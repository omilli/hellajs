# HellaJS Framework - LLM Code Reference

A reactive JavaScript framework with signals, CSS-in-JS, DOM utilities, data fetching, routing, and state management.

## Installation

```bash
npm install @hellajs/core @hellajs/dom @hellajs/css @hellajs/resource @hellajs/router @hellajs/store
```

## Core Package - Reactive Primitives

### signal - Reactive State
```typescript
import { signal } from '@hellajs/core';

// Create signal
const count = signal(0);

// Read value
console.log(count()); // 0

// Update value
count(5);
console.log(count()); // 5

// Object signals
const user = signal({ name: 'John', age: 30 });
user({ name: 'Jane', age: 25 }); // Replace entire object

// Array signals
const todos = signal([{ id: 1, text: 'Learn HellaJS' }]);
todos([...todos(), { id: 2, text: 'Build app' }]); // Add new item
```

### computed - Derived Values
```typescript
import { signal, computed } from '@hellajs/core';

const firstName = signal("John");
const lastName = signal("Doe");
const fullName = computed(() => `${firstName()} ${lastName()}`);

console.log(fullName()); // "John Doe"
firstName("Jane");
console.log(fullName()); // "Jane Doe"

// Chained computations
const price = signal(100);
const quantity = signal(2);
const subtotal = computed(() => price() * quantity());
const tax = computed(() => subtotal() * 0.07);
const total = computed(() => subtotal() + tax());

// Conditional dependencies
const showAdvanced = signal(false);
const basic = signal('basic');
const advanced = signal('advanced');
const setting = computed(() => {
  if (showAdvanced()) {
    return `Advanced: ${advanced()}`;
  }
  return `Basic: ${basic()}`;
});

// Previous value access
const items = signal([]);
const total = computed((previousTotal = 0) => {
  const currentItems = items();
  const newItems = currentItems.slice(lastCount);
  const additionalSum = newItems.reduce((sum, item) => sum + item.value, 0);
  lastCount = currentItems.length;
  return previousTotal + additionalSum;
});
```

### effect - Side Effects
```typescript
import { signal, effect } from '@hellajs/core';

const count = signal(0);

// Basic effect
const cleanup = effect(() => {
  console.log(`The count is: ${count()}`);
});

count(1); // Logs: "The count is: 1"
cleanup(); // Stop effect

// Conditional effects
const showData = signal(true);
const data = signal('value');
effect(() => {
  if (showData()) {
    console.log(data()); // Only reacts to 'data' when showData is true
  }
});

// Async operations in effects
const todoId = signal(1);
effect(() => {
  const id = todoId();
  fetch(`/api/todos/${id}`)
    .then(response => response.json())
    .then(data => console.log(data));
});
```

### batch - Group Updates
```typescript
import { signal, batch, effect } from '@hellajs/core';

const count = signal(1);
const multiplier = signal(2);

effect(() => {
  console.log(count() * multiplier());
});

// Without batch - effect runs twice
count(2); // Effect runs
multiplier(3); // Effect runs

// With batch - effect runs once
batch(() => {
  count(4);
  multiplier(5);
}); // Effect runs once with final values

// Nested batching
batch(() => {
  count(1);
  batch(() => {
    count(2);
    multiplier(2);
  });
  multiplier(3);
}); // Effect runs once with count=2, multiplier=3
```

### untracked - Non-reactive Reads
```typescript
import { signal, computed, untracked } from '@hellajs/core';

const value = signal(5);
const multiplier = signal(10);

const result = computed(() => {
  const currentValue = value(); // Tracked dependency
  const currentMultiplier = untracked(() => multiplier()); // Not tracked
  return currentValue * currentMultiplier;
});

console.log(result()); // 50
value(6); // Result recomputes
multiplier(20); // Result does NOT recompute
```

## CSS Package - CSS-in-JS

### css - Create Styles
```typescript
import { css } from '@hellajs/css';

// Basic styles
const buttonStyle = css({
  padding: '0.75rem 1.5rem',
  backgroundColor: '#3b82f6',
  color: 'white',
  border: 'none',
  borderRadius: '0.5rem',
  cursor: 'pointer'
});

// Nested selectors
const cardStyle = css({
  padding: '1rem',
  backgroundColor: 'white',
  borderRadius: '0.5rem',
  boxShadow: '0 1px 3px rgb-alpha(0, 0, 0, 0.1)',

  '&:hover': {
    transform: 'translateY(-2px)',
    boxShadow: '0 4px 12px rgb-alpha(0, 0, 0, 0.15)'
  },

  'h2': {
    margin: '0 0 0.5rem 0',
    fontSize: '1.25rem',
    fontWeight: '600'
  },

  '@media (max-width: 768px)': {
    padding: '0.75rem'
  }
});

// Custom class names
const navStyle = css({
  display: 'flex',
  justifyContent: 'space-between',
  alignItems: 'center'
}, { name: 'main-nav' });

// Scoped styles
const componentStyles = css({
  '.header': { fontSize: '1.5rem', fontWeight: 'bold' },
  '.content': { padding: '1rem' }
}, { scoped: '.my-component' });

// Global styles
css({
  '*': { boxSizing: 'border-box' },
  'body': { margin: 0, fontFamily: 'system-ui, sans-serif' }
}, { global: true });
```

### cssVars - CSS Variables
```typescript
import { signal } from '@hellajs/core';
import { cssVars, css } from '@hellajs/css';

// Static CSS variables
const theme = cssVars({
  colors: {
    primary: '#3b82f6',
    secondary: '#64748b'
  },
  spacing: {
    small: '0.5rem',
    medium: '1rem',
    large: '2rem'
  }
});

// Use in styles
const buttonStyle = css({
  backgroundColor: theme.colors.primary,
  color: theme.colors.background,
  padding: theme.spacing.medium
});

// Reactive CSS variables
const isDark = signal(false);
const primaryColor = signal('#3b82f6');

const reactiveTheme = cssVars({
  colors: {
    primary: primaryColor,
    background: () => isDark() ? '#1a1a1a' : '#ffffff',
    text: () => isDark() ? '#ffffff' : '#000000'
  }
});

// Variables update automatically when signals change
isDark(true); // CSS variables update automatically
primaryColor('#059669'); // CSS variables update automatically
```

### cssRemove - Clean Up Styles
```typescript
import { css, cssRemove } from '@hellajs/css';

const buttonStyle = css({
  background: 'blue',
  color: 'white',
  padding: '0.5rem 1rem'
});

// Remove style when no longer needed
cssRemove({
  background: 'blue',
  color: 'white',
  padding: '0.5rem 1rem'
});

// Component cleanup
class MyComponent {
  constructor() {
    this.styles = [
      css({ background: 'white', padding: '1rem' }),
      css({ color: 'blue', fontWeight: 'bold' })
    ];
  }

  destroy() {
    this.styles.forEach(styleObj => cssRemove(styleObj));
  }
}
```

### cssReset / cssVarsReset - Reset Systems
```typescript
import { css, cssReset, cssVarsReset } from '@hellajs/css';

// Clear all CSS rules and caches
cssReset();

// Clear all CSS variables and reactive effects
cssVarsReset();

// Complete reset
const resetAllCSS = () => {
  cssReset();
  cssVarsReset();
};
```

## DOM Package - DOM Utilities

### mount - Render to DOM
```typescript
import { signal } from '@hellajs/core';
import { mount } from '@hellajs/dom';

// Basic component
const Counter = () => {
  const count = signal(0);

  return (
    <div>
      <span>Count: {count()}</span>
      <button onClick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};

// Mount to DOM
mount(Counter, '#app');
mount(Counter); // Defaults to #app

// With cleanup
const App = () => {
  const timerId = setInterval(() => console.log('Tick'), 1000);

  return (
    <div onDestroy={() => clearInterval(timerId)}>
      Content
    </div>
  );
};

mount(App, '#app');
```

### forEach - Dynamic Lists
```typescript
import { signal } from '@hellajs/core';
import { forEach } from '@hellajs/dom';

const items = signal(['Apple', 'Banana', 'Cherry']);

// Basic list
<ul>
  {forEach(items, (fruit) =>
    <li>{fruit}</li>
  )}
</ul>

// With keys for optimization
const todos = signal([
  { id: 1, text: 'Learn HellaJS', done: false },
  { id: 2, text: 'Build app', done: false }
]);

<ul>
  {forEach(todos, (todo) =>
    <li key={todo.id}>
      <input type="checkbox" checked={todo.done} />
      {todo.text}
    </li>
  )}
</ul>

// Using id property (automatic key)
const users = signal([
  { id: 1, name: 'Alice' },
  { id: 2, name: 'Bob' }
]);

<ul>
  {forEach(users, (user) =>
    <li>{user.name}</li>
  )}
</ul>

// Updating lists (create new arrays)
const addItem = (newItem) => {
  items([...items(), newItem]); //  Triggers reactivity
  // items().push(newItem); // L Mutation doesn't trigger
};
```

### element - Single Element Enhancement
```typescript
import { signal } from '@hellajs/core';
import { element } from '@hellajs/dom';

// Basic element selection and manipulation
const count = signal(0);
const message = signal('Hello World');

// Text content (automatically detects form elements)
element('.title').text('Static text');
element('.counter').text(count); // Reactive
element('#username').text('john@example.com'); // Sets value for inputs
element('.dynamic').text(() => `Count: ${count()}`); // Function

// Attributes (static and reactive)
element('.button').attr({ 
  disabled: true,
  class: 'btn btn-primary'
});

element('.status').attr({
  'data-status': () => count() > 5 ? 'high' : 'low',
  class: () => `indicator ${count() > 5 ? 'active' : 'inactive'}`
});

// Event handlers
element('.increment').on('click', () => count(count() + 1));
element('.input').on('input', (e) => {
  message(e.target.value);
});

// Method chaining
element('.node')
  .text('Hello')
  .attr({ class: 'active', 'data-value': count })
  .on('click', () => console.log('Clicked'));

// Access raw DOM node
const wrapper = element('.my-element');
if (wrapper.node) {
  wrapper.node.focus();
}

// Graceful error handling for missing elements
element('.nonexistent')
  .text('test')
  .attr({ class: 'x' })
  .on('click', fn); // No errors thrown
```

### elements - Multiple Element Enhancement
```typescript
import { signal } from '@hellajs/core';
import { elements } from '@hellajs/dom';

const status = signal('loading');
const items = signal(['Apple', 'Banana', 'Cherry']);

// Apply operations to all matching elements
const statusElements = elements('.status-indicator');

statusElements.forEach((elem, index) => {
  elem.text(() => `Status: ${status()}`)
    .attr({ 
      class: () => `indicator ${status()}`,
      'data-index': index.toString()
    })
    .on('click', () => console.log(`Clicked indicator ${index}`));
});

// Reactive updates to collections
const listElements = elements('.fruit-item');
listElements.forEach((elem, index) => {
  elem.text(() => items()[index] || 'Empty');
});

// Check collection length
const items = elements('.item');
if (items.length > 0) {
  items.forEach(elem => elem.text('Found!'));
}

// Performance consideration for large collections
const manyElements = elements('.item');

// Reactive (automatic cleanup, slight overhead)
manyElements.forEach(elem => elem.text(() => computedValue()));

// Direct DOM (faster, manual cleanup required)
manyElements.forEach(elem => {
  if (elem.node) {
    elem.node.textContent = staticValue;
  }
});
```

### nodeRegistry - Low-level DOM Management
```typescript
import { nodeRegistry } from '@hellajs/dom';
import { signal } from '@hellajs/core';

const element = document.createElement('div');
const count = signal(0);

// Register reactive effect
nodeRegistry.addEffect(element, () => {
  element.textContent = `Count: ${count()}`;
});

// Register event handler
nodeRegistry.addEvent(element, 'click', (event) => {
  count(count() + 1);
});

// Manual cleanup (rarely needed)
nodeRegistry.clean(element);

// Inspect registry
console.log('Total nodes:', nodeRegistry.nodes.size);
const registry = nodeRegistry.get(element);
console.log('Effects:', registry.effects?.size || 0);
console.log('Events:', registry.events?.size || 0);
```

## Resource Package - Data Fetching

### resource - Basic Usage
```typescript
import { resource } from '@hellajs/resource';
import { signal } from '@hellajs/core';

// URL-based resource
const users = resource('/api/users');
users.request(); // Trigger fetch

// Function-based resource
const todos = resource(() =>
  fetch('/api/todos').then(r => r.json())
);
todos.request();

// Access state
console.log(todos.loading()); // boolean
console.log(todos.error());   // ResourceError | undefined
console.log(todos.data());    // T | undefined
console.log(todos.status());  // 'idle' | 'loading' | 'success' | 'error'

// Resource with reactive key
const userId = signal(1);
const userPosts = resource(
  id => fetch(`/api/users/${id}/posts`).then(r => r.json()),
  { key: () => userId() }
);

userPosts.request();
userId(2); // Change key
userPosts.invalidate(); // Refetch with new key
```

### resource - Auto-fetch Mode
```typescript
import { resource } from '@hellajs/resource';
import { signal } from '@hellajs/core';

const userId = signal(1);

// Auto-fetch when key changes
const userPosts = resource(
  id => fetch(`/api/users/${id}/posts`).then(r => r.json()),
  {
    key: () => userId(),
    auto: true // Automatically refetch when userId changes
  }
);

// No need to call .request() - fetches automatically
// Changing userId triggers automatic refetch
userId(2); // Automatically fetches posts for user 2
```

### resource - Configuration Options
```typescript
import { resource } from '@hellajs/resource';
import { signal } from '@hellajs/core';

const userId = signal(1);

const user = resource(
  id => fetch(`/api/users/${id}`).then(r => r.json()),
  {
    key: () => userId(),
    auto: true,
    initialData: { name: 'Loading...', email: '' },
    cacheTime: 5 * 60 * 1000, // 5 minutes
    timeout: 10000, // 10 seconds
    enabled: true,
    deduplicate: true,
    onSuccess: (data) => console.log('User loaded:', data.name),
    onError: (error) => console.error('Failed to load user:', error)
  }
);

// Cache control
user.get();        // Cache-first
user.request();    // Force fresh
user.invalidate(); // Clear cache and refetch

// State management
user.setData({ name: 'Updated Name' }); // Update cached data
user.reset(); // Reset to initial state
user.abort(); // Cancel ongoing request
```

### resource - Mutations
```typescript
import { resource } from '@hellajs/resource';

// Mutation resource
const createUser = resource(
  async (userData) => {
    const response = await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    });
    return response.json();
  },
  {
    onMutate: async (variables) => {
      // Optimistic update
      console.log('Starting mutation with:', variables);
      return { previousData: userResource.data() };
    },
    onSuccess: (data) => {
      console.log('User created:', data);
    },
    onError: (error) => {
      console.error('Mutation failed:', error);
    },
    onSettled: (data, error, variables, context) => {
      if (error) {
        console.log('Rollback if needed');
      } else {
        console.log('Mutation succeeded');
      }
    }
  }
);

// Execute mutation
const handleSubmit = async (formData) => {
  try {
    const result = await createUser.mutate(formData);
    console.log('Created:', result);
  } catch (error) {
    console.error('Failed:', error);
  }
};
```

### resourceCache - Global Cache Management
```typescript
import { resourceCache } from '@hellajs/resource';

// Configuration
resourceCache.setConfig({
  maxSize: 2000,
  enableLRU: true
});

// Direct cache operations
resourceCache.set('user:123', { name: 'John' }, 300000); // 5 min TTL
const user = resourceCache.get('user:123');

// Batch operations
resourceCache.updateMultiple([
  { key: 'user:1', updater: user => ({ ...user, online: true }) },
  { key: 'user:2', updater: { status: 'active' } }
]);

resourceCache.invalidateMultiple(['user:1', 'user:2', 'posts:user:1']);

// Key generation
const userKeyGen = resourceCache.generateKeys<{id: number}>()
  (params => `user:${params.id}`);
const userKey = userKeyGen({ id: 123 }); // 'user:123'

// Cleanup
resourceCache.cleanup(); // Remove expired entries

// Inspect cache
console.log('Cache size:', resourceCache.map.size);
console.log('Config:', resourceCache.config);
```

## Router Package - Client-side Routing

### router - Basic Setup
```typescript
import { router, navigate, route } from '@hellajs/router';
import { signal } from '@hellajs/core';

const currentView = signal('Loading...');

// Basic routing
router({
  routes: {
    '/': () => currentView('HomePage'),
    '/users/:id': (params, query) => {
      currentView(`UserProfile: ${params.id}`);
      return { userId: params.id };
    },
    '/files/*': (params, query) => {
      currentView(`FileViewer: ${params['*']}`);
      return { filePath: params['*'] };
    },
    '/search': (params, query) => {
      currentView(`SearchResults: ${query.q}`);
      return { term: query.q };
    }
  }
});

// Navigation
navigate('/dashboard');
navigate('/users/:id', { id: '123' });
navigate('/search', {}, { q: 'react', page: '2' });
navigate('/redirect', {}, {}, { replace: true });

// Access route info
const { path, params, query, handler } = route();
```

### router - Nested Routes
```typescript
import { router } from '@hellajs/router';
import { signal } from '@hellajs/core';

const currentView = signal('Loading...');

router({
  routes: {
    '/admin': {
      handler: () => currentView('AdminDashboard'),
      before: () => requireAuth(),
      children: {
        '/users': {
          handler: () => currentView('UsersList'),
          children: {
            '/:id': (params) => currentView(`UserDetail: ${params.id}`),
            '/:id/edit': (params) => currentView(`UserEdit: ${params.id}`)
          }
        },
        '/settings': () => currentView('AdminSettings')
      }
    }
  },
  hooks: {
    before: () => console.log('Global before hook')
  },
  redirects: [
    { from: ['/home', '/start'], to: '/dashboard' }
  ],
  notFound: () => currentView('404 Not Found')
});
```

### router - Hooks and Lifecycle
```typescript
import { router } from '@hellajs/router';

router({
  routes: {
    '/protected': {
      before: () => {
        const authResult = checkAuth();
        if (!authResult) {
          navigate('/login');
          return { authenticated: false };
        }
        return { authenticated: true };
      },
      handler: (params, query) => {
        currentView('ProtectedPage');
        return { page: 'protected' };
      },
      after: () => {
        trackPageView('protected');
        return { tracked: true };
      }
    }
  },
  hooks: {
    before: () => ({ globalBefore: true }),
    after: () => ({ globalAfter: true })
  }
});
```

### route - Reactive Route Info
```typescript
import { route } from '@hellajs/router';
import { effect, computed } from '@hellajs/core';

// Access current route reactively
effect(() => {
  const { path, params, query } = route();
  console.log(`Current path: ${path}`);

  if (params.id) {
    console.log(`ID param: ${params.id}`);
  }

  if (query.sort) {
    console.log(`Sort: ${query.sort}`);
  }
});

// Computed route values
const currentPath = computed(() => route().path);
const routeParams = computed(() => route().params);
const hasQueryParams = computed(() => Object.keys(route().query).length > 0);

// Type-safe parameter access
const userId = computed(() => parseInt(route().params.id) || 0);
const page = computed(() => parseInt(route().query.page) || 1);
```

### navigate - Programmatic Navigation
```typescript
import { navigate } from '@hellajs/router';

// Basic navigation
navigate('/dashboard');

// With parameters
navigate('/users/:id', { id: '123' }); // /users/123

// With query strings
navigate('/search', {}, { q: 'react', page: '2' }); // /search?q=react&page=2

// With both
navigate('/users/:id/posts', { id: '123' }, { sort: 'date' }); // /users/123/posts?sort=date

// History control
navigate('/dashboard', {}, {}, { replace: true }); // Replace current entry

// Parameter encoding
navigate('/search/:term', { term: 'hello world & more!' }); // Automatically URL encoded

// Async usage
effect(() => {
  if (route().path === '/dashboard') {
    console.log('Dashboard loaded');
  }
});

navigate('/dashboard'); // Effect will trigger when route changes
```

## Store Package - State Management

### store - Basic Usage
```typescript
import { store } from '@hellajs/store';
import { effect } from '@hellajs/core';

// Create store
const userStore = store({
  profile: {
    name: 'John',
    age: 30
  },
  settings: {
    theme: 'dark',
    notifications: true
  }
});

// Access nested reactive properties
effect(() => {
  console.log(userStore.profile.name()); // Reactive to name changes
  console.log(userStore.settings.theme()); // Reactive to theme changes
});

// Update properties
userStore.profile.name('Jane');
userStore.settings.theme('light');

// Get full snapshot
const snapshot = userStore.snapshot();
console.log(snapshot); // { profile: { name: 'Jane', age: 30 }, settings: { theme: 'light', notifications: true } }

// Replace entire state
userStore.set({
  profile: { name: 'Bob', age: 25 },
  settings: { theme: 'dark', notifications: false }
});

// Partial updates
userStore.update({
  profile: { age: 31 }, // Only updates age, name stays the same
  settings: { notifications: false }
});
```

### store - Readonly Properties
```typescript
import { store } from '@hellajs/store';

// Store with readonly properties
const configStore = store(
  {
    apiUrl: 'https://api.com',
    theme: 'light',
    debug: false
  },
  { readonly: ['apiUrl'] } // apiUrl cannot be modified
);

configStore.theme('dark'); //  Works
configStore.debug(true);   //  Works
configStore.apiUrl('new-url'); // L No effect, readonly

// Complete readonly store
const readonlyStore = store(
  { config: 'value' },
  { readonly: true }
);

readonlyStore.config('new'); // L No effect
```

### store - Cleanup and Memory Management
```typescript
import { store } from '@hellajs/store';
import { effect } from '@hellajs/core';

const appStore = store({
  count: 0,
  user: { name: 'Alice' }
});

// Create effects that use the store
const cleanup1 = effect(() => {
  console.log('Count:', appStore.count());
});

const cleanup2 = effect(() => {
  console.log('User:', appStore.user.name());
});

// Clean up store when no longer needed
appStore.cleanup(); // Disposes all reactive subscriptions

// Individual effect cleanup
cleanup1();
cleanup2();

// Store can still be used but won't be reactive
appStore.count(10); // No reactive updates after cleanup
```

## JSX and Component Patterns

### Basic Components
```typescript
import { signal } from '@hellajs/core';
import { mount } from '@hellajs/dom';

// Function component
const Counter = () => {
  const count = signal(0);

  return (
    <div>
      <h1>Count: {count()}</h1>
      <button onClick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};

// Component with props
const Greeting = ({ name, age }) => (
  <div>
    <h1>Hello, {name}!</h1>
    <p>You are {age} years old.</p>
  </div>
);

// Mount components
mount(Counter, '#app');
mount(<Greeting name="John" age={30} />, '#app');
```

### Reactive Components with Effects
```typescript
import { signal, effect } from '@hellajs/core';
import { mount, forEach } from '@hellajs/dom';

const TodoApp = () => {
  const todos = signal([]);
  const newTodo = signal('');

  const addTodo = () => {
    if (newTodo().trim()) {
      todos([...todos(), {
        id: Date.now(),
        text: newTodo(),
        completed: false
      }]);
      newTodo('');
    }
  };

  const toggleTodo = (id) => {
    todos(todos().map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  return (
    <div>
      <h1>Todo App</h1>
      <div>
        <input
          type="text"
          value={newTodo()}
          onInput={(e) => newTodo(e.target.value)}
          placeholder="Add new todo..."
        />
        <button onClick={addTodo}>Add</button>
      </div>

      <ul>
        {forEach(todos, (todo) => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => toggleTodo(todo.id)}
            />
            <span style={{
              textDecoration: todo.completed ? 'line-through' : 'none'
            }}>
              {todo.text}
            </span>
          </li>
        ))}
      </ul>
    </div>
  );
};

mount(TodoApp);
```

### Components with Resources
```typescript
import { signal } from '@hellajs/core';
import { resource } from '@hellajs/resource';
import { mount, forEach } from '@hellajs/dom';

const UserList = () => {
  const users = resource('/api/users', { auto: true });

  return (
    <div>
      <h1>Users</h1>

      {users.loading() && <p>Loading users...</p>}

      {users.error() && (
        <p style={{ color: 'red' }}>
          Error: {users.error().message}
        </p>
      )}

      {users.data() && (
        <ul>
          {forEach(users.data(), (user) => (
            <li key={user.id}>
              <strong>{user.name}</strong> - {user.email}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
};

mount(UserList);
```

### Styled Components
```typescript
import { signal } from '@hellajs/core';
import { css, cssVars } from '@hellajs/css';
import { mount } from '@hellajs/dom';

const theme = cssVars({
  colors: {
    primary: '#3b82f6',
    danger: '#ef4444',
    success: '#10b981'
  },
  spacing: {
    sm: '0.5rem',
    md: '1rem',
    lg: '1.5rem'
  }
});

const Button = ({ variant = 'primary', children, onClick }) => {
  const buttonStyle = css({
    padding: `${theme.spacing.sm} ${theme.spacing.md}`,
    border: 'none',
    borderRadius: '0.375rem',
    cursor: 'pointer',
    fontWeight: '500',
    backgroundColor: theme.colors[variant],
    color: 'white',

    '&:hover': {
      opacity: '0.9'
    },

    '&:active': {
      transform: 'translateY(1px)'
    }
  });

  return (
    <button class={buttonStyle} onClick={onClick}>
      {children}
    </button>
  );
};

const StyledApp = () => {
  const count = signal(0);

  return (
    <div>
      <h1>Count: {count()}</h1>
      <div>
        <Button variant="success" onClick={() => count(count() + 1)}>
          Increment
        </Button>
        <Button variant="danger" onClick={() => count(count() - 1)}>
          Decrement
        </Button>
        <Button onClick={() => count(0)}>
          Reset
        </Button>
      </div>
    </div>
  );
};

mount(StyledApp);
```

## Common Patterns and Best Practices

### State Management Patterns
```typescript
import { signal, computed, batch } from '@hellajs/core';
import { store } from '@hellajs/store';

// Global application state
const appState = store({
  user: null,
  theme: 'light',
  notifications: [],
  loading: false
});

// Computed values from state
const isAuthenticated = computed(() => !!appState.user());
const unreadCount = computed(() =>
  appState.notifications().filter(n => !n.read).length
);

// State actions
const actions = {
  login: (userData) => {
    batch(() => {
      appState.user(userData);
      appState.loading(false);
    });
  },

  logout: () => {
    batch(() => {
      appState.user(null);
      appState.notifications([]);
    });
  },

  toggleTheme: () => {
    const current = appState.theme();
    appState.theme(current === 'light' ? 'dark' : 'light');
  },

  addNotification: (notification) => {
    appState.notifications([
      ...appState.notifications(),
      { ...notification, id: Date.now(), read: false }
    ]);
  }
};
```

### Error Handling Patterns
```typescript
import { signal, effect } from '@hellajs/core';
import { resource } from '@hellajs/resource';

// Error boundary pattern
const createErrorBoundary = () => {
  const error = signal(null);

  const handleError = (err) => {
    console.error('Application error:', err);
    error(err);
  };

  // Global error handler
  window.addEventListener('error', (e) => handleError(e.error));
  window.addEventListener('unhandled-rejection', (e) => handleError(e.reason));

  return { error, handleError };
};

// Resource error handling
const apiData = resource('/api/data', {
  onError: (error) => {
    if (error.category === 'network') {
      console.log('Network error - showing offline message');
    } else if (error.category === 'authorization') {
      console.log('Auth error - redirecting to login');
    } else {
      console.log('Unknown error:', error.message);
    }
  }
});

// Safe computed values
const safeComputed = computed(() => {
  try {
    return riskyCalculation();
  } catch (error) {
    console.error('Computation error:', error);
    return fallbackValue;
  }
});
```

### Performance Optimization Patterns
```typescript
import { signal, computed, batch, untracked } from '@hellajs/core';

// Batch multiple updates
const updateUserProfile = (updates) => {
  batch(() => {
    if (updates.name) userStore.profile.name(updates.name);
    if (updates.email) userStore.profile.email(updates.email);
    if (updates.avatar) userStore.profile.avatar(updates.avatar);
  });
};

// Use untracked for non-reactive reads
const expensiveComputation = computed(() => {
  const data = primaryData(); // Tracked
  const config = untracked(() => configData()); // Not tracked
  return processData(data, config);
});

// Memoize expensive operations
const memoizedResults = new Map();
const expensiveOperation = computed(() => {
  const input = inputData();
  const key = JSON.stringify(input);

  if (!memoizedResults.has(key)) {
    memoizedResults.set(key, heavyCalculation(input));
  }

  return memoizedResults.get(key);
});

// Optimize large lists with stable keys
const optimizedList = forEach(items, (item) => (
  <ListItem key={item.id} item={item} />
));

// Use reference equality for arrays/objects
const updateItems = (newItem) => {
  const current = items();
  // Only update if actually different
  if (!current.some(item => item.id === newItem.id)) {
    items([...current, newItem]);
  }
};
```

### Testing Patterns
```typescript
import { signal, effect, flush } from '@hellajs/core';
import { mount } from '@hellajs/dom';

// Test reactive behavior
describe('Counter Component', () => {
  let container;

  beforeEach(() => {
    container = document.createElement('div');
    document.body.appendChild(container);
  });

  afterEach(() => {
    document.body.removeChild(container);
  });

  test('should update count when button clicked', () => {
    const count = signal(0);

    mount(() => (
      <div>
        <span data-testid="count">{count()}</span>
        <button data-testid="increment" onClick={() => count(count() + 1)}>
          +
        </button>
      </div>
    ), container);

    // Force effects to run
    flush();

    expect(container.querySelector('[data-testid="count"]').textContent).toBe('0');

    // Simulate click
    container.querySelector('[data-testid="increment"]').click();
    flush();

    expect(container.querySelector('[data-testid="count"]').textContent).toBe('1');
  });
});

// Test resources
describe('API Resource', () => {
  test('should handle successful fetch', async () => {
    const mockData = { id: 1, name: 'Test' };
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve(mockData)
      })
    );

    const apiResource = resource('/api/test');
    apiResource.request();

    // Wait for async operation
    await new Promise(resolve => {
      effect(() => {
        if (apiResource.status() === 'success') {
          expect(apiResource.data()).toEqual(mockData);
          resolve();
        }
      });
    });
  });
});
```

This comprehensive reference covers all the major features and patterns for building applications with HellaJS. Each code example is practical and shows real-world usage patterns that LLM coding agents can use to understand and implement HellaJS applications.