---
title: untracked()
description: API reference for reading reactive values without creating dependencies in the current reactive context.
---

import { Aside, Code } from '@astrojs/starlight/components';

Executes a function without tracking any signal dependencies. Any signals read within the untracked function will not cause the current reactive context (effect, computed, etc.) to re-run when those signals change.

## Function Signature

```typescript
function untracked<T>(fn: () => T): T
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `fn` | `() => T` | The function to execute without dependency tracking. Can return any value. |

## Returns

The return value of the executed function.

## Quick Example

```jsx
import { signal, computed, untracked } from '@hellajs/core';

const count = signal(0);
const multiplier = signal(2);

// Computed only depends on count, not multiplier
const result = computed(() => {
  const currentCount = count();
  const currentMultiplier = untracked(() => multiplier());
  return currentCount * currentMultiplier;
});

console.log(result()); // 0

count(5);
console.log(result()); // 10 (recomputed)

multiplier(3);
console.log(result()); // 10 (NOT recomputed - no dependency on multiplier)
```

## Usage Patterns

### Reading Current Values Without Dependencies

```typescript
const x = signal(10);
const y = signal(20);

const manhattanDistance = computed(() => {
  const currentX = x();
  // Read y without creating dependency
  const currentY = untracked(() => y());
  return Math.abs(currentX) + Math.abs(currentY);
});

x(15); // manhattanDistance recomputes
y(30); // manhattanDistance does NOT recompute
```

### Preventing Infinite Loops

```typescript
const counter = signal(0);

effect(() => {
  const current = untracked(() => counter());
  
  // Safe to update counter based on its current value
  if (current < 10) {
    counter(current + 1);
  }
});
```

### Conditional Dependencies

```typescript
const showDetails = signal(false);
const basicData = signal('basic');
const detailData = signal('detail');

const displayData = computed(() => {
  if (showDetails()) {
    return detailData(); // Creates dependency on detailData
  } else {
    // Read detailData without dependency for comparison
    const detail = untracked(() => detailData());
    return basicData() + (detail ? ' (details available)' : '');
  }
});
```

### Performance Optimization

```typescript
const items = signal<Item[]>([]);
const selectedId = signal<string | null>(null);

// Only recompute when items change, not when selection changes
const itemsWithSelection = computed(() => {
  const allItems = items();
  const selected = untracked(() => selectedId());
  
  return allItems.map(item => ({
    ...item,
    isSelected: item.id === selected
  }));
});
```

## Effect Optimization

### Avoiding Unnecessary Effect Runs

```typescript
const data = signal<Data[]>([]);
const lastProcessed = signal<Date | null>(null);

effect(() => {
  const currentData = data();
  const lastTime = untracked(() => lastProcessed());
  
  // Only process if data changed, not if lastProcessed changed
  if (currentData.length > 0) {
    processData(currentData);
    lastProcessed(new Date());
  }
});
```

### Reading Configuration Without Dependencies

```typescript
const userPrefs = signal({ theme: 'light', lang: 'en' });
const currentData = signal<any[]>([]);

effect(() => {
  const data = currentData();
  // Read preferences without making effect depend on them
  const prefs = untracked(() => userPrefs());
  
  renderData(data, prefs);
});
```

## State Management Patterns

### Reading Previous State

```typescript
const todos = signal<Todo[]>([]);

const addTodo = (text: string) => {
  const newTodo = {
    id: generateId(),
    text,
    completed: false
  };
  
  // Read current todos without dependency in this context
  const current = untracked(() => todos());
  todos([...current, newTodo]);
};
```

### Selective Reactivity

```typescript
const form = {
  name: signal(''),
  email: signal(''),
  age: signal(0)
};

// Only validate when name or email change, ignore age
const isValid = computed(() => {
  const name = form.name();
  const email = form.email();
  const age = untracked(() => form.age()); // No dependency on age
  
  return name.length > 0 && email.includes('@') && age >= 0;
});
```

## API Integration

### Reading Tokens Without Dependencies

```typescript
const authToken = signal<string | null>(null);
const apiData = signal<any>(null);

effect(() => {
  // Trigger refetch when apiData invalidated, but not when token changes
  if (apiData() === null) {
    const token = untracked(() => authToken());
    
    if (token) {
      fetch('/api/data', {
        headers: { Authorization: `Bearer ${token}` }
      })
      .then(response => response.json())
      .then(data => apiData(data));
    }
  }
});
```

### Cache Key Generation

```typescript
const userId = signal<number | null>(null);
const cacheVersion = signal(1);

const cacheKey = computed(() => {
  const id = userId();
  const version = untracked(() => cacheVersion());
  
  // Only regenerate cache key when userId changes, not version
  return id ? `user-${id}` : null;
});
```

## Debugging and Logging

### Safe Logging in Effects

```typescript
const debugMode = signal(false);
const appState = signal<AppState>({});

effect(() => {
  const state = appState();
  
  // Log without creating dependency on debugMode
  if (untracked(() => debugMode())) {
    console.log('State updated:', state);
  }
  
  updateUI(state);
});
```

### Performance Monitoring

```typescript
const operationCount = signal(0);
const data = signal<any[]>([]);

const processedData = computed(() => {
  const items = data();
  
  // Count operations without creating dependency
  untracked(() => {
    operationCount(operationCount() + 1);
  });
  
  return expensiveProcessing(items);
});
```

## Error Handling

```typescript
const errorCount = signal(0);
const apiCall = signal<Promise<any> | null>(null);

effect(() => {
  const call = apiCall();
  
  if (call) {
    call.catch(error => {
      console.error('API Error:', error);
      
      // Update error count without creating dependency
      untracked(() => {
        errorCount(errorCount() + 1);
      });
    });
  }
});
```

<Aside type="note">
Use `untracked()` when you need to read reactive values for side effects, logging, or performance optimizations without affecting the dependency graph.
</Aside>

## Best Practices

### ✅ Do This

```typescript
// Prevent infinite loops
effect(() => {
  const current = untracked(() => counter());
  if (current < limit) {
    counter(current + 1);
  }
});

// Read configuration without dependencies
computed(() => {
  const data = dataSignal();
  const config = untracked(() => configSignal());
  return processWithConfig(data, config);
});
```

### ❌ Avoid This

```typescript
// Don't overuse untracked - you might miss important updates
computed(() => {
  // This computed will never update!
  return untracked(() => importantSignal()) * 2;
});

// Don't use untracked when you actually want dependencies
effect(() => {
  const value = untracked(() => signal());
  updateUI(value); // UI won't update when signal changes!
});
```

## Related APIs

- [`signal()`](/api/core/signal) - Create reactive state that can be read with untracked
- [`computed()`](/api/core/computed) - Create derived values where untracked can prevent dependencies
- [`effect()`](/api/core/effect) - Create side effects where untracked can prevent infinite loops
- [`batch()`](/api/core/batch) - Group multiple updates together

## See Also

- [Understanding Reactivity](/concepts/reactivity) - Learn how dependency tracking works
- [Performance Optimization](/concepts/performance) - Best practices for efficient reactive code