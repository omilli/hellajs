---
title: effect()
description: API reference for creating side effects that run automatically when reactive dependencies change.
---

import { Aside, Code } from '@astrojs/starlight/components';

Creates a reactive effect that executes a function whenever its dependencies change. Effects are used for side effects like DOM manipulation, API calls, logging, and other operations that shouldn't return values.

## Function Signature

```typescript
function effect(fn: () => void): () => void
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `fn` | `() => void` | The function to execute. Any signals read within this function become dependencies. |

## Returns

A cleanup function that, when called, stops the effect and removes all its dependencies.

## Quick Example

```jsx
import { signal, effect } from '@hellajs/core';

const count = signal(0);

// Effect runs immediately and whenever count changes
const cleanup = effect(() => {
  console.log(`Count is now: ${count()}`);
});

count(1); // Logs: "Count is now: 1"
count(2); // Logs: "Count is now: 2"

// Stop the effect
cleanup();
count(3); // No log output
```

## Usage Patterns

### DOM Manipulation

```typescript
const isVisible = signal(true);
const element = document.getElementById('modal');

effect(() => {
  if (element) {
    element.style.display = isVisible() ? 'block' : 'none';
  }
});
```

### API Calls

```typescript
const userId = signal<number | null>(null);
const userData = signal<User | null>(null);

effect(() => {
  const id = userId();
  if (id) {
    fetch(`/api/users/${id}`)
      .then(response => response.json())
      .then(user => userData(user));
  }
});
```

### Local Storage Sync

```typescript
const preferences = signal({ theme: 'light', language: 'en' });

effect(() => {
  localStorage.setItem('preferences', JSON.stringify(preferences()));
});

// Load from storage on startup
const stored = localStorage.getItem('preferences');
if (stored) {
  preferences(JSON.parse(stored));
}
```

### Logging and Analytics

```typescript
const currentPage = signal('/home');
const userId = signal<string | null>(null);

effect(() => {
  const page = currentPage();
  const user = userId();
  
  if (user) {
    analytics.track('page_view', {
      page,
      userId: user
    });
  }
});
```

## Cleanup and Resource Management

### Manual Cleanup

```typescript
const intervalEffect = effect(() => {
  const interval = setInterval(() => {
    console.log(`Timer: ${Date.now()}`);
  }, 1000);
  
  // Note: This won't automatically clean up the interval
  // You need to handle cleanup separately
});

// Stop the effect (but interval keeps running)
intervalEffect();
```

### Proper Resource Management

```typescript
const createTimerEffect = () => {
  let cleanup: (() => void) | null = null;
  
  const effectCleanup = effect(() => {
    // Clean up previous timer
    if (cleanup) cleanup();
    
    const interval = setInterval(() => {
      console.log(`Timer: ${Date.now()}`);
    }, 1000);
    
    cleanup = () => clearInterval(interval);
  });
  
  return () => {
    if (cleanup) cleanup();
    effectCleanup();
  };
};
```

### Component Lifecycle Integration

```typescript
const UserProfile = ({ userId }: { userId: number }) => {
  const userData = signal<User | null>(null);
  const loading = signal(true);
  
  // Effect runs when component mounts and when userId changes
  const cleanup = effect(() => {
    loading(true);
    fetch(`/api/users/${userId}`)
      .then(response => response.json())
      .then(user => {
        userData(user);
        loading(false);
      })
      .catch(() => loading(false));
  });
  
  // Clean up when component unmounts
  onCleanup(cleanup);
  
  return (
    <div>
      {loading() ? <p>Loading...</p> : <UserDisplay user={userData()} />}
    </div>
  );
};
```

## Multiple Dependencies

```typescript
const firstName = signal('John');
const lastName = signal('Doe');
const age = signal(30);

// Effect depends on all three signals
effect(() => {
  const full = `${firstName()} ${lastName()}`;
  const years = age();
  
  document.title = `${full} (${years} years old)`;
});

// Any change triggers the effect
firstName('Jane');  // Updates title
age(31);           // Updates title
```

## Conditional Dependencies

```typescript
const showDetails = signal(false);
const basicInfo = signal('Basic');
const detailedInfo = signal('Detailed');

effect(() => {
  // Only depends on detailedInfo when showDetails is true
  const info = showDetails() ? detailedInfo() : basicInfo();
  
  updateDisplay(info);
});
```

## Nested Effects

```typescript
const parentSignal = signal('parent');

effect(() => {
  console.log(`Parent: ${parentSignal()}`);
  
  // Nested effect inherits parent's lifecycle
  effect(() => {
    console.log(`Child effect running`);
  });
});
```

<Aside type="caution">
Effects run immediately when created and then whenever their dependencies change. Make sure your effect function is idempotent and handles being called multiple times.
</Aside>

## Error Handling

```typescript
const dataSource = signal<string>('api/data');

effect(() => {
  try {
    fetch(dataSource())
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }
        return response.json();
      })
      .then(data => processData(data))
      .catch(error => {
        console.error('Effect error:', error);
        handleError(error);
      });
  } catch (error) {
    console.error('Synchronous effect error:', error);
  }
});
```

## Performance Considerations

### Debouncing Effects

```typescript
const searchTerm = signal('');
let debounceTimer: number | null = null;

effect(() => {
  const term = searchTerm();
  
  if (debounceTimer) {
    clearTimeout(debounceTimer);
  }
  
  debounceTimer = setTimeout(() => {
    if (term.length > 2) {
      performSearch(term);
    }
  }, 300);
});
```

### Avoiding Infinite Loops

```typescript
const counter = signal(0);

// ❌ Dangerous: Effect modifies its own dependency
effect(() => {
  const current = counter();
  if (current < 10) {
    counter(current + 1); // This creates an infinite loop!
  }
});

// ✅ Safe: Use untracked for reads that shouldn't create dependencies
effect(() => {
  const shouldIncrement = someCondition();
  if (shouldIncrement) {
    counter(untracked(() => counter()) + 1);
  }
});
```

## Related APIs

- [`signal()`](/api/core/signal) - Create reactive state that effects can depend on
- [`computed()`](/api/core/computed) - Create derived values that effects can watch
- [`batch()`](/api/core/batch) - Group multiple updates to prevent excessive effect runs
- [`untracked()`](/api/core/untracked) - Read signals without creating dependencies

## See Also

- [Understanding Reactivity](/concepts/reactivity) - Learn how dependency tracking works
- [Effect Guide](/packages/core/effect) - Comprehensive guide with lifecycle management patterns