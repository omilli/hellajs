---
title: batch()
description: API reference for grouping multiple signal updates to prevent intermediate effect executions.
---

import { Aside, Code } from '@astrojs/starlight/components';

Executes a function while batching all signal updates within it. Effects and other reactive computations are deferred until the outermost batch operation completes, preventing unnecessary intermediate executions.

## Function Signature

```typescript
function batch<T>(fn: () => T): T
```

## Parameters

| Parameter | Type | Description |
|-----------|------|-------------|
| `fn` | `() => T` | The function to execute while batching updates. Can return any value. |

## Returns

The return value of the executed function.

## Quick Example

```jsx
import { signal, effect, batch } from '@hellajs/core';

const firstName = signal('John');
const lastName = signal('Doe');

effect(() => {
  console.log(`Name: ${firstName()} ${lastName()}`);
});
// Logs: "Name: John Doe"

// Without batch - effect runs twice
firstName('Jane');  // Logs: "Name: Jane Doe"
lastName('Smith');  // Logs: "Name: Jane Smith"

// With batch - effect runs only once
batch(() => {
  firstName('Bob');
  lastName('Johnson');
});
// Logs: "Name: Bob Johnson" (only once)
```

## Usage Patterns

### Updating Multiple Related Signals

```typescript
const user = {
  name: signal(''),
  email: signal(''),
  age: signal(0)
};

const updateUser = (userData: UserData) => {
  batch(() => {
    user.name(userData.name);
    user.email(userData.email);
    user.age(userData.age);
  });
  // All effects run once after all updates complete
};
```

### Form State Management

```typescript
const formData = {
  name: signal(''),
  email: signal(''),
  phone: signal('')
};

const resetForm = () => {
  batch(() => {
    formData.name('');
    formData.email('');
    formData.phone('');
  });
};

const loadFormData = (data: FormData) => {
  batch(() => {
    formData.name(data.name);
    formData.email(data.email);
    formData.phone(data.phone);
  });
};
```

### Complex State Transitions

```typescript
const gameState = {
  score: signal(0),
  level: signal(1),
  lives: signal(3),
  powerUps: signal<string[]>([])
};

const levelUp = () => {
  batch(() => {
    gameState.level(gameState.level() + 1);
    gameState.score(gameState.score() + 1000);
    gameState.lives(gameState.lives() + 1);
    gameState.powerUps(['shield', 'boost']);
  });
};
```

### Preventing Intermediate Effects

```typescript
const x = signal(0);
const y = signal(0);

// Expensive effect that should only run once per coordinate update
effect(() => {
  const position = { x: x(), y: y() };
  expensiveRenderOperation(position);
});

// Move to new position - effect runs only once
const moveTo = (newX: number, newY: number) => {
  batch(() => {
    x(newX);
    y(newY);
  });
};
```

## Nested Batching

```typescript
const signals = {
  a: signal(1),
  b: signal(2),
  c: signal(3)
};

effect(() => {
  console.log(`Values: ${signals.a()}, ${signals.b()}, ${signals.c()}`);
});

// Nested batches work correctly
batch(() => {
  signals.a(10);
  
  batch(() => {
    signals.b(20);
    signals.c(30);
  });
  
  signals.a(100);
});
// Effect runs only once: "Values: 100, 20, 30"
```

## Return Values

```typescript
const calculate = () => {
  return batch(() => {
    const a = signalA(10);
    const b = signalB(20);
    return a + b; // Returns 30
  });
};

const result = calculate(); // 30
```

## Async Operations

<Aside type="caution">
Batch only applies to synchronous operations within the function. Async operations that complete later are not batched.
</Aside>

```typescript
// ❌ Async updates are not batched
const asyncUpdate = async () => {
  batch(() => {
    signal1('immediate');
    
    setTimeout(() => {
      signal2('delayed'); // This is NOT batched
    }, 100);
  });
};

// ✅ Batch each group of synchronous updates
const properAsyncUpdate = async () => {
  batch(() => {
    signal1('immediate');
    signal2('also immediate');
  });
  
  await someAsyncOperation();
  
  batch(() => {
    signal3('after async');
    signal4('also after async');
  });
};
```

## Performance Benefits

### Before Batching

```typescript
const items = signal<Item[]>([]);
const filter = signal('');
const sortBy = signal<'name' | 'date'>('name');

// Each update triggers the expensive computed
const filteredItems = computed(() => {
  return items()
    .filter(item => item.name.includes(filter()))
    .sort((a, b) => a[sortBy()] > b[sortBy()] ? 1 : -1);
});

// Updates one by one - computed runs 3 times
items(newItems);    // Computed runs
filter('search');   // Computed runs again  
sortBy('date');     // Computed runs again
```

### After Batching

```typescript
// All updates batched - computed runs only once
const updateView = (newItems: Item[], newFilter: string, newSort: 'name' | 'date') => {
  batch(() => {
    items(newItems);
    filter(newFilter);
    sortBy(newSort);
  });
  // filteredItems computed runs only once with final values
};
```

## Common Use Cases

### Component State Updates

```jsx
const UserEditor = () => {
  const user = {
    name: signal(''),
    email: signal(''),
    preferences: signal({})
  };
  
  const saveUser = async () => {
    const userData = await api.updateUser(getCurrentUserData());
    
    // Update all user fields at once
    batch(() => {
      user.name(userData.name);
      user.email(userData.email);
      user.preferences(userData.preferences);
    });
  };
  
  return <UserForm user={user} onSave={saveUser} />;
};
```

### Animation Frames

```typescript
const position = { x: signal(0), y: signal(0) };
const velocity = { x: signal(0), y: signal(0) };

const updateAnimation = () => {
  batch(() => {
    position.x(position.x() + velocity.x());
    position.y(position.y() + velocity.y());
    
    // Apply physics
    velocity.x(velocity.x() * 0.98);
    velocity.y(velocity.y() * 0.98);
  });
  
  requestAnimationFrame(updateAnimation);
};
```

### Error Handling

```typescript
const updateWithErrorHandling = (updates: Array<() => void>) => {
  try {
    batch(() => {
      updates.forEach(update => update());
    });
  } catch (error) {
    console.error('Batch update failed:', error);
    // Handle error - effects won't run if batch throws
  }
};
```

## Best Practices

### ✅ Do This

```typescript
// Group related updates
batch(() => {
  userSignal(newUser);
  statusSignal('updated');
  timestampSignal(Date.now());
});

// Use for expensive operation optimization
batch(() => {
  signals.forEach(signal => signal(newValue));
});
```

### ❌ Avoid This

```typescript
// Don't batch single updates
batch(() => {
  oneSignal(newValue); // Unnecessary batching
});

// Don't rely on batching for async operations
batch(() => {
  signal1(value);
  setTimeout(() => signal2(value), 0); // Not batched
});
```

## Related APIs

- [`signal()`](/api/core/signal) - Create reactive state that can be batched
- [`computed()`](/api/core/computed) - Create derived values that benefit from batching
- [`effect()`](/api/core/effect) - Create side effects that are deferred during batching
- [`untracked()`](/api/core/untracked) - Read signals without creating dependencies

## See Also

- [Understanding Reactivity](/concepts/reactivity) - Learn how the reactive system processes updates
- [Performance Optimization](/concepts/performance) - Best practices for efficient reactive updates