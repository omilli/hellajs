---
title: effect
description: A reactive side effect that automatically runs when dependencies change.
---

A reactive side effect that automatically runs when dependencies change.


```typescript
import { signal, effect } from '@hellajs/core';

const count = signal(0);

// Creates an effect that runs when count changes
const cleanup = effect(() => {
  console.log(`The count is: ${count()}`);
});
// Logs: "The count is: 0" (initial run)

count(1);
// Logs: "The count is: 1"

// Stop the effect from running
cleanup();

// No longer logs anything
count(2);
```

## Effect Lifecycle

Effects run immediately when created and automatically re-run when their dependencies change.

```typescript
import { signal, effect } from '@hellajs/core';

const data = signal<string | null>(null);

const cleanup = effect(() => {
  const currentData = data();
  
  if (currentData) {
    console.log('Data available:', currentData);
    
    // Effects run side effects but don't return cleanup functions
    // The cleanup function returned by effect() stops the effect itself
    console.log('Processing data...');
  }
});

data('Hello'); // Logs: "Data available: Hello" and "Processing data..."
data('World'); // Logs: "Data available: World" and "Processing data..."

// Stop the effect from running
cleanup();
```

## Conditional Effects

Use early returns to conditionally track dependencies in effects.

```typescript
const isEnabled = signal(false);
const data = signal('initial');

effect(() => {
  if (!isEnabled()) return; // Early return prevents tracking
  
  // This code only runs when isEnabled is true
  console.log('Processing:', data());
});

isEnabled(true); // Now starts tracking data changes
data('updated'); // Logs: "Processing: updated"
```

## Cleanup Patterns

Properly clean up resources in effects to prevent memory leaks.

```typescript
const data = signal('');

const cleanup = effect(() => {
  const value = data();
  
  // Set up subscription or event listener
  const subscription = subscribe(value, (newData) => {
    console.log('Received:', newData);
  });
  
  // Return cleanup function to run when effect is disposed
  return () => subscription.unsubscribe();
});

// Clean up the effect
cleanup();
```

## Async Effects

Handle asynchronous operations properly in effects.

```typescript
const userId = signal('1');

effect(() => {
  const id = userId();
  
  // Use a flag to prevent race conditions
  let cancelled = false;
  
  fetchUser(id).then(user => {
    if (!cancelled) {
      console.log('User loaded:', user);
    }
  });
  
  // Cleanup function sets the flag
  return () => cancelled = true;
});
```

