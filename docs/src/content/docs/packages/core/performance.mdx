---
title: Performance Patterns
description: Advanced performance optimization patterns using HellaJS core reactivity.
---

Best practices for optimizing reactive applications with HellaJS core primitives.

## Memory Management

HellaJS automatically cleans up unused reactive dependencies, but you can optimize further:

```typescript
import { signal, computed, effect, untracked } from '@hellajs/core';

// Signals automatically cleanup when no longer referenced
function createTemporaryComputation() {
  const temp = signal(0);
  const doubled = computed(() => temp() * 2);
  
  // When this function ends and temp/doubled go out of scope,
  // they're automatically cleaned up
  return doubled();
}

// For long-lived effects, store cleanup functions
const cleanupFunctions: Array<() => void> = [];

function setupLongLivedEffect() {
  const cleanup = effect(() => {
    // Some side effect
  });
  
  cleanupFunctions.push(cleanup);
}

// Clean up when component unmounts
function onUnmount() {
  cleanupFunctions.forEach(cleanup => cleanup());
}
```

## Minimizing Recomputations

Use `untracked` to read signals without creating dependencies:

```typescript
import { signal, computed, untracked } from '@hellajs/core';

const data = signal([1, 2, 3, 4, 5]);
const threshold = signal(3);
const debug = signal(false);

const filteredData = computed(() => {
  const items = data().filter(item => item > threshold());
  
  // Don't recompute when debug flag changes
  if (untracked(() => debug())) {
    console.log('Filtered:', items);
  }
  
  return items;
});
```

## Batch Critical Updates

Always batch related signal updates to prevent cascading effects:

```typescript
import { signal, batch, effect } from '@hellajs/core';

const user = signal({ name: '', email: '', verified: false });
const loading = signal(false);
const error = signal<string | null>(null);

// Expensive effect that should only run once per update
effect(() => {
  const currentUser = user();
  const isLoading = loading();
  
  // Expensive DOM updates or API calls
  updateUI(currentUser, isLoading);
});

// Bad: Triggers effect multiple times
function updateUserBad(newUser: User) {
  loading(true);
  error(null);
  user(newUser);
  loading(false);
  // Effect runs 4 times!
}

// Good: Triggers effect only once
function updateUserGood(newUser: User) {
  batch(() => {
    loading(true);
    error(null);
    user(newUser);
    loading(false);
  });
  // Effect runs 1 time
}
```

## Conditional Computation

Avoid unnecessary computations with conditional logic:

```typescript
import { signal, computed } from '@hellajs/core';

const mode = signal<'simple' | 'complex'>('simple');
const data = signal(generateLargeDataset());

// Conditional computation based on mode
const processedData = computed(() => {
  const currentMode = mode();
  const dataset = data();
  
  if (currentMode === 'simple') {
    // Fast path for simple processing
    return dataset.slice(0, 10);
  }
  
  // Expensive computation only when needed
  return dataset
    .map(item => expensiveTransform(item))
    .filter(item => complexFilter(item))
    .sort(complexComparator);
});
```

## Debouncing with Signals

Create debounced effects for expensive operations:

```typescript
import { signal, effect } from '@hellajs/core';

const searchQuery = signal('');

// Debounced search effect
function createDebouncedSearch(delay = 300) {
  let timeoutId: number;
  
  return effect(() => {
    const query = searchQuery();
    
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      if (query.trim()) {
        performSearch(query);
      }
    }, delay);
  });
}

const cleanup = createDebouncedSearch();
```