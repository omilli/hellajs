---
title: untracked
description: Read signals without creating reactive dependencies.
---

Executes a function and reads signals within it without creating a reactive dependency. This is a powerful tool for optimizing performance and controlling reactive behavior.

## API

```typescript
function untracked<T>(fn: () => T): T
```
- `fn`: A function to execute without tracking signal dependencies.
- **Returns**: The value returned by the function `fn`.

## TypeScript

The `untracked` function is generic and preserves the return type of the function it wraps.

```typescript
type UntrackedFunction<T> = () => T;

const value: number = untracked(() => {
  // read some signals...
  return 42;
});
```

## Basic Usage

Use `untracked` to access a signal's value inside a reactive scope (like `computed` or `effect`) without making that scope depend on the signal.

```typescript
import { signal, computed, untracked } from '@hellajs/core';

const value = signal(5);
const multiplier = signal(10);

const result = computed(() => {
  // `result` will update when `value` changes...
  const currentValue = value();

  // ...but it will NOT update when `multiplier` changes.
  const currentMultiplier = untracked(() => multiplier());
  
  return currentValue * currentMultiplier;
});

console.log(result()); // 50

value(6);
console.log(result()); // 60 (recomputed because `value` is a dependency)

multiplier(20);
console.log(result()); // 60 (NOT recomputed because `multiplier` is untracked)
```

## Use Cases

### Avoiding Unnecessary Re-runs
The most common use case is to prevent an effect or computation from re-running when a signal that is not core to its logic changes. This is often used for debug logging or feature flags.

```typescript
const data = signal("some data");
const debugMode = signal(false);

effect(() => {
  // This effect should only re-run when `data` changes.
  console.log(`Data is: ${data()}`);

  // We can check debugMode without making it a dependency.
  if (untracked(() => debugMode())) {
    console.log("Debug mode is on, but this log doesn't create a dependency.");
  }
});

// Changing `debugMode` does not re-run the effect.
debugMode(true);
```

### Conditional Tracking
You can use `untracked` to create dependencies conditionally.

```typescript
const trackAnalytics = signal(false);
const analyticsData = signal(0);

effect(() => {
  // This effect always depends on `trackAnalytics`.
  if (trackAnalytics()) {
    // But it only depends on `analyticsData` when tracking is enabled.
    console.log(`Analytics data: ${analyticsData()}`);
  } else {
    console.log("Analytics tracking is disabled.");
  }
});
```

## Common Gotchas

### Overusing `untracked`
Most of the time, you want dependencies to be tracked automatically. Only use `untracked` when you have a specific reason to prevent a dependency. Overusing it can lead to bugs where your UI doesn't update as expected.

### Forgetting `untracked` for Debug Code
A common mistake is to add logging that references a signal, accidentally creating an unwanted dependency. Always wrap debug-only signal reads in `untracked`.

```typescript
// ❌ Bug: `debugMode` is now a dependency of this computed.
const c = computed(() => {
  if (debugMode()) {
    console.log('calculating...');
  }
  return expensiveCalculation();
});

// ✅ Correct:
const c = computed(() => {
  if (untracked(() => debugMode())) {
    console.log('calculating...');
  }
  return expensiveCalculation();
});
```
