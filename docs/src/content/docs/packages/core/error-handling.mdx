---
title: Error Handling
description: Error handling patterns and debugging techniques for reactive computations.
---

Strategies for handling errors and debugging reactive computations in HellaJS.

## Error Boundaries in Effects

Handle errors gracefully in effects to prevent application crashes:

```typescript
import { signal, effect, computed } from '@hellajs/core';

const data = signal<any[]>([]);
const error = signal<string | null>(null);
const loading = signal(false);

// Effect with error handling
effect(() => {
  try {
    const items = data();
    // Process data that might throw
    const processed = items.map(item => {
      if (!item.id) throw new Error('Invalid item: missing id');
      return processItem(item);
    });
    
    // Clear any previous errors
    error(null);
  } catch (err) {
    error(err instanceof Error ? err.message : 'Unknown error');
    console.error('Data processing error:', err);
  }
});
```

## Safe Computed Values

Create computed values that handle exceptions gracefully:

```typescript
import { signal, computed } from '@hellajs/core';

const jsonString = signal('{"name": "John"}');

const parsedData = computed(() => {
  try {
    return JSON.parse(jsonString());
  } catch (err) {
    console.warn('Invalid JSON:', jsonString(), err);
    return null; // Return fallback value
  }
});

// Usage with null checks
const userName = computed(() => {
  const data = parsedData();
  return data?.name ?? 'Unknown';
});
```

## Async Error Handling

Handle errors in async operations within effects:

```typescript
import { signal, effect, batch } from '@hellajs/core';

const userId = signal<string | null>(null);
const user = signal<User | null>(null);
const loading = signal(false);
const error = signal<string | null>(null);

effect(() => {
  const id = userId();
  
  if (!id) {
    batch(() => {
      user(null);
      error(null);
      loading(false);
    });
    return;
  }
  
  batch(() => {
    loading(true);
    error(null);
  });
  
  fetchUser(id)
    .then(userData => {
      batch(() => {
        user(userData);
        loading(false);
      });
    })
    .catch(err => {
      batch(() => {
        error(err.message);
        loading(false);
        user(null);
      });
    });
});
```

## Debugging Reactive Dependencies

Debug complex reactive dependency chains:

```typescript
import { signal, computed, effect } from '@hellajs/core';

// Add debug names to signals for easier debugging
const count = signal(0);
(count as any).displayName = 'count';

const doubled = computed(() => {
  const value = count() * 2;
  console.log('Computed doubled:', value);
  return value;
});
(doubled as any).displayName = 'doubled';

const tripled = computed(() => {
  const value = doubled() + count();
  console.log('Computed tripled:', value, 'depends on doubled:', doubled(), 'count:', count());
  return value;
});

// Debug effect that logs all dependencies
effect(() => {
  console.log('Effect triggered - tripled:', tripled(), 'count:', count());
});
```

## Validation Patterns

Create validation signals that handle invalid states:

```typescript
import { signal, computed } from '@hellajs/core';

const email = signal('');
const password = signal('');

const emailError = computed(() => {
  const value = email();
  if (!value) return null;
  
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(value)) {
    return 'Invalid email format';
  }
  
  return null;
});

const passwordError = computed(() => {
  const value = password();
  if (!value) return null;
  
  if (value.length < 8) {
    return 'Password must be at least 8 characters';
  }
  
  return null;
});

const formValid = computed(() => {
  return email() && password() && !emailError() && !passwordError();
});

const formErrors = computed(() => {
  const errors = [];
  
  const emailErr = emailError();
  if (emailErr) errors.push(emailErr);
  
  const passwordErr = passwordError();
  if (passwordErr) errors.push(passwordErr);
  
  return errors;
});
```

## Recovery Strategies

Implement recovery mechanisms for failed computations:

```typescript
import { signal, computed, effect } from '@hellajs/core';

const networkStatus = signal<'online' | 'offline'>('online');
const retryCount = signal(0);
const maxRetries = 3;

const dataResource = computed(() => {
  const isOnline = networkStatus();
  const attempts = retryCount();
  
  if (!isOnline && attempts < maxRetries) {
    // Trigger retry when back online
    setTimeout(() => retryCount(attempts + 1), 1000);
    throw new Error('Network offline - retrying...');
  }
  
  if (attempts >= maxRetries) {
    throw new Error('Max retries exceeded');
  }
  
  // Reset retry count on success
  retryCount(0);
  return fetchDataSync();
});

// Effect with recovery
effect(() => {
  try {
    const data = dataResource();
    console.log('Data loaded:', data);
  } catch (err) {
    console.error('Data loading failed:', err.message);
    
    // Handle specific error types
    if (err.message.includes('Network offline')) {
      showRetryMessage();
    } else if (err.message.includes('Max retries')) {
      showOfflineMode();
    }
  }
});
```