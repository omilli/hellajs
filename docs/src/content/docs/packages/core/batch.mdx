---
title: batch
description: Groups multiple signal updates to trigger effects only once.
---

Groups multiple signal updates into a single transaction, ensuring that reactive effects run only once after all updates are complete. This is essential for performance when modifying multiple related signals simultaneously.

## API

```typescript
function batch<T>(fn: () => T): T
```

- `fn`: A function that contains the signal updates to be batched.
- **Returns**: The value returned by the function `fn`.

## TypeScript

The `batch` function is generic and preserves the return type of the function it wraps.

```typescript
type BatchFunction<T> = () => T;

const result: string = batch(() => {
  // ... signal updates
  return "done";
});
```

## Basic Usage

Without `batch`, each signal update triggers its own effect run. With `batch`, all updates are grouped, and effects run only once.

```typescript
import { signal, batch, effect } from '@hellajs/core';

const firstName = signal("John");
const lastName = signal("Doe");
let updateCount = 0;

effect(() => {
  console.log(`${firstName()} ${lastName()}`);
  updateCount++;
});
// Initial run: logs "John Doe", updateCount is 1

// Without batching: 2 separate effect runs
firstName("Jane");   // Logs "Jane Doe"
lastName("Smith"); // Logs "Jane Smith"
console.log(updateCount); // 3

// With batching: 1 effect run for both updates
batch(() => {
  firstName("Alice");
  lastName("Johnson");
}); // Logs "Alice Johnson"
console.log(updateCount); // 4 (only 1 additional update)
```

## Use Cases

### Form Updates
Batching is ideal for applying multiple changes to a form's state, preventing repeated validation or re-rendering.

```typescript
const formData = {
  email: signal(''),
  name: signal(''),
};

effect(() => {
  // This validation logic runs only once per batch
  console.log('Validating:', formData.name(), formData.email());
});

const loadUserData = (userData) => {
  batch(() => {
    formData.email(userData.email);
    formData.name(userData.name);
  });
};

loadUserData({ email: "user@example.com", name: "John Doe" });
```

### State Initialization
Use `batch` to initialize or update complex state objects without causing a cascade of intermediate updates.

```typescript
const appState = {
  user: signal(null),
  isLoading: signal(false),
  error: signal(null),
};

const login = async (credentials) => {
  batch(() => {
    appState.isLoading(true);
    appState.error(null);
  });

  try {
    const userData = await api.login(credentials);
    batch(() => {
      appState.user(userData);
      appState.isLoading(false);
    });
  } catch (error) {
    batch(() => {
      appState.error(error.message);
      appState.isLoading(false);
    });
  }
};
```

## Nested Batching

Batches can be nested. Effects will not run until the outermost batch has completed.

```typescript
const counters = { a: signal(0), b: signal(0) };
let effectRuns = 0;

effect(() => {
  counters.a(); counters.b();
  effectRuns++;
}); // effectRuns is 1

batch(() => {
  counters.a(1);
  batch(() => {
    counters.b(2);
  });
  counters.a(10);
});

console.log(effectRuns); // 2 (only one additional run)
```

## Important Considerations

### Async Operations
Batching only applies to synchronous signal updates within the batch function. Asynchronous operations will not be batched with the initial updates.

```typescript
// ❌ Incorrect: Async operations break batching
batch(async () => {
  signal1('value1');
  await someAsyncOperation();
  signal2('value2'); // This update is NOT batched with the first
});

// ✅ Correct: Batch synchronous parts separately
batch(() => {
  signal1('value1');
  loadingState(true);
});

try {
  const result = await someAsyncOperation();
  batch(() => {
    signal2(result);
    loadingState(false);
  });
} catch (error) {
  // ...
}
```
