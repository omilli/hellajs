---
title: Event Handling
description: Event delegation, custom events, and reactive event patterns in HellaJS DOM.
---

HellaJS DOM provides efficient event handling through delegation and reactive patterns.

## Event Delegation

HellaJS uses global event delegation for better performance and memory usage:

```jsx
import { signal } from '@hellajs/core';
import { mount } from '@hellajs/dom';

const App = () => {
  const count = signal(0);
  const name = signal('');
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', done: false },
    { id: 2, text: 'Build an app', done: false }
  ]);

  // Event handlers are automatically delegated
  return (
    <div>
      <button onclick={() => count(count() + 1)}>
        Count: {count}
      </button>
      
      <input 
        value={name}
        oninput={(e) => name(e.target.value)}
        placeholder="Enter your name"
      />
      
      <ul>
        {todos().map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.done}
              onchange={(e) => {
                const checked = e.target.checked;
                todos(todos().map(t => 
                  t.id === todo.id ? { ...t, done: checked } : t
                ));
              }}
            />
            <span style={{ textDecoration: todo.done ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
          </li>
        ))}
      </ul>
    </div>
  );
};
```

## Custom Event Handlers

Create reusable event handler patterns:

```jsx
import { signal, batch } from '@hellajs/core';

const Form = () => {
  const data = signal({ name: '', email: '', age: 0 });
  const errors = signal({});

  // Generic field update handler
  const handleFieldChange = (field) => (e) => {
    const value = e.target.type === 'number' ? +e.target.value : e.target.value;
    data({ ...data(), [field]: value });
  };

  // Form submission with validation
  const handleSubmit = (e) => {
    e.preventDefault();
    
    const newErrors = {};
    const currentData = data();
    
    if (!currentData.name) newErrors.name = 'Name is required';
    if (!currentData.email) newErrors.email = 'Email is required';
    if (currentData.age < 18) newErrors.age = 'Must be at least 18';
    
    batch(() => {
      errors(newErrors);
      if (Object.keys(newErrors).length === 0) {
        console.log('Form submitted:', currentData);
        data({ name: '', email: '', age: 0 });
      }
    });
  };

  return (
    <form onsubmit={handleSubmit}>
      <div>
        <input
          type="text"
          value={data().name}
          oninput={handleFieldChange('name')}
          placeholder="Name"
        />
        {errors().name && <span class="error">{errors().name}</span>}
      </div>
      
      <div>
        <input
          type="email"
          value={data().email}
          oninput={handleFieldChange('email')}
          placeholder="Email"
        />
        {errors().email && <span class="error">{errors().email}</span>}
      </div>
      
      <div>
        <input
          type="number"
          value={data().age}
          oninput={handleFieldChange('age')}
          placeholder="Age"
        />
        {errors().age && <span class="error">{errors().age}</span>}
      </div>
      
      <button type="submit">Submit</button>
    </form>
  );
};
```

## Keyboard Navigation

Handle keyboard events for accessibility and navigation:

```jsx
import { signal } from '@hellajs/core';

const SearchableList = () => {
  const items = signal(['Apple', 'Banana', 'Cherry', 'Date', 'Elderberry']);
  const query = signal('');
  const selectedIndex = signal(-1);
  
  const filteredItems = signal(() => {
    const q = query().toLowerCase();
    return items().filter(item => item.toLowerCase().includes(q));
  });

  const handleKeydown = (e) => {
    const filtered = filteredItems();
    const currentIndex = selectedIndex();

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        selectedIndex(Math.min(currentIndex + 1, filtered.length - 1));
        break;
        
      case 'ArrowUp':
        e.preventDefault();
        selectedIndex(Math.max(currentIndex - 1, -1));
        break;
        
      case 'Enter':
        e.preventDefault();
        if (currentIndex >= 0 && currentIndex < filtered.length) {
          console.log('Selected:', filtered[currentIndex]);
          query('');
          selectedIndex(-1);
        }
        break;
        
      case 'Escape':
        query('');
        selectedIndex(-1);
        break;
    }
  };

  return (
    <div>
      <input
        type="text"
        value={query}
        oninput={(e) => {
          query(e.target.value);
          selectedIndex(-1);
        }}
        onkeydown={handleKeydown}
        placeholder="Search items..."
        autofocus
      />
      
      <ul>
        {filteredItems().map((item, index) => (
          <li
            key={item}
            class={index === selectedIndex() ? 'selected' : ''}
            onclick={() => {
              console.log('Selected:', item);
              query('');
              selectedIndex(-1);
            }}
          >
            {item}
          </li>
        ))}
      </ul>
    </div>
  );
};
```

## Dynamic Event Binding

Conditionally bind events based on reactive state:

```jsx
import { signal, computed } from '@hellajs/core';

const InteractiveCard = () => {
  const mode = signal('view'); // 'view', 'edit', 'disabled'
  const content = signal('Click to edit this content');
  
  const isEditing = computed(() => mode() === 'edit');
  const isDisabled = computed(() => mode() === 'disabled');

  const handleClick = () => {
    if (mode() === 'view') {
      mode('edit');
    }
  };

  const handleKeydown = (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      mode('view');
    } else if (e.key === 'Escape') {
      mode('view');
    }
  };

  const handleBlur = () => {
    mode('view');
  };

  return (
    <div class={`card ${mode()}`}>
      {isEditing() ? (
        <textarea
          value={content}
          oninput={(e) => content(e.target.value)}
          onkeydown={handleKeydown}
          onblur={handleBlur}
          autofocus
        />
      ) : (
        <div
          onclick={isDisabled() ? undefined : handleClick}
          class={`content ${isDisabled() ? 'disabled' : 'clickable'}`}
        >
          {content}
        </div>
      )}
      
      <div class="controls">
        <button
          onclick={() => mode('disabled')}
          disabled={isDisabled()}
        >
          {isDisabled() ? 'Disabled' : 'Disable'}
        </button>
        
        <button onclick={() => mode('view')}>
          Reset
        </button>
      </div>
    </div>
  );
};
```

## Event Cleanup

HellaJS automatically handles event cleanup, but you can manage custom events:

```jsx
import { signal, effect } from '@hellajs/core';

const WindowEventComponent = () => {
  const windowSize = signal({ width: window.innerWidth, height: window.innerHeight });
  const isOnline = signal(navigator.onLine);

  // Effects for global events are automatically cleaned up
  effect(() => {
    const handleResize = () => {
      windowSize({ width: window.innerWidth, height: window.innerHeight });
    };

    const handleOnline = () => isOnline(true);
    const handleOffline = () => isOnline(false);

    window.addEventListener('resize', handleResize);
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    // Return cleanup function
    return () => {
      window.removeEventListener('resize', handleResize);
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  });

  return (
    <div>
      <p>Window size: {windowSize().width} x {windowSize().height}</p>
      <p>Status: {isOnline() ? 'Online' : 'Offline'}</p>
    </div>
  );
};
```