---
title: router
description: Minimal client-side router with hooks, params, and redirects.
---

Minimal client-side router with hooks, params, redirects, and 404.

```typescript
import { effect } from "@hellajs/core";
import { router, route } from "@hellajs/router";

// Define routes and handlers
router({
  "/": () => { /* home handler */ },
  "/about": {
    handler: () => { /* about handler */ },
    before: () => { /* before hook */ },
    after: () => { /* after hook */ }
  },
  "/user/:id": (params) => {
    console.log(params.id); // dynamic param
  },
  "/old": "/new", // redirect
}, {
  before: () => { /* global before */ },
  after: () => { /* global after */ },
  404: () => { /* not found */ },
  redirects: [
    { from: ["/legacy"], to: "/" }
  ],
  hash: true, // enable hash routing
});

// Access current route reactively
effect(() => {
  const r = route();
  console.log(r.path, r.params, r.query);
});
```

## API

```typescript
function router(
  routes: Record<string, RouteValue | string>,
  options?: RouterOptions
): void

function navigate(
  path: string,
  params?: Record<string, string>,
  query?: Record<string, string>,
  options?: { replace?: boolean }
): void

function route(): RouteInfo
```

## Route Guards

Control access to routes and perform authentication checks before navigation.

Route guards allow you to control access to routes and perform authentication checks.

```typescript
import { router, navigate } from '@hellajs/router';
import { signal } from '@hellajs/core';

const isAuthenticated = signal(false);
const userRole = signal<string | null>(null);

// Authentication guard
const authGuard = () => {
  if (!isAuthenticated()) {
    navigate('/login');
    return false; // Prevent navigation
  }
  return true; // Allow navigation
};

// Role-based guard
const adminGuard = () => {
  if (userRole() !== 'admin') {
    navigate('/unauthorized');
    return false;
  }
  return true;
};

router({
  "/": () => { /* public home */ },
  "/login": () => { /* login page */ },
  "/dashboard": {
    handler: () => { /* protected dashboard */ },
    before: authGuard // Requires authentication
  },
  "/admin": {
    handler: () => { /* admin panel */ },
    before: [authGuard, adminGuard] // Multiple guards
  }
});
```

### Nested Routing

Build complex routing hierarchies with nested components and layout structures.

Create hierarchical route structures with nested components and layouts.

```typescript
import { router, route } from '@hellajs/router';
import { signal, effect } from '@hellajs/core';

// Layout component that renders child routes
const AdminLayout = () => {
  const currentRoute = route();
  
  return (
    <div class="admin-layout">
      <nav>
        <a href="/admin/users">Users</a>
        <a href="/admin/settings">Settings</a>
        <a href="/admin/reports">Reports</a>
      </nav>
      <main id="admin-content">
        {/* Child routes render here */}
      </main>
    </div>
  );
};

// Nested route configuration
router({
  "/admin": {
    handler: () => mount(AdminLayout, '#app'),
    children: {
      "/users": {
        handler: () => mount(UserManagement, '#admin-content'),
        children: {
          "/:id": (params) => {
            // Nested param: /admin/users/123
            mount(() => <UserDetail userId={params.id} />, '#admin-content');
          }
        }
      },
      "/settings": () => mount(AdminSettings, '#admin-content'),
      "/reports": () => mount(Reports, '#admin-content')
    }
  }
});
```

### Route Data & Preloading

Improve user experience by loading data before routes become active.

Preload data before route activation to improve user experience.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(
  (id: string) => fetch(`/api/user/${id}`).then(r => r.json())
);

router({
  "/user/:id": {
    // Preload data before rendering
    before: async (params) => {
      try {
        // Start loading user data
        await userResource.fetch(params.id);
        return true; // Continue with navigation
      } catch (error) {
        console.error('Failed to load user:', error);
        navigate('/error');
        return false; // Cancel navigation
      }
    },
    handler: (params) => {
      // Data is already loaded when handler runs
      const userData = userResource.data();
      mount(() => <UserProfile user={userData} />, '#app');
    }
  }
});
```

### Dynamic Route Loading

Implement code splitting by lazy loading route components on demand.

Lazy load route components for better performance.

```typescript
const loadRoute = async (componentPath: string) => {
  const module = await import(componentPath);
  return module.default;
};

router({
  "/dashboard": {
    handler: async () => {
      const Dashboard = await loadRoute('./components/Dashboard.jsx');
      mount(Dashboard, '#app');
    }
  },
  "/reports": {
    handler: async () => {
      const Reports = await loadRoute('./components/Reports.jsx');
      mount(Reports, '#app');
    }
  }
});
```

## TypeScript Types

```typescript
interface RouteHandler {
  (params?: Record<string, string>): void | Promise<void>;
}

interface RouteGuard {
  (params?: Record<string, string>): boolean | Promise<boolean>;
}

interface RouteConfig {
  handler?: RouteHandler;
  before?: RouteGuard | RouteGuard[];
  after?: RouteGuard | RouteGuard[];
  children?: Record<string, RouteConfig | RouteHandler | string>;
}

interface RouterConfig {
  before?: RouteGuard | RouteGuard[];     // Global before guards
  after?: RouteGuard | RouteGuard[];      // Global after guards
  404?: RouteHandler;                     // Not found handler
  redirects?: Array<{                     // Redirect rules
    from: string | string[];
    to: string;
  }>;
  hash?: boolean;                         // Enable hash routing
}

interface RouteInfo {
  path: string;                           // Current path
  params: Record<string, string>;         // URL parameters
  query: Record<string, string>;          // Query parameters
  hash: string;                          // URL hash
}
```

## Route Patterns

### Wildcard Routes

Match dynamic path segments using wildcard patterns.

```typescript
router({
  "/docs/*": (params) => {
    // Matches /docs/anything/here
    const wildcard = params['*']; // "anything/here"
    mount(() => <DocViewer path={wildcard} />, '#app');
  }
});
```

### Optional Parameters

Define routes with optional parameters using the question mark syntax.

```typescript
router({
  "/product/:id/:variant?": (params) => {
    // Matches both /product/123 and /product/123/red
    const { id, variant } = params;
    mount(() => <Product id={id} variant={variant} />, '#app');
  }
});
```

### Route Constraints

Use regular expressions to constrain parameter values in routes.

```typescript
router({
  "/api/v:version(\\d+)": (params) => {
    // Only matches numeric versions: /api/v1, /api/v2, etc.
    const version = parseInt(params.version);
    handleApiRequest(version);
  }
});
```
