---
title: Advanced Navigation
description: Programmatic navigation, route transitions, and navigation state management.
---

Advanced navigation patterns including programmatic navigation, route transitions, and navigation state management.

## Programmatic Navigation

Control navigation through code with various navigation methods:

```typescript
import { navigate, route } from '@hellajs/router';
import { signal, effect } from '@hellajs/core';

const NavigationController = () => {
  const currentUser = signal(null);
  const navigationHistory = signal<string[]>([]);

  // Track navigation history
  effect(() => {
    const currentRoute = route();
    if (currentRoute.path) {
      navigationHistory([...navigationHistory(), currentRoute.path]);
    }
  });

  const goToUserProfile = (userId: string) => {
    navigate('/user/:id', { id: userId });
  };

  const goToUserSettings = (userId: string, tab = 'general') => {
    navigate('/user/:id/settings', { id: userId }, { tab });
  };

  const goToDashboard = (replace = false) => {
    navigate('/dashboard', {}, {}, { replace });
  };

  const goBack = () => {
    const history = navigationHistory();
    if (history.length > 1) {
      const previousRoute = history[history.length - 2];
      navigate(previousRoute, {}, {}, { replace: true });
    }
  };

  const conditionalNavigation = (condition: boolean, truePath: string, falsePath: string) => {
    navigate(condition ? truePath : falsePath);
  };

  return {
    goToUserProfile,
    goToUserSettings,
    goToDashboard,
    goBack,
    conditionalNavigation,
    navigationHistory
  };
};

// Usage in components
const UserCard = ({ user }) => {
  const nav = NavigationController();

  const handleUserClick = () => {
    nav.goToUserProfile(user.id);
  };

  const handleSettingsClick = (e) => {
    e.stopPropagation();
    nav.goToUserSettings(user.id, 'privacy');
  };

  return (
    <div class="user-card" onclick={handleUserClick}>
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <button onclick={handleSettingsClick}>Settings</button>
    </div>
  );
};
```

## Route-Based Authentication Flow

Implement comprehensive authentication flows with route protection:

```typescript
import { router, navigate, route } from '@hellajs/router';
import { signal, effect, computed } from '@hellajs/core';

const createAuthenticationSystem = () => {
  const user = signal(null);
  const isAuthenticated = computed(() => user() !== null);
  const permissions = signal<string[]>([]);
  const redirectAfterLogin = signal<string | null>(null);

  const login = async (credentials: { email: string; password: string }) => {
    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      });

      if (!response.ok) throw new Error('Login failed');

      const userData = await response.json();
      user(userData);
      permissions(userData.permissions || []);

      // Redirect to intended destination or dashboard
      const redirectTo = redirectAfterLogin() || '/dashboard';
      redirectAfterLogin(null);
      navigate(redirectTo);

    } catch (error) {
      console.error('Login error:', error);
      throw error;
    }
  };

  const logout = async () => {
    try {
      await fetch('/api/auth/logout', { method: 'POST' });
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      user(null);
      permissions([]);
      navigate('/login');
    }
  };

  const hasPermission = (requiredPermission: string) => {
    return permissions().includes(requiredPermission);
  };

  const requireAuth = () => {
    if (!isAuthenticated()) {
      const currentRoute = route();
      redirectAfterLogin(currentRoute.path);
      navigate('/login');
      return false;
    }
    return true;
  };

  const requirePermission = (permission: string) => {
    if (!requireAuth()) return false;
    
    if (!hasPermission(permission)) {
      navigate('/unauthorized');
      return false;
    }
    return true;
  };

  return {
    user,
    isAuthenticated,
    permissions,
    login,
    logout,
    hasPermission,
    requireAuth,
    requirePermission
  };
};

const auth = createAuthenticationSystem();

// Protected route system
router({
  '/login': {
    handler: () => {
      if (auth.isAuthenticated()) {
        navigate('/dashboard');
        return;
      }
      mount(LoginComponent, '#app');
    }
  },

  '/dashboard': {
    before: auth.requireAuth,
    handler: () => mount(Dashboard, '#app')
  },

  '/admin': {
    before: () => auth.requirePermission('admin'),
    handler: () => mount(AdminPanel, '#app')
  },

  '/profile': {
    before: auth.requireAuth,
    handler: () => {
      const currentUser = auth.user();
      mount(() => <UserProfile user={currentUser} />, '#app');
    }
  },

  '/users/:id': {
    before: () => auth.requirePermission('view_users'),
    handler: (params) => {
      mount(() => <UserDetail userId={params.id} />, '#app');
    }
  }
}, {
  // Global authentication check
  before: () => {
    // Check if user session is still valid
    if (auth.user() && !isValidSession()) {
      auth.logout();
      return false;
    }
    return true;
  },

  404: () => mount(NotFoundPage, '#app')
});
```

## Navigation State Management

Track and manage complex navigation states:

```typescript
import { signal, computed, effect } from '@hellajs/core';
import { router, route, navigate } from '@hellajs/router';

const createNavigationState = () => {
  const navigationStack = signal<Array<{ path: string; timestamp: number }>>([]);
  const isNavigating = signal(false);
  const navigationError = signal<string | null>(null);
  const breadcrumbs = signal<Array<{ label: string; path: string }>>([]);

  // Track navigation history
  effect(() => {
    const currentRoute = route();
    if (currentRoute.path) {
      const entry = { path: currentRoute.path, timestamp: Date.now() };
      navigationStack([...navigationStack().slice(-9), entry]); // Keep last 10
    }
  });

  // Generate breadcrumbs based on current route
  const generateBreadcrumbs = (path: string) => {
    const segments = path.split('/').filter(Boolean);
    const crumbs = [{ label: 'Home', path: '/' }];

    let currentPath = '';
    segments.forEach((segment, index) => {
      currentPath += `/${segment}`;
      
      // Map segments to human-readable labels
      const labelMap: Record<string, string> = {
        'dashboard': 'Dashboard',
        'users': 'Users',
        'settings': 'Settings',
        'profile': 'Profile',
        'admin': 'Administration'
      };

      const label = labelMap[segment] || 
                   (segment.match(/^\d+$/) ? `#${segment}` : segment);

      crumbs.push({ label, path: currentPath });
    });

    return crumbs;
  };

  effect(() => {
    const currentRoute = route();
    breadcrumbs(generateBreadcrumbs(currentRoute.path));
  });

  const canGoBack = computed(() => navigationStack().length > 1);

  const goBack = () => {
    if (!canGoBack()) return;

    const stack = navigationStack();
    const previousEntry = stack[stack.length - 2];
    
    if (previousEntry) {
      navigate(previousEntry.path);
    }
  };

  const goToStackPosition = (index: number) => {
    const stack = navigationStack();
    if (index >= 0 && index < stack.length) {
      navigate(stack[index].path);
    }
  };

  const clearHistory = () => {
    navigationStack([]);
  };

  const saveState = (key: string, state: any) => {
    localStorage.setItem(`nav_state_${key}`, JSON.stringify(state));
  };

  const loadState = (key: string) => {
    try {
      const stored = localStorage.getItem(`nav_state_${key}`);
      return stored ? JSON.parse(stored) : null;
    } catch {
      return null;
    }
  };

  return {
    navigationStack,
    isNavigating,
    navigationError,
    breadcrumbs,
    canGoBack,
    goBack,
    goToStackPosition,
    clearHistory,
    saveState,
    loadState
  };
};

const navState = createNavigationState();

// Breadcrumb component
const Breadcrumbs = () => {
  const crumbs = navState.breadcrumbs();

  if (crumbs.length <= 1) return null;

  return (
    <nav class="breadcrumbs">
      {crumbs.map((crumb, index) => (
        <span key={crumb.path}>
          {index > 0 && <span class="separator">/</span>}
          {index === crumbs.length - 1 ? (
            <span class="current">{crumb.label}</span>
          ) : (
            <a href={crumb.path} onclick={(e) => {
              e.preventDefault();
              navigate(crumb.path);
            }}>
              {crumb.label}
            </a>
          )}
        </span>
      ))}
    </nav>
  );
};

// Navigation history component
const NavigationHistory = () => {
  const stack = navState.navigationStack();

  return (
    <div class="navigation-history">
      <h3>Navigation History</h3>
      <div class="history-stack">
        {stack.map((entry, index) => (
          <div 
            key={entry.timestamp}
            class={`history-entry ${index === stack.length - 1 ? 'current' : ''}`}
            onclick={() => navState.goToStackPosition(index)}
          >
            <span class="path">{entry.path}</span>
            <span class="time">
              {new Date(entry.timestamp).toLocaleTimeString()}
            </span>
          </div>
        ))}
      </div>
      
      <div class="history-controls">
        <button 
          onclick={() => navState.goBack()}
          disabled={!navState.canGoBack()}
        >
          Go Back
        </button>
        <button onclick={() => navState.clearHistory()}>
          Clear History
        </button>
      </div>
    </div>
  );
};
```

## Route Animations and Transitions

Create smooth transitions between routes:

```typescript
import { signal, effect, computed } from '@hellajs/core';
import { router, route } from '@hellajs/router';
import { css } from '@hellajs/css';

const createRouteTransitions = () => {
  const currentRoute = signal('');
  const previousRoute = signal('');
  const isTransitioning = signal(false);
  const transitionDirection = signal<'forward' | 'backward' | 'replace'>('forward');

  const routeOrder = ['/', '/dashboard', '/profile', '/settings'];

  const getTransitionDirection = (from: string, to: string) => {
    const fromIndex = routeOrder.indexOf(from);
    const toIndex = routeOrder.indexOf(to);
    
    if (fromIndex === -1 || toIndex === -1) return 'replace';
    return toIndex > fromIndex ? 'forward' : 'backward';
  };

  const transitionStyles = css({
    '.route-container': {
      position: 'relative',
      width: '100%',
      height: '100%',
      overflow: 'hidden'
    },

    '.route-page': {
      position: 'absolute',
      top: 0,
      left: 0,
      width: '100%',
      height: '100%',
      transition: 'transform 0.3s ease-in-out, opacity 0.3s ease-in-out'
    },

    '.route-page.entering-forward': {
      transform: 'translateX(100%)'
    },

    '.route-page.entering-backward': {
      transform: 'translateX(-100%)'
    },

    '.route-page.entering-replace': {
      opacity: 0
    },

    '.route-page.active': {
      transform: 'translateX(0)',
      opacity: 1
    },

    '.route-page.exiting-forward': {
      transform: 'translateX(-100%)'
    },

    '.route-page.exiting-backward': {
      transform: 'translateX(100%)'
    },

    '.route-page.exiting-replace': {
      opacity: 0
    }
  });

  const navigateWithTransition = (to: string) => {
    if (isTransitioning()) return;

    const from = currentRoute();
    const direction = getTransitionDirection(from, to);

    isTransitioning(true);
    previousRoute(from);
    transitionDirection(direction);

    // Start exit animation
    setTimeout(() => {
      currentRoute(to);
    }, 150);

    // Complete transition
    setTimeout(() => {
      isTransitioning(false);
      previousRoute('');
    }, 300);
  };

  return {
    currentRoute,
    previousRoute,
    isTransitioning,
    transitionDirection,
    transitionStyles,
    navigateWithTransition
  };
};

const routeTransitions = createRouteTransitions();

// Animated route container component
const AnimatedRouter = ({ routes }) => {
  const current = routeTransitions.currentRoute();
  const previous = routeTransitions.previousRoute();
  const direction = routeTransitions.transitionDirection();
  const transitioning = routeTransitions.isTransitioning();

  const getPageClass = (routeName: string) => {
    if (routeName === current && !transitioning) return 'route-page active';
    if (routeName === current && transitioning) return `route-page entering-${direction}`;
    if (routeName === previous && transitioning) return `route-page exiting-${direction}`;
    return 'route-page';
  };

  return (
    <div class={`route-container ${routeTransitions.transitionStyles}`}>
      {Object.entries(routes).map(([routeName, Component]) => (
        <div key={routeName} class={getPageClass(routeName)}>
          {(routeName === current || routeName === previous) && (
            <Component />
          )}
        </div>
      ))}
    </div>
  );
};

// Usage with router
const routeComponents = {
  '/': HomePage,
  '/dashboard': Dashboard,
  '/profile': Profile,
  '/settings': Settings
};

router({
  '/': () => routeTransitions.navigateWithTransition('/'),
  '/dashboard': () => routeTransitions.navigateWithTransition('/dashboard'),
  '/profile': () => routeTransitions.navigateWithTransition('/profile'),
  '/settings': () => routeTransitions.navigateWithTransition('/settings')
});

// Mount the animated router
mount(() => <AnimatedRouter routes={routeComponents} />, '#app');
```