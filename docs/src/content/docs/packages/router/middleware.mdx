---
title: Route Middleware
description: Advanced route middleware patterns for authentication, logging, and request processing.
---

Implement sophisticated middleware systems for route processing, including authentication, logging, analytics, and request transformation.

## Middleware Chain System

Create a composable middleware system for routes:

```typescript
import { router, navigate, route } from '@hellajs/router';
import { signal, effect } from '@hellajs/core';

type MiddlewareContext = {
  route: { path: string; params: Record<string, string>; query: Record<string, string> };
  user?: any;
  metadata: Record<string, any>;
  abort: () => void;
  redirect: (path: string) => void;
};

type Middleware = (context: MiddlewareContext, next: () => Promise<boolean>) => Promise<boolean>;

const createMiddlewareSystem = () => {
  const globalMiddleware: Middleware[] = [];
  
  const use = (middleware: Middleware) => {
    globalMiddleware.push(middleware);
  };

  const runMiddleware = async (
    middlewares: Middleware[], 
    context: MiddlewareContext
  ): Promise<boolean> => {
    let index = 0;

    const next = async (): Promise<boolean> => {
      if (index >= middlewares.length) return true;
      
      const middleware = middlewares[index++];
      return middleware(context, next);
    };

    return next();
  };

  const executeRoute = async (
    handler: () => void,
    routeMiddleware: Middleware[] = []
  ) => {
    const currentRoute = route();
    let aborted = false;
    let redirectPath: string | null = null;

    const context: MiddlewareContext = {
      route: currentRoute,
      metadata: {},
      abort: () => { aborted = true; },
      redirect: (path: string) => { redirectPath = path; }
    };

    const allMiddleware = [...globalMiddleware, ...routeMiddleware];
    
    try {
      const success = await runMiddleware(allMiddleware, context);
      
      if (aborted) {
        console.log('Route execution aborted by middleware');
        return;
      }
      
      if (redirectPath) {
        navigate(redirectPath);
        return;
      }
      
      if (success) {
        handler();
      }
    } catch (error) {
      console.error('Middleware error:', error);
      navigate('/error');
    }
  };

  return { use, executeRoute };
};

const middlewareSystem = createMiddlewareSystem();

// Authentication middleware
const authMiddleware: Middleware = async (context, next) => {
  console.log('🔐 Checking authentication...');
  
  const token = localStorage.getItem('auth_token');
  if (!token) {
    console.log('❌ No auth token found');
    context.redirect('/login');
    return false;
  }

  try {
    const response = await fetch('/api/auth/verify', {
      headers: { Authorization: `Bearer ${token}` }
    });
    
    if (!response.ok) throw new Error('Invalid token');
    
    const user = await response.json();
    context.user = user;
    context.metadata.authenticated = true;
    
    console.log('✅ Authentication successful');
    return next();
  } catch (error) {
    console.log('❌ Authentication failed');
    localStorage.removeItem('auth_token');
    context.redirect('/login');
    return false;
  }
};

// Logging middleware
const loggingMiddleware: Middleware = async (context, next) => {
  const startTime = Date.now();
  console.log(`📝 Route access: ${context.route.path}`);
  
  const success = await next();
  
  const duration = Date.now() - startTime;
  console.log(`⏱️ Route processed in ${duration}ms`);
  
  // Send analytics
  if (success) {
    fetch('/api/analytics/route', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        path: context.route.path,
        duration,
        timestamp: new Date().toISOString(),
        user: context.user?.id
      })
    }).catch(console.error);
  }
  
  return success;
};

// Permission middleware factory
const createPermissionMiddleware = (requiredPermission: string): Middleware => {
  return async (context, next) => {
    console.log(`🔑 Checking permission: ${requiredPermission}`);
    
    if (!context.user) {
      console.log('❌ No user context for permission check');
      context.redirect('/login');
      return false;
    }

    const userPermissions = context.user.permissions || [];
    if (!userPermissions.includes(requiredPermission)) {
      console.log(`❌ Missing permission: ${requiredPermission}`);
      context.redirect('/unauthorized');
      return false;
    }

    console.log(`✅ Permission granted: ${requiredPermission}`);
    return next();
  };
};

// Rate limiting middleware
const createRateLimitMiddleware = (maxRequests = 100, windowMs = 60000): Middleware => {
  const requests = new Map<string, { count: number; resetTime: number }>();

  return async (context, next) => {
    const userId = context.user?.id || 'anonymous';
    const now = Date.now();
    
    const userRequests = requests.get(userId) || { count: 0, resetTime: now + windowMs };
    
    if (now > userRequests.resetTime) {
      userRequests.count = 0;
      userRequests.resetTime = now + windowMs;
    }
    
    if (userRequests.count >= maxRequests) {
      console.log(`🚫 Rate limit exceeded for ${userId}`);
      context.redirect('/rate-limited');
      return false;
    }
    
    userRequests.count++;
    requests.set(userId, userRequests);
    
    return next();
  };
};

// Register global middleware
middlewareSystem.use(loggingMiddleware);
middlewareSystem.use(createRateLimitMiddleware(50, 60000));

// Route definitions with middleware
router({
  '/': {
    handler: () => mount(HomePage, '#app')
  },

  '/login': {
    handler: () => mount(LoginPage, '#app')
  },

  '/dashboard': {
    handler: () => middlewareSystem.executeRoute(
      () => mount(Dashboard, '#app'),
      [authMiddleware]
    )
  },

  '/admin': {
    handler: () => middlewareSystem.executeRoute(
      () => mount(AdminPanel, '#app'),
      [
        authMiddleware,
        createPermissionMiddleware('admin')
      ]
    )
  },

  '/users/:id': {
    handler: (params) => middlewareSystem.executeRoute(
      () => mount(() => <UserProfile userId={params.id} />, '#app'),
      [
        authMiddleware,
        createPermissionMiddleware('view_users')
      ]
    )
  }
});
```

## Advanced Middleware Patterns

Implement sophisticated middleware for complex scenarios:

```typescript
import { signal, computed, batch } from '@hellajs/core';

// Feature flag middleware
const createFeatureFlagMiddleware = (flagName: string): Middleware => {
  return async (context, next) => {
    try {
      const response = await fetch(`/api/features/${flagName}`, {
        headers: context.user ? { Authorization: `Bearer ${localStorage.getItem('auth_token')}` } : {}
      });
      
      const { enabled } = await response.json();
      
      if (!enabled) {
        console.log(`🚩 Feature flag '${flagName}' is disabled`);
        context.redirect('/feature-not-available');
        return false;
      }

      context.metadata.featureFlags = {
        ...context.metadata.featureFlags,
        [flagName]: true
      };
      
      return next();
    } catch (error) {
      console.error('Feature flag check failed:', error);
      return next(); // Continue on error (graceful degradation)
    }
  };
};

// A/B testing middleware
const createABTestMiddleware = (testName: string): Middleware => {
  return async (context, next) => {
    const userId = context.user?.id || 'anonymous';
    
    try {
      const response = await fetch('/api/ab-test/assignment', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ userId, testName })
      });
      
      const { variant } = await response.json();
      
      context.metadata.abTests = {
        ...context.metadata.abTests,
        [testName]: variant
      };
      
      console.log(`🧪 A/B test '${testName}': variant '${variant}'`);
      return next();
    } catch (error) {
      console.error('A/B test assignment failed:', error);
      return next();
    }
  };
};

// Cache middleware for expensive routes
const createCacheMiddleware = (ttl = 300000): Middleware => {
  const cache = new Map<string, { data: any; expiry: number }>();

  return async (context, next) => {
    const cacheKey = `${context.route.path}:${JSON.stringify(context.route.params)}`;
    const cached = cache.get(cacheKey);
    
    if (cached && Date.now() < cached.expiry) {
      console.log(`💾 Cache hit for ${cacheKey}`);
      context.metadata.cached = cached.data;
      return next();
    }

    const success = await next();
    
    if (success && context.metadata.cacheableData) {
      cache.set(cacheKey, {
        data: context.metadata.cacheableData,
        expiry: Date.now() + ttl
      });
      console.log(`💾 Cached data for ${cacheKey}`);
    }
    
    return success;
  };
};

// Data preloading middleware
const createDataPreloadMiddleware = <T>(
  loader: (params: Record<string, string>) => Promise<T>,
  metadataKey = 'preloadedData'
): Middleware => {
  return async (context, next) => {
    try {
      console.log(`📊 Preloading data for ${context.route.path}`);
      const startTime = Date.now();
      
      const data = await loader(context.route.params);
      
      const loadTime = Date.now() - startTime;
      console.log(`📊 Data preloaded in ${loadTime}ms`);
      
      context.metadata[metadataKey] = data;
      context.metadata.cacheableData = data; // For cache middleware
      
      return next();
    } catch (error) {
      console.error('Data preloading failed:', error);
      context.metadata.preloadError = error;
      return next(); // Continue even if preload fails
    }
  };
};

// Error boundary middleware
const errorBoundaryMiddleware: Middleware = async (context, next) => {
  try {
    return await next();
  } catch (error) {
    console.error('Route middleware error:', error);
    
    // Log error to monitoring service
    fetch('/api/errors', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        error: error.message,
        stack: error.stack,
        route: context.route.path,
        user: context.user?.id,
        timestamp: new Date().toISOString()
      })
    }).catch(console.error);

    context.redirect('/error');
    return false;
  }
};

// Usage with complex route
const complexRouteHandler = () => middlewareSystem.executeRoute(
  () => {
    const context = getCurrentContext(); // Get context from middleware
    
    mount(() => (
      <ComplexPage 
        preloadedData={context.metadata.preloadedData}
        abTestVariant={context.metadata.abTests?.complexPageTest}
        featureFlags={context.metadata.featureFlags}
      />
    ), '#app');
  },
  [
    errorBoundaryMiddleware,
    authMiddleware,
    createFeatureFlagMiddleware('complex_page_v2'),
    createABTestMiddleware('complexPageTest'),
    createCacheMiddleware(600000), // 10 minutes
    createDataPreloadMiddleware(
      async (params) => {
        const [userData, settings, analytics] = await Promise.all([
          fetch(`/api/user/${params.id}`).then(r => r.json()),
          fetch('/api/user/settings').then(r => r.json()),
          fetch('/api/analytics/summary').then(r => r.json())
        ]);
        
        return { userData, settings, analytics };
      },
      'complexPageData'
    ),
    createPermissionMiddleware('view_complex_page')
  ]
);

router({
  '/complex/:id': {
    handler: complexRouteHandler
  }
});
```

## Conditional Middleware

Apply middleware conditionally based on route patterns and user context:

```typescript
// Conditional middleware application
const createConditionalMiddleware = (
  condition: (context: MiddlewareContext) => boolean,
  middleware: Middleware
): Middleware => {
  return async (context, next) => {
    if (condition(context)) {
      return middleware(context, next);
    }
    return next();
  };
};

// Route pattern matcher
const matchesRoute = (pattern: RegExp) => (context: MiddlewareContext) => {
  return pattern.test(context.route.path);
};

// User role checker
const hasRole = (role: string) => (context: MiddlewareContext) => {
  return context.user?.role === role;
};

// Time-based conditions
const isDuringBusinessHours = (context: MiddlewareContext) => {
  const hour = new Date().getHours();
  return hour >= 9 && hour <= 17;
};

// Apply middleware conditionally
middlewareSystem.use(
  createConditionalMiddleware(
    matchesRoute(/^\/admin/),
    createPermissionMiddleware('admin')
  )
);

middlewareSystem.use(
  createConditionalMiddleware(
    (ctx) => matchesRoute(/^\/api\//)(ctx) && !isDuringBusinessHours(ctx),
    async (context, next) => {
      console.log('🌙 API access outside business hours');
      return next();
    }
  )
);

middlewareSystem.use(
  createConditionalMiddleware(
    hasRole('beta_tester'),
    createFeatureFlagMiddleware('beta_features')
  )
);
```