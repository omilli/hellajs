---
title: store
description: A deeply reactive store for managing application state.
---

A deeply reactive store for managing application state.

```typescript
import { store } from '@hellajs/store';

// Create a nested store
const userStore = store({
  name: 'John Doe',
  age: 30,
  address: {
    street: '123 Main St',
    city: 'New York',
  },
});

// Get a plain object snapshot
const user = userStore.computed();
console.log(user);
// { name: 'John Doe', age: 30, address: { street: '123 Main St', city: 'New York' } }

// Update nested property
userStore.update({
  address: {
    city: 'San Francisco',
  },
});
console.log(userStore.address.city()); // 'San Francisco'



userStore.address.street('789 Oak St'); // Set property directly
console.log(userStore.address.street()); // '789 Oak St'
```

## API

```typescript
function store<T extends Record<string, any>>(
  initial: T,
  options?: StoreOptions<T>
): Store<T>

interface Store<T> {
  computed(): T;                    // Get plain object snapshot
  set(value: T): void;             // Replace entire store
  update(partial: PartialDeep<T>): void; // Update nested properties
  cleanup(): void;                 // Cleanup store resources
}
```

## Reactive Updates

Store properties are reactive signals that automatically notify subscribers when changed.

```typescript
import { store, effect } from '@hellajs/core';

const userStore = store({
  name: 'John',
  profile: {
    theme: 'light',
    notifications: true
  }
});

// React to store changes
effect(() => {
  console.log('User:', userStore.name());
  console.log('Theme:', userStore.profile.theme());
});

// Updates trigger effects
userStore.name('Jane'); // Logs: "User: Jane"
userStore.profile.theme('dark'); // Logs: "Theme: dark"
```

## Batch Updates

Use batch() when making multiple store changes to prevent unnecessary re-renders.

```typescript
import { store, batch } from '@hellajs/core';

const userStore = store({
  name: 'John',
  email: 'john@example.com',
  age: 30
});

// Batch multiple updates
batch(() => {
  userStore.name('Jane');
  userStore.email('jane@example.com');
  userStore.age(25);
}); // Only triggers effects once at the end
```

## Computed Properties

Create derived values from store data using computed signals.

```typescript
import { store, computed } from '@hellajs/core';

const cartStore = store({
  items: [
    { id: 1, price: 10, quantity: 2 },
    { id: 2, price: 15, quantity: 1 }
  ],
  taxRate: 0.08
});

// Computed total
const total = computed(() => 
  cartStore.items().reduce((sum, item) => sum + item.price * item.quantity, 0)
);

const totalWithTax = computed(() => 
  total() * (1 + cartStore.taxRate())
);

console.log(total()); // 35
console.log(totalWithTax()); // 37.8
```

## Performance Tips

Optimize store updates for better performance.

```typescript
// ✅ Good: Update specific nested properties
userStore.update({
  profile: {
    theme: 'dark'
  }
});

// ❌ Bad: Replacing entire nested objects
userStore.profile.set({
  ...userStore.profile.computed(),
  theme: 'dark'
});

// ✅ Good: Batch related updates
batch(() => {
  userStore.name(newName);
  userStore.email(newEmail);
  userStore.lastUpdated(Date.now());
});
```

## Common Patterns

Typical patterns for store management.

```typescript
// Form state management
const formStore = store({
  data: { name: '', email: '' },
  errors: {},
  isSubmitting: false,
  isDirty: false
});

const updateField = (field: string, value: string) => {
  batch(() => {
    formStore.data[field](value);
    formStore.isDirty(true);
    // Clear error when field is updated
    if (formStore.errors()[field]) {
      formStore.update({
        errors: { ...formStore.errors(), [field]: undefined }
      });
    }
  });
};

// Async state management
const dataStore = store({
  items: [],
  loading: false,
  error: null
});

const fetchItems = async () => {
  batch(() => {
    dataStore.loading(true);
    dataStore.error(null);
  });
  
  try {
    const items = await api.getItems();
    batch(() => {
      dataStore.items(items);
      dataStore.loading(false);
    });
  } catch (error) {
    batch(() => {
      dataStore.error(error);
      dataStore.loading(false);
    });
  }
};
```