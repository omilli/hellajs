---
title: store
description: A deeply reactive store for managing application state with full type safety and flexible readonly controls.
---

Creates a deeply reactive object where every property is a signal. It's designed for managing complex, nested application state.

## API

```typescript
function store<T>(initial: T, options?: StoreOptions<T>): Store<T>

interface Store<T> {
  // Properties from T are converted to signals or nested stores
  [K in keyof T]: // ...

  // Methods
  computed(): T;
  set(value: T): void;
  update(partial: PartialDeep<T>): void;
  cleanup(): void;
}

interface StoreOptions<T> {
  readonly?: boolean | readonly (keyof T)[];
}
```

## TypeScript

The `store` function is fully type-safe, preserving your initial object's structure and providing type inference for all properties and methods.

```typescript
import { store } from '@hellajs/store';

interface User {
  name: string;
  age: number;
  settings: { theme: 'dark' | 'light' };
}

const userStore = store<User>({
  name: 'John Doe',
  age: 30,
  settings: { theme: 'dark' },
});

// userStore.name is Signal<string>
// userStore.settings.theme is Signal<'dark' | 'light'>
```

## Basic Usage

Create a store by passing a plain JavaScript object. Access properties as signal functions to read their values, and call them with a new value to update.

```typescript
import { store } from '@hellajs/store';
import { effect } from '@hellajs/core';

const user = store({
  name: 'John Doe',
  address: {
    city: 'New York',
  },
});

effect(() => {
  console.log(`${user.name()} lives in ${user.address.city()}`);
});
// Logs: "John Doe lives in New York"

// Update a top-level property
user.name('Jane Doe');
// Logs: "Jane Doe lives in New York"

// Update a nested property
user.address.city('San Francisco');
// Logs: "Jane Doe lives in San Francisco"
```

## Updating State

There are two primary ways to update a store's state.

### `set(value)`
Replaces the entire store's state with a new object.

```typescript
const state = store({ a: 1, b: 2 });
state.set({ a: 10, b: 20 });
console.log(state.a()); // 10
```

### `update(partial)`
Performs a deep, partial update. This is useful for changing nested properties without replacing the entire parent object.

```typescript
const product = store({
  name: 'Laptop',
  details: { price: 1000, brand: 'BrandX' }
});

// Update only the price
product.update({
  details: { price: 950 }
});

console.log(product.details.brand()); // "BrandX" (unchanged)
console.log(product.details.price()); // 950 (updated)
```

## Readonly Properties

You can prevent properties from being changed after the store is created using the `readonly` option.

```typescript
const config = store({
  apiKey: 'abc-123',
  timeout: 5000,
}, { 
  // `apiKey` cannot be changed, but `timeout` can
  readonly: ['apiKey'] 
});

config.apiKey('new-key');
console.log(config.apiKey()); // "abc-123"

config.timeout(10000);
console.log(config.timeout()); // 10000
```
To make the entire store readonly, use `{ readonly: true }`.

## Getting a Plain Object Snapshot

The `.computed()` method returns a non-reactive, plain JavaScript object representing the current state of the store.

```typescript
const reactiveStore = store({ name: 'John', age: 31 });
const snapshot = reactiveStore.computed();

console.log(snapshot); // { name: 'John', age: 31 }
```

## Memory Management

Stores create reactive signals that need to be cleaned up to prevent memory leaks. Call the `.cleanup()` method when the store is no longer needed (e.g., when a component unmounts).

```typescript
const myStore = store({ ... });

// When you're done with the store:
myStore.cleanup();
```
