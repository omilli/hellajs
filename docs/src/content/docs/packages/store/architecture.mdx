---
title: Store Architecture
description: Scalable store architectures for complex applications including modules, actions, and store composition.
---

Design scalable store architectures for complex applications with modular stores, action patterns, and composition strategies.

## Modular Store Architecture

Create modular stores that can be composed into larger application state:

```typescript
import { store, computed, signal, batch } from '@hellajs/core';

// Base store interface
interface StoreModule<T> {
  state: T;
  actions: Record<string, (...args: any[]) => void>;
  computed: Record<string, () => any>;
  cleanup?: () => void;
}

// User module
const createUserModule = () => {
  const userState = store({
    currentUser: null as User | null,
    preferences: {
      theme: 'light' as 'light' | 'dark',
      language: 'en',
      notifications: true
    },
    loginStatus: 'idle' as 'idle' | 'loading' | 'authenticated' | 'error'
  });

  const actions = {
    login: async (credentials: { email: string; password: string }) => {
      userState.loginStatus('loading');
      
      try {
        const response = await fetch('/api/auth/login', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(credentials)
        });

        if (!response.ok) throw new Error('Login failed');

        const user = await response.json();
        
        batch(() => {
          userState.currentUser(user);
          userState.loginStatus('authenticated');
        });
      } catch (error) {
        batch(() => {
          userState.currentUser(null);
          userState.loginStatus('error');
        });
        throw error;
      }
    },

    logout: () => {
      batch(() => {
        userState.currentUser(null);
        userState.loginStatus('idle');
      });
    },

    updatePreferences: (preferences: Partial<typeof userState.preferences>) => {
      userState.update({ preferences });
    },

    setTheme: (theme: 'light' | 'dark') => {
      userState.preferences.theme(theme);
    }
  };

  const computed = {
    isAuthenticated: () => userState.currentUser() !== null,
    isLoading: () => userState.loginStatus() === 'loading',
    userName: () => userState.currentUser()?.name || 'Guest',
    initials: () => {
      const user = userState.currentUser();
      if (!user) return 'G';
      return user.name
        .split(' ')
        .map(n => n[0])
        .join('')
        .toUpperCase();
    }
  };

  return {
    state: userState,
    actions,
    computed
  } as StoreModule<typeof userState>;
};

// Cart module
const createCartModule = () => {
  const cartState = store({
    items: [] as CartItem[],
    discountCode: '',
    shippingAddress: null as Address | null,
    status: 'idle' as 'idle' | 'calculating' | 'ready' | 'error'
  });

  const actions = {
    addItem: (product: Product, quantity = 1) => {
      const existingItemIndex = cartState.items().findIndex(
        item => item.productId === product.id
      );

      if (existingItemIndex >= 0) {
        const items = [...cartState.items()];
        items[existingItemIndex] = {
          ...items[existingItemIndex],
          quantity: items[existingItemIndex].quantity + quantity
        };
        cartState.items(items);
      } else {
        cartState.items([
          ...cartState.items(),
          {
            id: `${product.id}-${Date.now()}`,
            productId: product.id,
            name: product.name,
            price: product.price,
            quantity
          }
        ]);
      }
    },

    removeItem: (itemId: string) => {
      cartState.items(cartState.items().filter(item => item.id !== itemId));
    },

    updateQuantity: (itemId: string, quantity: number) => {
      if (quantity <= 0) {
        actions.removeItem(itemId);
        return;
      }

      const items = cartState.items().map(item =>
        item.id === itemId ? { ...item, quantity } : item
      );
      cartState.items(items);
    },

    applyDiscount: (code: string) => {
      cartState.discountCode(code);
    },

    setShippingAddress: (address: Address) => {
      cartState.shippingAddress(address);
    },

    clear: () => {
      batch(() => {
        cartState.items([]);
        cartState.discountCode('');
        cartState.shippingAddress(null);
        cartState.status('idle');
      });
    }
  };

  const computed = {
    itemCount: () => cartState.items().reduce((sum, item) => sum + item.quantity, 0),
    
    subtotal: () => cartState.items().reduce(
      (sum, item) => sum + item.price * item.quantity, 0
    ),
    
    hasItems: () => cartState.items().length > 0,
    
    canCheckout: () => 
      computed.hasItems() && 
      cartState.shippingAddress() !== null &&
      cartState.status() !== 'calculating'
  };

  return {
    state: cartState,
    actions,
    computed
  } as StoreModule<typeof cartState>;
};

// Notifications module
const createNotificationsModule = () => {
  const notificationsState = store({
    notifications: [] as Notification[],
    unreadCount: 0,
    settings: {
      showDesktop: true,
      playSound: false,
      maxVisible: 5
    }
  });

  const actions = {
    add: (notification: Omit<Notification, 'id' | 'timestamp'>) => {
      const newNotification: Notification = {
        ...notification,
        id: `notification-${Date.now()}-${Math.random()}`,
        timestamp: Date.now()
      };

      notificationsState.notifications([
        newNotification,
        ...notificationsState.notifications()
      ]);

      if (!notification.read) {
        notificationsState.unreadCount(notificationsState.unreadCount() + 1);
      }

      // Auto-remove after delay for non-persistent notifications
      if (notification.type !== 'persistent') {
        setTimeout(() => {
          actions.remove(newNotification.id);
        }, notification.duration || 5000);
      }
    },

    remove: (id: string) => {
      const notification = notificationsState.notifications().find(n => n.id === id);
      if (notification && !notification.read) {
        notificationsState.unreadCount(Math.max(0, notificationsState.unreadCount() - 1));
      }
      
      notificationsState.notifications(
        notificationsState.notifications().filter(n => n.id !== id)
      );
    },

    markAsRead: (id: string) => {
      const notifications = notificationsState.notifications().map(n =>
        n.id === id ? { ...n, read: true } : n
      );
      
      notificationsState.notifications(notifications);
      notificationsState.unreadCount(Math.max(0, notificationsState.unreadCount() - 1));
    },

    markAllAsRead: () => {
      const notifications = notificationsState.notifications().map(n => ({ ...n, read: true }));
      notificationsState.notifications(notifications);
      notificationsState.unreadCount(0);
    },

    clear: () => {
      batch(() => {
        notificationsState.notifications([]);
        notificationsState.unreadCount(0);
      });
    }
  };

  const computed = {
    hasUnread: () => notificationsState.unreadCount() > 0,
    visibleNotifications: () => 
      notificationsState.notifications().slice(0, notificationsState.settings.maxVisible()),
    recentNotifications: () =>
      notificationsState.notifications().filter(n => 
        Date.now() - n.timestamp < 24 * 60 * 60 * 1000 // Last 24 hours
      )
  };

  return {
    state: notificationsState,
    actions,
    computed
  } as StoreModule<typeof notificationsState>;
};
```

## Store Composition and Root Store

Compose modular stores into a unified application store:

```typescript
// Root store that composes all modules
const createRootStore = () => {
  const user = createUserModule();
  const cart = createCartModule();
  const notifications = createNotificationsModule();

  // Global app state
  const appState = store({
    isLoading: false,
    error: null as string | null,
    theme: 'light' as 'light' | 'dark',
    sidebarOpen: false,
    currentRoute: '/',
    online: navigator.onLine
  });

  // Cross-module actions that coordinate between modules
  const globalActions = {
    initialize: async () => {
      appState.isLoading(true);

      try {
        // Initialize user session
        const token = localStorage.getItem('auth_token');
        if (token) {
          // Verify token and load user
          await user.actions.login({ email: '', password: '' }); // Implement token verification
        }

        // Load persisted cart
        const savedCart = localStorage.getItem('cart');
        if (savedCart) {
          const cartData = JSON.parse(savedCart);
          // Restore cart items
        }

        appState.error(null);
      } catch (error) {
        appState.error(error instanceof Error ? error.message : 'Initialization failed');
        notifications.actions.add({
          type: 'error',
          title: 'Initialization Error',
          message: 'Failed to initialize application',
          read: false
        });
      } finally {
        appState.isLoading(false);
      }
    },

    logout: () => {
      batch(() => {
        user.actions.logout();
        cart.actions.clear();
        notifications.actions.clear();
        appState.error(null);
      });

      notifications.actions.add({
        type: 'success',
        title: 'Logged Out',
        message: 'You have been successfully logged out',
        read: false,
        duration: 3000
      });
    },

    setTheme: (theme: 'light' | 'dark') => {
      batch(() => {
        appState.theme(theme);
        user.actions.setTheme(theme);
      });
      
      // Persist theme preference
      localStorage.setItem('theme', theme);
      document.documentElement.setAttribute('data-theme', theme);
    },

    handleError: (error: string, context?: string) => {
      appState.error(error);
      
      notifications.actions.add({
        type: 'error',
        title: context ? `Error in ${context}` : 'Error',
        message: error,
        read: false,
        duration: 8000
      });
    },

    clearError: () => {
      appState.error(null);
    }
  };

  // Global computed values that span multiple modules
  const globalComputed = {
    appReady: () => !appState.isLoading() && !appState.error(),
    
    userName: () => user.computed.isAuthenticated() 
      ? user.computed.userName() 
      : 'Guest',
      
    cartSummary: () => ({
      itemCount: cart.computed.itemCount(),
      total: cart.computed.subtotal(),
      hasItems: cart.computed.hasItems()
    }),
    
    notificationSummary: () => ({
      count: notifications.state.unreadCount(),
      hasUnread: notifications.computed.hasUnread(),
      recent: notifications.computed.recentNotifications().slice(0, 3)
    }),

    dashboardData: () => ({
      user: user.state.computed(),
      cartSummary: globalComputed.cartSummary(),
      notifications: globalComputed.notificationSummary(),
      appStatus: {
        theme: appState.theme(),
        online: appState.online(),
        route: appState.currentRoute()
      }
    })
  };

  // Cross-module effects for coordination
  const effects = [
    // Save cart when it changes
    () => effect(() => {
      const cartData = cart.state.computed();
      localStorage.setItem('cart', JSON.stringify(cartData));
    }),

    // Show notification when user logs in/out
    () => effect(() => {
      const isAuthenticated = user.computed.isAuthenticated();
      const userName = user.computed.userName();
      
      // Skip initial run
      if (userName !== 'Guest' && isAuthenticated) {
        notifications.actions.add({
          type: 'success',
          title: 'Welcome Back',
          message: `Hello ${userName}!`,
          read: false,
          duration: 4000
        });
      }
    }),

    // Handle online/offline status
    () => effect(() => {
      const handleOnline = () => {
        appState.online(true);
        notifications.actions.add({
          type: 'info',
          title: 'Back Online',
          message: 'Connection restored',
          read: false,
          duration: 3000
        });
      };

      const handleOffline = () => {
        appState.online(false);
        notifications.actions.add({
          type: 'warning',
          title: 'Offline',
          message: 'Connection lost. Some features may be unavailable.',
          read: false,
          type: 'persistent'
        });
      };

      window.addEventListener('online', handleOnline);
      window.addEventListener('offline', handleOffline);

      return () => {
        window.removeEventListener('online', handleOnline);
        window.removeEventListener('offline', handleOffline);
      };
    })
  ];

  // Initialize effects
  const cleanupFunctions = effects.map(effect => effect());

  const cleanup = () => {
    cleanupFunctions.forEach(cleanup => cleanup?.());
    user.cleanup?.();
    cart.cleanup?.();
    notifications.cleanup?.();
  };

  return {
    // Module access
    user,
    cart,
    notifications,
    
    // Global state
    app: {
      state: appState,
      actions: globalActions,
      computed: globalComputed
    },
    
    // Cleanup
    cleanup
  };
};

// Create and export root store instance
export const rootStore = createRootStore();

// Global store provider for components
export const useStore = () => rootStore;

// Individual module hooks for convenience
export const useUser = () => rootStore.user;
export const useCart = () => rootStore.cart;
export const useNotifications = () => rootStore.notifications;
export const useApp = () => rootStore.app;
```

## Store Testing Patterns

Create testable stores with mock data and test utilities:

```typescript
import { store, signal, computed } from '@hellajs/core';

// Test utilities for stores
const createTestStore = <T extends Record<string, any>>(
  initialState: T,
  options: {
    mockActions?: Record<string, jest.Mock>;
    mockComputed?: Record<string, () => any>;
  } = {}
) => {
  const testState = store(initialState);
  
  const reset = () => {
    testState.set(initialState);
  };

  const setState = (newState: Partial<T>) => {
    testState.update(newState);
  };

  const getSnapshot = () => testState.computed();

  return {
    state: testState,
    reset,
    setState,
    getSnapshot,
    ...options.mockActions,
    computed: {
      ...Object.entries(options.mockComputed || {}).reduce((acc, [key, fn]) => {
        acc[key] = computed(fn);
        return acc;
      }, {} as Record<string, any>)
    }
  };
};

// Example test suite
describe('User Store', () => {
  let userStore: ReturnType<typeof createUserModule>;

  beforeEach(() => {
    userStore = createUserModule();
  });

  afterEach(() => {
    userStore.cleanup?.();
  });

  test('should initialize with default state', () => {
    expect(userStore.computed.isAuthenticated()).toBe(false);
    expect(userStore.computed.userName()).toBe('Guest');
    expect(userStore.state.loginStatus()).toBe('idle');
  });

  test('should update login status during login', async () => {
    // Mock fetch
    global.fetch = jest.fn().mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ id: '1', name: 'John Doe', email: 'john@example.com' })
    });

    const loginPromise = userStore.actions.login({
      email: 'john@example.com',
      password: 'password'
    });

    // Should be loading immediately
    expect(userStore.state.loginStatus()).toBe('loading');

    await loginPromise;

    // Should be authenticated after completion
    expect(userStore.computed.isAuthenticated()).toBe(true);
    expect(userStore.computed.userName()).toBe('John Doe');
    expect(userStore.state.loginStatus()).toBe('authenticated');
  });

  test('should handle login errors', async () => {
    global.fetch = jest.fn().mockResolvedValueOnce({
      ok: false,
      status: 401
    });

    await expect(userStore.actions.login({
      email: 'wrong@example.com',
      password: 'wrongpassword'
    })).rejects.toThrow('Login failed');

    expect(userStore.computed.isAuthenticated()).toBe(false);
    expect(userStore.state.loginStatus()).toBe('error');
  });
});

// Integration tests for store composition
describe('Root Store Integration', () => {
  let store: ReturnType<typeof createRootStore>;

  beforeEach(() => {
    store = createRootStore();
  });

  afterEach(() => {
    store.cleanup();
  });

  test('should coordinate user login with notifications', async () => {
    // Mock successful login
    global.fetch = jest.fn().mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ id: '1', name: 'John Doe', email: 'john@example.com' })
    });

    await store.user.actions.login({
      email: 'john@example.com',
      password: 'password'
    });

    // Should have welcome notification
    const notifications = store.notifications.state.notifications();
    expect(notifications).toHaveLength(1);
    expect(notifications[0].title).toBe('Welcome Back');
    expect(notifications[0].message).toBe('Hello John Doe!');
  });

  test('should clear all data on logout', () => {
    // Set up some data
    store.user.state.currentUser({ id: '1', name: 'John' });
    store.cart.actions.addItem({ id: '1', name: 'Product', price: 10 }, 2);
    store.notifications.actions.add({
      type: 'info',
      title: 'Test',
      message: 'Test message',
      read: false
    });

    // Logout
    store.app.actions.logout();

    // Everything should be cleared
    expect(store.user.computed.isAuthenticated()).toBe(false);
    expect(store.cart.computed.hasItems()).toBe(false);
    expect(store.notifications.state.notifications()).toHaveLength(1); // Only logout confirmation
  });
});
```