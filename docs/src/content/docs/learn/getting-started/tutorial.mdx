---
title: Complete Todo App Tutorial
description: Build a full-featured todo application from scratch with HellaJS
---

import { Aside } from '@astrojs/starlight/components';

# Building a Todo App with HellaJS

## What You'll Build

A complete todo application with the following features:
- Add and remove todos
- Mark todos as completed
- Filter todos (all, active, completed)
- Local storage persistence
- Responsive design

**Live demo:** [View the completed app ‚Üí](https://stackblitz.com/edit/hellajs-todo-tutorial)

## Prerequisites

Before starting, you should understand:
- [Reactivity](/concepts/reactivity) - How HellaJS tracks changes
- [Templating](/concepts/templates) - JSX syntax and patterns

**APIs you'll use:**
- [`signal()`](/api/core/signal) - For reactive state
- [`computed()`](/api/core/computed) - For derived values
- [`effect()`](/api/core/effect) - For side effects
- [`mount()`](/api/dom/mount) - To render the app

## Step-by-Step Tutorial

### Step 1: Project Setup

Create a new Vite project with HellaJS:

```bash
npm create vite@latest todo-app -- --template vanilla
cd todo-app
npm install
```

Install HellaJS dependencies:

```bash
npm install @hellajs/core @hellajs/dom
npm install --save-dev vite-plugin-hellajs
```

Configure Vite in `vite.config.js`:

```js
import { defineConfig } from 'vite';
import viteHellaJS from 'vite-plugin-hellajs';

export default defineConfig({
  plugins: [viteHellaJS()]
});
```

<Aside type="tip">
**TypeScript Setup:** Use `--template vanilla-ts` and add these options to `tsconfig.json`:
```json
{
  "compilerOptions": {
    "jsx": "preserve",
    "types": ["@hellajs/dom"]
  }
}
```
</Aside>

### Step 2: Create the Todo Data Model

Replace `main.js` with our todo application. Start by defining the data structure:

```jsx
import { signal, computed, effect } from '@hellajs/core';
import { mount } from '@hellajs/dom';

// Todo item structure: { id: number, text: string, completed: boolean }
const todos = signal([]);
const filter = signal('all'); // 'all' | 'active' | 'completed'
const newTodoText = signal('');
```

This creates three reactive signals:
- `todos` - Array of todo items
- `filter` - Current filter setting
- `newTodoText` - Text for creating new todos

### Step 3: Add Computed Values

Create derived values that update automatically:

```jsx
// Filtered todos based on current filter
const filteredTodos = computed(() => {
  const filterValue = filter();
  const todoList = todos();
  
  switch (filterValue) {
    case 'active':
      return todoList.filter(todo => !todo.completed);
    case 'completed':
      return todoList.filter(todo => todo.completed);
    default:
      return todoList;
  }
});

// Count statistics
const activeTodoCount = computed(() => 
  todos().filter(todo => !todo.completed).length
);

const completedTodoCount = computed(() => 
  todos().filter(todo => todo.completed).length
);

const totalTodoCount = computed(() => todos().length);
```

<details>
<summary>üîç Why use computed() for filtered todos?</summary>

Computed values only recalculate when their dependencies change. When you change the filter, `filteredTodos()` updates automatically. When you add a todo, it also updates if the new todo matches the current filter.

This is more efficient than filtering in the render function, which would run on every render.

</details>

### Step 4: Implement Todo Actions

Add functions to manipulate todos:

```jsx
// Generate unique IDs for new todos
let nextId = 1;

const addTodo = () => {
  const text = newTodoText().trim();
  if (!text) return;
  
  todos([...todos(), {
    id: nextId++,
    text: text,
    completed: false
  }]);
  
  newTodoText(''); // Clear input
};

const removeTodo = (id) => {
  todos(todos().filter(todo => todo.id !== id));
};

const toggleTodo = (id) => {
  todos(todos().map(todo => 
    todo.id === id 
      ? { ...todo, completed: !todo.completed }
      : todo
  ));
};

const clearCompleted = () => {
  todos(todos().filter(todo => !todo.completed));
};

const toggleAll = () => {
  const allCompleted = activeTodoCount() === 0;
  todos(todos().map(todo => ({ ...todo, completed: !allCompleted })));
};
```

### Step 5: Build the Todo Component

Create the main component with proper event handling:

```jsx
const TodoApp = () => {
  const handleAddTodo = (e) => {
    e.preventDefault();
    addTodo();
  };

  const handleKeyPress = (e) => {
    if (e.key === 'Enter') {
      addTodo();
    }
  };

  return (
    <div class="todo-app">
      <header class="header">
        <h1>todos</h1>
        <form onsubmit={handleAddTodo}>
          <input
            class="new-todo"
            placeholder="What needs to be done?"
            value={newTodoText}
            oninput={(e) => newTodoText(e.target.value)}
            onkeypress={handleKeyPress}
            autofocus
          />
        </form>
      </header>

      {() => totalTodoCount() > 0 && (
        <main class="main">
          <div class="toggle-all-container">
            <input
              id="toggle-all"
              class="toggle-all"
              type="checkbox"
              checked={() => activeTodoCount() === 0}
              onchange={toggleAll}
            />
            <label for="toggle-all">Mark all as complete</label>
          </div>
          
          <ul class="todo-list">
            {() => filteredTodos().map(todo => (
              <TodoItem 
                key={todo.id}
                todo={todo}
                onToggle={() => toggleTodo(todo.id)}
                onRemove={() => removeTodo(todo.id)}
              />
            ))}
          </ul>
        </main>
      )}

      {() => totalTodoCount() > 0 && <TodoFooter />}
    </div>
  );
};
```

### Step 6: Create the Todo Item Component

Build a reusable component for individual todos:

```jsx
const TodoItem = ({ todo, onToggle, onRemove }) => {
  return (
    <li class={() => todo.completed ? 'completed' : ''}>
      <div class="view">
        <input
          class="toggle"
          type="checkbox"
          checked={todo.completed}
          onchange={onToggle}
        />
        <label ondblclick={onToggle}>{todo.text}</label>
        <button class="destroy" onclick={onRemove}></button>
      </div>
    </li>
  );
};
```

<details>
<summary>üí° Component composition pattern</summary>

Notice how `TodoItem` receives `todo` data and `onToggle`/`onRemove` callbacks. This makes it a "controlled component" - it doesn't manage its own state, making it predictable and reusable.

The parent `TodoApp` controls all state changes, and child components just render and handle events.

</details>

### Step 7: Add the Footer with Filters

Create a footer with filtering controls:

```jsx
const TodoFooter = () => {
  const pluralize = (count, word) => 
    count === 1 ? word : `${word}s`;

  return (
    <footer class="footer">
      <span class="todo-count">
        <strong>{activeTodoCount}</strong> {() => pluralize(activeTodoCount(), 'item')} left
      </span>
      
      <ul class="filters">
        <li>
          <a 
            href="#/"
            class={() => filter() === 'all' ? 'selected' : ''}
            onclick={() => filter('all')}
          >
            All
          </a>
        </li>
        <li>
          <a 
            href="#/active"
            class={() => filter() === 'active' ? 'selected' : ''}
            onclick={() => filter('active')}
          >
            Active
          </a>
        </li>
        <li>
          <a 
            href="#/completed"
            class={() => filter() === 'completed' ? 'selected' : ''}
            onclick={() => filter('completed')}
          >
            Completed
          </a>
        </li>
      </ul>
      
      {() => completedTodoCount() > 0 && (
        <button class="clear-completed" onclick={clearCompleted}>
          Clear completed
        </button>
      )}
    </footer>
  );
};
```

### Step 8: Add Local Storage Persistence

Save todos to localStorage automatically:

```jsx
// Load todos from localStorage on startup
const savedTodos = localStorage.getItem('hellajs-todos');
if (savedTodos) {
  try {
    const parsed = JSON.parse(savedTodos);
    todos(parsed);
    // Update nextId based on existing todos
    nextId = Math.max(...parsed.map(t => t.id), 0) + 1;
  } catch (e) {
    console.warn('Failed to load todos from localStorage:', e);
  }
}

// Save todos to localStorage whenever they change
effect(() => {
  localStorage.setItem('hellajs-todos', JSON.stringify(todos()));
});
```

<details>
<summary>‚öôÔ∏è Why use effect() for localStorage?</summary>

The `effect()` automatically runs whenever `todos()` changes. This means every add, remove, toggle, or clear operation will automatically save to localStorage.

Since effects run after DOM updates, this won't block the UI and provides automatic persistence without manual save calls.

</details>

### Step 9: Add Styling

Create `style.css` with TodoMVC-inspired styles:

```css
body {
  margin: 0;
  padding: 0;
  font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
  font-size: 14px;
  line-height: 1.4em;
  background: #f5f5f5;
  color: #111111;
  min-width: 230px;
  max-width: 550px;
  margin: 0 auto;
  -webkit-font-smoothing: antialiased;
}

.todo-app {
  background: #fff;
  margin: 130px auto 40px auto;
  position: relative;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.2),
              0 25px 50px 0 rgba(0, 0, 0, 0.1);
}

.header h1 {
  position: absolute;
  top: -120px;
  width: 100%;
  font-size: 80px;
  font-weight: 200;
  text-align: center;
  color: #b83f45;
  -webkit-text-rendering: optimizeLegibility;
  -moz-text-rendering: optimizeLegibility;
  text-rendering: optimizeLegibility;
}

.new-todo {
  position: relative;
  margin: 0;
  width: 100%;
  font-size: 24px;
  font-family: inherit;
  font-weight: inherit;
  line-height: 1.4em;
  color: inherit;
  padding: 6px;
  border: 1px solid #999;
  box-shadow: inset 0 -1px 5px 0 rgba(0, 0, 0, 0.2);
  box-sizing: border-box;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.toggle-all {
  width: 1px;
  height: 1px;
  border: none;
  opacity: 0;
  position: absolute;
  right: 100%;
  bottom: 100%;
}

.toggle-all + label {
  width: 45px;
  height: 65px;
  font-size: 0;
  position: absolute;
  top: -65px;
  left: -0;
  -webkit-transform: rotate(90deg);
  transform: rotate(90deg);
}

.toggle-all + label:before {
  content: '‚ùØ';
  font-size: 22px;
  color: #949494;
  padding: 10px 27px 10px 27px;
}

.toggle-all:checked + label:before {
  color: #484848;
}

.todo-list {
  margin: 0;
  padding: 0;
  list-style: none;
}

.todo-list li {
  position: relative;
  font-size: 24px;
  border-bottom: 1px solid #ededed;
}

.todo-list li:last-child {
  border-bottom: none;
}

.todo-list li.completed .view label {
  color: #949494;
  text-decoration: line-through;
}

.todo-list li .view {
  position: relative;
  word-wrap: break-word;
  padding: 15px 15px 15px 60px;
  display: block;
  line-height: 1.2;
  transition: color 0.4s;
}

.todo-list li .toggle {
  text-align: center;
  width: 40px;
  height: auto;
  position: absolute;
  top: 0;
  bottom: 0;
  margin: auto 0;
  border: none;
  -webkit-appearance: none;
  appearance: none;
  cursor: pointer;
}

.todo-list li .toggle {
  opacity: 0;
}

.todo-list li .toggle + label {
  background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%23949494%22%20stroke-width%3D%223%22/%3E%3C/svg%3E');
  background-repeat: no-repeat;
  background-position: center left;
}

.todo-list li .toggle:checked + label {
  background-image: url('data:image/svg+xml;utf8,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2240%22%20height%3D%2240%22%20viewBox%3D%22-10%20-18%20100%20135%22%3E%3Ccircle%20cx%3D%2250%22%20cy%3D%2250%22%20r%3D%2250%22%20fill%3D%22none%22%20stroke%3D%22%2359A193%22%20stroke-width%3D%223%22/%3E%3Cpath%20fill%3D%22%233EA390%22%20d%3D%22m72%2025-42%2042-19-19-9%209%2028%2028%2051-51z%22/%3E%3C/svg%3E');
}

.todo-list li label {
  word-break: break-all;
  padding: 15px 15px 15px 60px;
  display: block;
  line-height: 1.2;
  transition: color 0.4s;
  font-weight: 400;
  color: #484848;
}

.todo-list li .destroy {
  display: none;
  position: absolute;
  top: 0;
  right: 10px;
  bottom: 0;
  width: 40px;
  height: 40px;
  margin: auto 0;
  font-size: 30px;
  color: #949494;
  margin-bottom: 11px;
  transition: color 0.2s ease-out;
  cursor: pointer;
}

.todo-list li .destroy:hover,
.todo-list li .destroy:focus {
  color: #C18585;
}

.todo-list li .destroy:after {
  content: '√ó';
}

.todo-list li:hover .destroy {
  display: block;
}

.footer {
  padding: 10px 15px;
  height: 20px;
  text-align: center;
  font-size: 15px;
  border-top: 1px solid #e6e6e6;
}

.footer:before {
  content: '';
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 50px;
  overflow: hidden;
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.2),
              0 8px 0 -3px #f6f6f6,
              0 9px 1px -3px rgba(0, 0, 0, 0.2),
              0 16px 0 -6px #f6f6f6,
              0 17px 2px -6px rgba(0, 0, 0, 0.2);
}

.todo-count {
  float: left;
  text-align: left;
}

.filters {
  margin: 0;
  padding: 0;
  list-style: none;
  position: absolute;
  right: 0;
  left: 0;
}

.filters li {
  display: inline;
}

.filters li a {
  color: inherit;
  margin: 3px;
  padding: 3px 7px;
  text-decoration: none;
  border: 1px solid transparent;
  border-radius: 3px;
}

.filters li a:hover {
  border-color: #DB7676;
}

.filters li a.selected {
  border-color: #CE4646;
}

.clear-completed {
  float: right;
  position: relative;
  line-height: 19px;
  text-decoration: none;
  cursor: pointer;
}

.clear-completed:hover {
  text-decoration: underline;
}
```

Import the styles in your `index.html`:

```html
<link rel="stylesheet" href="/style.css">
```

### Step 10: Mount the Application

Finally, mount the app to the DOM:

```jsx
mount(TodoApp, '#app');
```

## Complete Example

Here's the complete `main.js` file:

```jsx
import { signal, computed, effect } from '@hellajs/core';
import { mount } from '@hellajs/dom';

// State
const todos = signal([]);
const filter = signal('all');
const newTodoText = signal('');

// Load from localStorage
const savedTodos = localStorage.getItem('hellajs-todos');
if (savedTodos) {
  try {
    const parsed = JSON.parse(savedTodos);
    todos(parsed);
  } catch (e) {
    console.warn('Failed to load todos from localStorage:', e);
  }
}

// Save to localStorage
effect(() => {
  localStorage.setItem('hellajs-todos', JSON.stringify(todos()));
});

// Computed values
const filteredTodos = computed(() => {
  const filterValue = filter();
  const todoList = todos();
  
  switch (filterValue) {
    case 'active':
      return todoList.filter(todo => !todo.completed);
    case 'completed':
      return todoList.filter(todo => todo.completed);
    default:
      return todoList;
  }
});

const activeTodoCount = computed(() => 
  todos().filter(todo => !todo.completed).length
);

const completedTodoCount = computed(() => 
  todos().filter(todo => todo.completed).length
);

const totalTodoCount = computed(() => todos().length);

// Actions
let nextId = Math.max(...(todos().map(t => t.id) || [0]), 0) + 1;

const addTodo = () => {
  const text = newTodoText().trim();
  if (!text) return;
  
  todos([...todos(), {
    id: nextId++,
    text: text,
    completed: false
  }]);
  
  newTodoText('');
};

const removeTodo = (id) => {
  todos(todos().filter(todo => todo.id !== id));
};

const toggleTodo = (id) => {
  todos(todos().map(todo => 
    todo.id === id 
      ? { ...todo, completed: !todo.completed }
      : todo
  ));
};

const clearCompleted = () => {
  todos(todos().filter(todo => !todo.completed));
};

const toggleAll = () => {
  const allCompleted = activeTodoCount() === 0;
  todos(todos().map(todo => ({ ...todo, completed: !allCompleted })));
};

// Components
const TodoItem = ({ todo, onToggle, onRemove }) => {
  return (
    <li class={() => todo.completed ? 'completed' : ''}>
      <div class="view">
        <input
          class="toggle"
          type="checkbox"
          checked={todo.completed}
          onchange={onToggle}
        />
        <label ondblclick={onToggle}>{todo.text}</label>
        <button class="destroy" onclick={onRemove}></button>
      </div>
    </li>
  );
};

const TodoFooter = () => {
  const pluralize = (count, word) => 
    count === 1 ? word : `${word}s`;

  return (
    <footer class="footer">
      <span class="todo-count">
        <strong>{activeTodoCount}</strong> {() => pluralize(activeTodoCount(), 'item')} left
      </span>
      
      <ul class="filters">
        <li>
          <a 
            href="#/"
            class={() => filter() === 'all' ? 'selected' : ''}
            onclick={() => filter('all')}
          >
            All
          </a>
        </li>
        <li>
          <a 
            href="#/active"
            class={() => filter() === 'active' ? 'selected' : ''}
            onclick={() => filter('active')}
          >
            Active
          </a>
        </li>
        <li>
          <a 
            href="#/completed"
            class={() => filter() === 'completed' ? 'selected' : ''}
            onclick={() => filter('completed')}
          >
            Completed
          </a>
        </li>
      </ul>
      
      {() => completedTodoCount() > 0 && (
        <button class="clear-completed" onclick={clearCompleted}>
          Clear completed
        </button>
      )}
    </footer>
  );
};

const TodoApp = () => {
  const handleAddTodo = (e) => {
    e.preventDefault();
    addTodo();
  };

  return (
    <div class="todo-app">
      <header class="header">
        <h1>todos</h1>
        <form onsubmit={handleAddTodo}>
          <input
            class="new-todo"
            placeholder="What needs to be done?"
            value={newTodoText}
            oninput={(e) => newTodoText(e.target.value)}
            autofocus
          />
        </form>
      </header>

      {() => totalTodoCount() > 0 && (
        <main class="main">
          <div class="toggle-all-container">
            <input
              id="toggle-all"
              class="toggle-all"
              type="checkbox"
              checked={() => activeTodoCount() === 0}
              onchange={toggleAll}
            />
            <label for="toggle-all">Mark all as complete</label>
          </div>
          
          <ul class="todo-list">
            {() => filteredTodos().map(todo => (
              <TodoItem 
                key={todo.id}
                todo={todo}
                onToggle={() => toggleTodo(todo.id)}
                onRemove={() => removeTodo(todo.id)}
              />
            ))}
          </ul>
        </main>
      )}

      {() => totalTodoCount() > 0 && <TodoFooter />}
    </div>
  );
};

mount(TodoApp, '#app');
```

## Next Steps

Now that you've built a complete todo app, you can:

1. **Add more features:**
   - Edit todos inline
   - Drag and drop reordering
   - Categories or tags
   - Due dates

2. **Improve the architecture:**
   - Extract a custom store using [`store()`](/api/store/store)
   - Add routing with [`router()`](/api/router/router)
   - Implement data fetching with [`resource()`](/api/resource/resource)

3. **Learn more patterns:**
   - [Component Patterns](/guides/patterns/component-patterns)
   - [State Management](/guides/patterns/state-patterns)
   - [Performance Optimization](/guides/performance/optimization)

## Troubleshooting

### Common Issues

**‚ùå "Cannot read property of undefined" errors**
- Check that you're calling signals as functions: `todos()` not `todos`
- Ensure reactive values are accessed inside functions when used in JSX

**‚ùå "Components not updating"**
- Verify you're returning new arrays/objects when updating signals
- Use spread syntax: `[...todos(), newTodo]` instead of `todos().push(newTodo)`

**‚ùå "localStorage errors"**
- Wrap localStorage access in try/catch blocks
- Check that data is properly serialized before saving

**‚ùå "Build errors with JSX"**
- Ensure `vite-plugin-hellajs` is properly configured
- Check that JSX files have the correct extension (.jsx or .tsx)

### Getting Help

- Review the [reactivity concepts](/concepts/reactivity)
- Check the API docs for [`signal()`](/api/core/signal) and [`computed()`](/api/core/computed)
- Browse the [patterns guide](/guides/patterns/) for common solutions

## Related Guides

- [Project Structure](/guides/getting-started/project-structure) - Organize larger applications
- [Component Patterns](/guides/patterns/component-patterns) - Reusable component strategies
- [State Patterns](/guides/patterns/state-patterns) - Advanced state management