---
title: Project Structure Guide
description: Learn how to organize larger HellaJS applications for maintainability and scalability
---

import { Aside, FileTree } from '@astrojs/starlight/components';

# Organizing HellaJS Projects

## What You'll Learn

How to structure HellaJS applications that scale from simple prototypes to production applications with multiple developers.

## Prerequisites

- [Tutorial](/guides/getting-started/tutorial) - Basic HellaJS application building
- [Reactivity](/concepts/reactivity) - Understanding reactive patterns

**Key concepts:**
- Component composition and boundaries
- State management organization
- Module separation and imports

## File Organization Patterns

### Small Project Structure

For applications with &lt;10 components:

<FileTree>
- src/
  - main.jsx              # App entry point
  - App.jsx               # Root component
  - components/
    - Counter.jsx         # Simple components
    - TodoList.jsx
    - UserProfile.jsx
  - styles/
    - global.css          # Global styles
    - components.css      # Component styles
</FileTree>

**Example `main.jsx`:**

```jsx
import { mount } from '@hellajs/dom';
import { App } from './App.jsx';
import './styles/global.css';

mount(App, '#app');
```

**Example `App.jsx`:**

```jsx
import { signal } from '@hellajs/core';
import { Counter } from './components/Counter.jsx';
import { TodoList } from './components/TodoList.jsx';

export const App = () => {
  const currentView = signal('todos');

  return (
    <div class="app">
      <nav>
        <button onclick={() => currentView('counter')}>Counter</button>
        <button onclick={() => currentView('todos')}>Todos</button>
      </nav>
      
      <main>
        {() => currentView() === 'counter' && <Counter />}
        {() => currentView() === 'todos' && <TodoList />}
      </main>
    </div>
  );
};
```

### Medium Project Structure

For applications with 10-50 components:

<FileTree>
- src/
  - main.jsx              # App entry point
  - App.jsx               # Root component
  - components/
    - ui/                 # Reusable UI components
      - Button.jsx
      - Modal.jsx
      - Input.jsx
      - LoadingSpinner.jsx
    - features/           # Feature-specific components
      - auth/
        - LoginForm.jsx
        - SignupForm.jsx
        - UserMenu.jsx
      - todos/
        - TodoList.jsx
        - TodoItem.jsx
        - TodoForm.jsx
      - dashboard/
        - Dashboard.jsx
        - StatsCard.jsx
        - RecentActivity.jsx
  - stores/               # Shared state management
    - authStore.js
    - todosStore.js
    - settingsStore.js
  - services/             # API and external services
    - api.js
    - auth.js
    - localStorage.js
  - utils/                # Helper functions
    - dateHelpers.js
    - validation.js
    - constants.js
  - styles/
    - global.css
    - components/
      - ui.css
      - todos.css
      - auth.css
</FileTree>

### Large Project Structure

For applications with 50+ components:

<FileTree>
- src/
  - main.jsx
  - App.jsx
  - components/
    - ui/                 # Design system components
      - atoms/            # Basic building blocks
        - Button/
          - Button.jsx
          - Button.css
          - Button.test.js
        - Input/
        - Icon/
      - molecules/        # Composed components
        - SearchBar/
        - UserCard/
        - FormField/
      - organisms/        # Complex components
        - Header/
        - Sidebar/
        - DataTable/
    - features/           # Business logic components
      - auth/
        - components/
        - hooks/
        - services/
        - stores/
        - types/
      - todos/
      - dashboard/
      - settings/
  - shared/               # Cross-feature shared code
    - stores/
      - rootStore.js
      - globalState.js
    - services/
      - apiClient.js
      - errorHandler.js
    - hooks/              # Custom reactive hooks
      - useLocalStorage.js
      - useApi.js
    - utils/
    - types/              # TypeScript definitions
      - api.types.js
      - common.types.js
  - assets/
    - icons/
    - images/
    - fonts/
  - styles/
    - globals/
    - themes/
    - components/
</FileTree>

## Component Organization Strategies

### 1. Feature-Based Organization

Group related components by business feature:

```jsx
// features/todos/TodoFeature.jsx
import { TodoList } from './components/TodoList.jsx';
import { TodoForm } from './components/TodoForm.jsx';
import { useTodosStore } from './stores/todosStore.js';

export const TodoFeature = () => {
  const todos = useTodosStore();
  
  return (
    <div class="todo-feature">
      <TodoForm onAdd={todos.add} />
      <TodoList 
        todos={todos.filtered()} 
        onToggle={todos.toggle}
        onRemove={todos.remove}
      />
    </div>
  );
};

// features/todos/stores/todosStore.js
import { signal, computed } from '@hellajs/core';

export const useTodosStore = () => {
  const todos = signal([]);
  const filter = signal('all');
  
  const filtered = computed(() => {
    // Filter logic...
  });
  
  const add = (text) => {
    // Add logic...
  };
  
  const toggle = (id) => {
    // Toggle logic...
  };
  
  const remove = (id) => {
    // Remove logic...
  };
  
  return { todos, filter, filtered, add, toggle, remove };
};
```

### 2. Atomic Design Pattern

Organize components by complexity level:

```jsx
// components/ui/atoms/Button/Button.jsx
export const Button = ({ 
  children, 
  variant = 'primary', 
  size = 'medium',
  disabled = false,
  onclick,
  ...props 
}) => {
  return (
    <button 
      class={`btn btn--${variant} btn--${size}`}
      disabled={disabled}
      onclick={onclick}
      {...props}
    >
      {children}
    </button>
  );
};

// components/ui/molecules/SearchBar/SearchBar.jsx
import { signal } from '@hellajs/core';
import { Button } from '../atoms/Button/Button.jsx';
import { Input } from '../atoms/Input/Input.jsx';

export const SearchBar = ({ onSearch, placeholder }) => {
  const query = signal('');
  
  const handleSearch = () => {
    onSearch(query());
  };
  
  return (
    <div class="search-bar">
      <Input 
        value={query}
        oninput={(e) => query(e.target.value)}
        placeholder={placeholder}
      />
      <Button onclick={handleSearch}>Search</Button>
    </div>
  );
};
```

### 3. Container/Presentational Pattern

Separate data logic from presentation:

```jsx
// components/features/todos/TodoContainer.jsx
import { TodoPresentation } from './TodoPresentation.jsx';
import { useTodosStore } from '../../../stores/todosStore.js';

export const TodoContainer = () => {
  const store = useTodosStore();
  
  return (
    <TodoPresentation
      todos={store.filtered()}
      filter={store.filter}
      loading={store.loading()}
      onAdd={store.add}
      onToggle={store.toggle}
      onRemove={store.remove}
      onFilterChange={store.setFilter}
    />
  );
};

// components/features/todos/TodoPresentation.jsx
import { TodoList } from './TodoList.jsx';
import { TodoForm } from './TodoForm.jsx';
import { TodoFilters } from './TodoFilters.jsx';

export const TodoPresentation = ({
  todos,
  filter,
  loading,
  onAdd,
  onToggle,
  onRemove,
  onFilterChange
}) => {
  if (loading) {
    return <div>Loading todos...</div>;
  }
  
  return (
    <div class="todo-app">
      <TodoForm onAdd={onAdd} />
      <TodoFilters filter={filter} onChange={onFilterChange} />
      <TodoList 
        todos={todos}
        onToggle={onToggle}
        onRemove={onRemove}
      />
    </div>
  );
};
```

## State Management Organization

### Local Component State

Use signals directly in components for local state:

```jsx
// components/ui/molecules/CollapsiblePanel.jsx
import { signal } from '@hellajs/core';

export const CollapsiblePanel = ({ title, children }) => {
  const isOpen = signal(false);
  
  return (
    <div class="collapsible-panel">
      <button 
        class="panel-header"
        onclick={() => isOpen(!isOpen())}
      >
        {title}
        <span class={`arrow ${isOpen() ? 'open' : ''}`}>▼</span>
      </button>
      
      {() => isOpen() && (
        <div class="panel-content">
          {children}
        </div>
      )}
    </div>
  );
};
```

### Shared State Stores

Create dedicated store files for shared state:

```jsx
// stores/authStore.js
import { signal, computed, effect } from '@hellajs/core';
import { apiClient } from '../services/apiClient.js';

const user = signal(null);
const isLoading = signal(false);
const error = signal(null);

const isAuthenticated = computed(() => user() !== null);

const login = async (credentials) => {
  isLoading(true);
  error(null);
  
  try {
    const userData = await apiClient.login(credentials);
    user(userData);
    localStorage.setItem('user', JSON.stringify(userData));
  } catch (err) {
    error(err.message);
  } finally {
    isLoading(false);
  }
};

const logout = () => {
  user(null);
  localStorage.removeItem('user');
};

// Auto-restore user from localStorage
const savedUser = localStorage.getItem('user');
if (savedUser) {
  try {
    user(JSON.parse(savedUser));
  } catch (e) {
    localStorage.removeItem('user');
  }
}

export const authStore = {
  user,
  isLoading,
  error,
  isAuthenticated,
  login,
  logout
};
```

### Global State Composition

Combine multiple stores for complex applications:

```jsx
// stores/rootStore.js
import { authStore } from './authStore.js';
import { todosStore } from './todosStore.js';
import { settingsStore } from './settingsStore.js';
import { notificationsStore } from './notificationsStore.js';

export const rootStore = {
  auth: authStore,
  todos: todosStore,
  settings: settingsStore,
  notifications: notificationsStore
};

// App.jsx
import { rootStore } from './stores/rootStore.js';

export const App = () => {
  return (
    <div class="app">
      {() => rootStore.auth.isAuthenticated() ? (
        <AuthenticatedApp />
      ) : (
        <LoginPage />
      )}
    </div>
  );
};
```

## Module Import Strategies

### Relative Imports (Small Projects)

```jsx
// components/todos/TodoList.jsx
import { TodoItem } from './TodoItem.jsx';
import { useTodosStore } from '../../stores/todosStore.js';
import { Button } from '../ui/Button.jsx';
```

### Absolute Imports (Medium+ Projects)

Configure path mapping in `vite.config.js`:

```js
import { defineConfig } from 'vite';
import viteHellaJS from 'vite-plugin-hellajs';
import path from 'path';

export default defineConfig({
  plugins: [viteHellaJS()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '@components': path.resolve(__dirname, './src/components'),
      '@stores': path.resolve(__dirname, './src/stores'),
      '@services': path.resolve(__dirname, './src/services'),
      '@utils': path.resolve(__dirname, './src/utils')
    }
  }
});
```

Then use clean imports:

```jsx
// components/todos/TodoList.jsx
import { TodoItem } from '@components/todos/TodoItem.jsx';
import { useTodosStore } from '@stores/todosStore.js';
import { Button } from '@components/ui/Button.jsx';
```

### Barrel Exports (Large Projects)

Create index files to simplify imports:

```jsx
// components/ui/index.js
export { Button } from './atoms/Button/Button.jsx';
export { Input } from './atoms/Input/Input.jsx';
export { Modal } from './molecules/Modal/Modal.jsx';
export { SearchBar } from './molecules/SearchBar/SearchBar.jsx';

// Usage
import { Button, Input, Modal } from '@components/ui';
```

<details>
<summary>⚙️ Advanced: Dynamic Imports for Code Splitting</summary>

For large applications, use dynamic imports to load features on demand:

```jsx
// App.jsx
import { signal } from '@hellajs/core';

export const App = () => {
  const currentFeature = signal(null);
  const FeatureComponent = signal(null);
  
  const loadFeature = async (featureName) => {
    currentFeature('loading');
    
    try {
      const module = await import(`./features/${featureName}/index.jsx`);
      FeatureComponent(module.default);
      currentFeature(featureName);
    } catch (error) {
      console.error(`Failed to load feature: ${featureName}`, error);
      currentFeature('error');
    }
  };
  
  return (
    <div class="app">
      <nav>
        <button onclick={() => loadFeature('todos')}>Todos</button>
        <button onclick={() => loadFeature('dashboard')}>Dashboard</button>
      </nav>
      
      <main>
        {() => {
          if (currentFeature() === 'loading') return <div>Loading...</div>;
          if (currentFeature() === 'error') return <div>Error loading feature</div>;
          if (FeatureComponent()) return <FeatureComponent() />;
          return <div>Select a feature</div>;
        }}
      </main>
    </div>
  );
};
```

</details>

## Build Configuration

### TypeScript Configuration

For TypeScript projects, configure `tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"],
      "@components/*": ["./src/components/*"],
      "@stores/*": ["./src/stores/*"],
      "@services/*": ["./src/services/*"],
      "@utils/*": ["./src/utils/*"]
    },
    "types": ["@hellajs/dom"]
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
```

### Environment Configuration

Create environment-specific configurations:

```jsx
// config/env.js
const config = {
  development: {
    API_BASE_URL: 'http://localhost:3001',
    DEBUG: true,
    LOG_LEVEL: 'debug'
  },
  production: {
    API_BASE_URL: 'https://api.myapp.com',
    DEBUG: false,
    LOG_LEVEL: 'error'
  }
};

export const env = config[import.meta.env.MODE] || config.development;

// services/apiClient.js
import { env } from '../config/env.js';

export const apiClient = {
  baseURL: env.API_BASE_URL,
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    
    if (env.DEBUG) {
      console.log(`API Request: ${options.method || 'GET'} ${url}`);
    }
    
    const response = await fetch(url, {
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      ...options
    });
    
    if (!response.ok) {
      throw new Error(`API Error: ${response.status} ${response.statusText}`);
    }
    
    return response.json();
  }
};
```

## Testing Structure

Organize tests alongside components:

<FileTree>
- src/
  - components/
    - ui/
      - Button/
        - Button.jsx
        - Button.test.js
        - Button.stories.js
    - features/
      - todos/
        - TodoList/
          - TodoList.jsx
          - TodoList.test.js
        - stores/
          - todosStore.js
          - todosStore.test.js
  - __tests__/
    - integration/
      - todoFlow.test.js
    - e2e/
      - userJourney.test.js
</FileTree>

## Best Practices

### ✅ DO

- **Keep components small and focused** - Single responsibility principle
- **Use consistent naming conventions** - PascalCase for components, camelCase for functions
- **Separate concerns** - UI logic vs business logic vs data fetching
- **Create reusable abstractions** - Extract common patterns into custom hooks or utilities
- **Document complex logic** - Add comments for non-obvious business rules

### ❌ DON'T

- **Create deep component hierarchies** - Prefer composition over deep nesting
- **Mix presentation and business logic** - Keep components focused on rendering
- **Put everything in one file** - Split large files into smaller, focused modules
- **Use relative imports for distant files** - Configure path aliases for cleaner imports
- **Ignore bundle size** - Monitor and optimize for performance

## Migration Strategies

### From Small to Medium Structure

1. **Create feature directories** for related components
2. **Extract shared state** into dedicated store files
3. **Introduce absolute imports** with path aliases
4. **Add service layer** for API calls and external dependencies

### From Medium to Large Structure

1. **Implement atomic design** patterns for UI components
2. **Create shared utility libraries** for cross-cutting concerns
3. **Add TypeScript** for better maintainability
4. **Implement testing strategy** with proper test organization
5. **Consider micro-frontend architecture** for very large teams

## Next Steps

- [Best Practices](/guides/getting-started/best-practices) - Coding conventions and patterns
- [Component Patterns](/guides/patterns/component-patterns) - Advanced component composition
- [State Patterns](/guides/patterns/state-patterns) - Complex state management strategies

## Troubleshooting

### Common Issues

**❌ Import resolution errors**
- Check path aliases in `vite.config.js`
- Ensure file extensions are included for relative imports
- Verify case sensitivity in file names

**❌ Circular dependency warnings**
- Review import structure for circular references
- Extract shared dependencies to separate modules
- Use barrel exports carefully to avoid circular imports

**❌ Bundle size issues**
- Analyze bundle with `npm run build -- --analyze`
- Implement code splitting for large features
- Tree-shake unused exports

### Performance Considerations

- **Lazy load large features** to reduce initial bundle size
- **Use barrel exports sparingly** to avoid importing unused code
- **Monitor bundle analyzer** to identify optimization opportunities
- **Consider CDN for large dependencies** that don't change often

## Related Guides

- [Component Patterns](/guides/patterns/component-patterns) - Composition strategies
- [Performance Optimization](/guides/performance/optimization) - Application performance
- [Best Practices](/guides/getting-started/best-practices) - Development conventions