---
title: Memory Management
description: Best practices for avoiding memory leaks in HellaJS
---

# Memory Management

HellaJS's reactive system is designed to be memory-efficient, but like any JavaScript application, it's possible to introduce memory leaks. This guide covers best practices for avoiding them.

## 1. Effect Cleanup

Effects can create memory leaks if they set up subscriptions (like event listeners or timers) that are not properly torn down. Always return a cleanup function from your effects.

```jsx
import { effect } from '@hellajs/core';

effect(() => {
  const timer = setInterval(() => {
    console.log('tick');
  }, 1000);

  // This cleanup function is crucial!
  // It runs before the next effect execution or when the effect is disposed.
  return () => {
    clearInterval(timer);
  };
});
```
The `mount` function in HellaJS automatically handles disposing top-level effects when the component is unmounted. For effects created within components, ensure they are cleaned up when the component is destroyed.

## 2. Avoiding Stale References

Be careful about closing over variables in long-lived computations.

```jsx
// Potential leak if `largeDataObject` is not updated
let largeDataObject = { ... };

const myComputed = computed(() => {
  // This computed holds a reference to `largeDataObject`
  return process(largeDataObject);
});

// If `myComputed` is part of a long-lived scope but `largeDataObject`
// is logically no longer needed, it won't be garbage collected.
// Ensure you null out references when they are no longer needed.
largeDataObject = null;
```

## 3. Using Browser Memory Tools

The Memory tab in your browser's developer tools is essential for hunting down leaks.
- **Take heap snapshots** at different points in your application's lifecycle.
- **Compare snapshots** to see which objects are being allocated and not released.
- **Look for detached DOM nodes** that are still held in memory.
