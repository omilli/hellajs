---
title: Performance Optimization
description: Techniques for optimizing HellaJS application performance
---

# Performance Optimization Guide

This guide covers key strategies for optimizing your HellaJS applications.

## 1. Batching State Updates

Group multiple signal updates into a single transaction with `batch()` to prevent unnecessary intermediate computations and re-renders.

**✅ Good:**
```jsx
import { batch } from '@hellajs/core';

batch(() => {
  firstName('Jane');
  lastName('Smith');
  age(31);
});
// Effects and computed values run only once.
```

**❌ Bad:**
```jsx
firstName('Jane');   // Triggers update
lastName('Smith'); // Triggers another update
age(31);           // Triggers a third update
```

## 2. Memoizing Expensive Computations

Use `computed()` to cache the results of expensive calculations. The computation only re-runs when its dependencies change.

```jsx
import { computed } from '@hellajs/core';

const filteredData = computed(() => {
  // This expensive filtering logic only runs when `rawData` or `filter` changes.
  return rawData().filter(item => item.name.includes(filter()));
});
```

## 3. Efficient List Rendering

Use the `forEach` helper for rendering lists. Provide a stable, unique `key` for each item to help HellaJS optimize DOM updates.

```jsx
import { forEach } from '@hellajs/dom';

<ul>
  {forEach(items, (item) => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
```

## 4. Code Splitting and Lazy Loading

Use dynamic `import()` to load components only when they are needed. This is crucial for reducing the initial bundle size of your application.

```jsx
const loadAdminDashboard = () => import('./features/admin/Dashboard.jsx');

const App = () => {
  const showDashboard = signal(false);

  return (
    <div>
      <button onclick={() => showDashboard(true)}>Load Dashboard</button>
      {() => showDashboard() && <Lazy component={loadAdminDashboard} />}
    </div>
  );
};
```

## 5. Minimizing Reactivity

- Don't make static data reactive. Use plain variables for values that never change.
- Use `untracked()` to read signals inside reactive scopes without creating a dependency, preventing unnecessary re-runs.
