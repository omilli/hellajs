---
title: State Management Patterns
description: Patterns for managing application state at different scales with HellaJS
---

import { Aside } from '@astrojs/starlight/components';

# State Management Patterns

## What You'll Learn

Proven strategies for organizing and managing state in HellaJS applications, from simple local state to complex global state architectures.

## Prerequisites

- [Component Patterns](/guides/patterns/component-patterns) - Understanding composition strategies
- [Best Practices](/guides/getting-started/best-practices) - State ownership principles

**APIs you'll use:**
- [`signal()`](/api/core/signal) - For reactive state
- [`computed()`](/api/core/computed) - For derived values
- [`store()`](/api/store/store) - For complex state objects
- [`effect()`](/api/core/effect) - For side effects

## Local State Patterns

### 1. Component State Organization

Structure local state for maintainability:

```jsx
const ProductCard = ({ productId }) => {
  // Group related state together
  const ui = {
    isExpanded: signal(false),
    isHovered: signal(false),
    showTooltip: signal(false)
  };
  
  const data = {
    product: signal(null),
    loading: signal(false),
    error: signal(null)
  };
  
  const actions = {
    toggle: () => ui.isExpanded(!ui.isExpanded()),
    hover: () => ui.isHovered(true),
    unhover: () => ui.isHovered(false),
    showTooltip: () => ui.showTooltip(true),
    hideTooltip: () => ui.showTooltip(false)
  };
  
  // Computed values for complex UI logic
  const displayState = {
    shouldShowDetails: computed(() => ui.isExpanded() || ui.isHovered()),
    cardClasses: computed(() => [
      'product-card',
      ui.isExpanded() && 'product-card--expanded',
      ui.isHovered() && 'product-card--hovered',
      data.loading() && 'product-card--loading'
    ].filter(Boolean).join(' ')),
    
    tooltipPosition: computed(() => {
      if (!ui.showTooltip()) return null;
      // Calculate tooltip position based on card state
      return ui.isExpanded() ? 'bottom' : 'top';
    })
  };
  
  // Data fetching effect
  effect(() => {
    if (!productId) return;
    
    data.loading(true);
    data.error(null);
    
    fetchProduct(productId)
      .then(product => data.product(product))
      .catch(error => data.error(error))
      .finally(() => data.loading(false));
  });
  
  return (
    <div 
      class={displayState.cardClasses}
      onmouseenter={actions.hover}
      onmouseleave={actions.unhover}
    >
      {/* Component content */}
    </div>
  );
};
```

### 2. State Hooks Pattern

Extract reusable state logic:

```jsx
// useCounter - Simple counter with bounds
const useCounter = (initialValue = 0, { min, max, step = 1 } = {}) => {
  const count = signal(initialValue);
  
  const increment = () => {
    const newValue = count() + step;
    count(max !== undefined ? Math.min(newValue, max) : newValue);
  };
  
  const decrement = () => {
    const newValue = count() - step;
    count(min !== undefined ? Math.max(newValue, min) : newValue);
  };
  
  const set = (value) => {
    let newValue = value;
    if (min !== undefined) newValue = Math.max(newValue, min);
    if (max !== undefined) newValue = Math.min(newValue, max);
    count(newValue);
  };
  
  const reset = () => count(initialValue);
  
  const isAtMin = computed(() => min !== undefined && count() <= min);
  const isAtMax = computed(() => max !== undefined && count() >= max);
  const canIncrement = computed(() => !isAtMax());
  const canDecrement = computed(() => !isAtMin());
  
  return {
    count,
    increment,
    decrement,
    set,
    reset,
    isAtMin,
    isAtMax,
    canIncrement,
    canDecrement
  };
};

// useToggleGroup - Multiple toggle states
const useToggleGroup = (initialStates = {}) => {
  const states = signal(initialStates);
  
  const toggle = (key) => {
    states({ ...states(), [key]: !states()[key] });
  };
  
  const set = (key, value) => {
    states({ ...states(), [key]: value });
  };
  
  const setAll = (value) => {
    const newStates = {};
    Object.keys(states()).forEach(key => {
      newStates[key] = value;
    });
    states(newStates);
  };
  
  const get = (key) => states()[key];
  const getAll = () => states();
  
  const allTrue = computed(() => 
    Object.values(states()).every(state => state)
  );
  
  const allFalse = computed(() => 
    Object.values(states()).every(state => !state)
  );
  
  const someTrue = computed(() => 
    Object.values(states()).some(state => state)
  );
  
  return {
    toggle,
    set,
    setAll,
    get,
    getAll,
    allTrue,
    allFalse,
    someTrue
  };
};

// Usage examples
const QuantitySelector = ({ max = 10, onChange }) => {
  const { count, increment, decrement, canIncrement, canDecrement } = useCounter(1, {
    min: 1,
    max
  });
  
  effect(() => {
    onChange?.(count());
  });
  
  return (
    <div class="quantity-selector">
      <button 
        onclick={decrement} 
        disabled={() => !canDecrement()}
        aria-label="Decrease quantity"
      >
        −
      </button>
      <span class="quantity">{count}</span>
      <button 
        onclick={increment} 
        disabled={() => !canIncrement()}
        aria-label="Increase quantity"
      >
        +
      </button>
    </div>
  );
};

const FilterPanel = ({ onFiltersChange }) => {
  const filters = useToggleGroup({
    inStock: false,
    onSale: false,
    freeShipping: false,
    newArrival: false
  });
  
  effect(() => {
    onFiltersChange?.(filters.getAll());
  });
  
  return (
    <div class="filter-panel">
      <h3>Filters</h3>
      <div class="filter-options">
        {Object.keys(filters.getAll()).map(filterKey => (
          <label key={filterKey} class="filter-option">
            <input
              type="checkbox"
              checked={() => filters.get(filterKey)}
              onchange={() => filters.toggle(filterKey)}
            />
            {filterKey.replace(/([A-Z])/g, ' $1').toLowerCase()}
          </label>
        ))}
      </div>
      <div class="filter-actions">
        <button onclick={() => filters.setAll(true)}>Select All</button>
        <button onclick={() => filters.setAll(false)}>Clear All</button>
      </div>
    </div>
  );
};
```

## Global State Patterns

### 1. Store Architecture

Design scalable store patterns:

```jsx
import { store } from '@hellajs/store';

// User store with authentication
const createUserStore = () => {
  const state = store({
    user: null,
    isAuthenticated: false,
    loading: false,
    error: null,
    preferences: {
      theme: 'light',
      language: 'en',
      notifications: true
    }
  });
  
  // Computed values
  const isLoggedIn = computed(() => !!state.user && state.isAuthenticated);
  const userDisplayName = computed(() => {
    const user = state.user;
    return user ? `${user.firstName} ${user.lastName}` : 'Guest';
  });
  
  const hasPermission = computed(() => (permission) => {
    const user = state.user;
    return user?.permissions?.includes(permission) || false;
  });
  
  // Actions
  const login = async (credentials) => {
    state.loading = true;
    state.error = null;
    
    try {
      const response = await authAPI.login(credentials);
      state.user = response.user;
      state.isAuthenticated = true;
      
      // Persist to localStorage
      localStorage.setItem('authToken', response.token);
      localStorage.setItem('user', JSON.stringify(response.user));
      
    } catch (error) {
      state.error = error.message;
      throw error;
    } finally {
      state.loading = false;
    }
  };
  
  const logout = () => {
    state.user = null;
    state.isAuthenticated = false;
    state.error = null;
    
    // Clear persistence
    localStorage.removeItem('authToken');
    localStorage.removeItem('user');
  };
  
  const updateProfile = async (updates) => {
    if (!state.user) throw new Error('No user logged in');
    
    state.loading = true;
    
    try {
      const updatedUser = await userAPI.updateProfile(state.user.id, updates);
      state.user = { ...state.user, ...updatedUser };
      
      // Update localStorage
      localStorage.setItem('user', JSON.stringify(state.user));
    } catch (error) {
      state.error = error.message;
      throw error;
    } finally {
      state.loading = false;
    }
  };
  
  const updatePreferences = (preferences) => {
    state.preferences = { ...state.preferences, ...preferences };
    localStorage.setItem('userPreferences', JSON.stringify(state.preferences));
  };
  
  // Initialize from localStorage
  const initializeFromStorage = () => {
    try {
      const savedUser = localStorage.getItem('user');
      const savedPreferences = localStorage.getItem('userPreferences');
      const token = localStorage.getItem('authToken');
      
      if (savedUser && token) {
        state.user = JSON.parse(savedUser);
        state.isAuthenticated = true;
      }
      
      if (savedPreferences) {
        state.preferences = { ...state.preferences, ...JSON.parse(savedPreferences) };
      }
    } catch (error) {
      console.warn('Failed to restore user state from localStorage:', error);
    }
  };
  
  // Initialize on creation
  initializeFromStorage();
  
  return {
    // State
    state,
    
    // Computed
    isLoggedIn,
    userDisplayName,
    hasPermission,
    
    // Actions
    login,
    logout,
    updateProfile,
    updatePreferences,
    initializeFromStorage
  };
};

// Shopping cart store
const createCartStore = () => {
  const state = store({
    items: [],
    discount: null,
    shippingCost: 0,
    isLoading: false
  });
  
  // Computed values
  const itemCount = computed(() => 
    state.items.reduce((sum, item) => sum + item.quantity, 0)
  );
  
  const subtotal = computed(() => 
    state.items.reduce((sum, item) => sum + (item.price * item.quantity), 0)
  );
  
  const discountAmount = computed(() => {
    const discount = state.discount;
    if (!discount) return 0;
    
    const sub = subtotal();
    return discount.type === 'percentage' 
      ? (sub * discount.value / 100)
      : Math.min(discount.value, sub);
  });
  
  const total = computed(() => 
    subtotal() - discountAmount() + state.shippingCost
  );
  
  const isEmpty = computed(() => state.items.length === 0);
  
  // Actions
  const addItem = (product, quantity = 1) => {
    const existingItem = state.items.find(item => item.id === product.id);
    
    if (existingItem) {
      existingItem.quantity += quantity;
    } else {
      state.items.push({
        id: product.id,
        name: product.name,
        price: product.price,
        image: product.image,
        quantity
      });
    }
    
    persistCart();
  };
  
  const removeItem = (productId) => {
    state.items = state.items.filter(item => item.id !== productId);
    persistCart();
  };
  
  const updateQuantity = (productId, quantity) => {
    const item = state.items.find(item => item.id === productId);
    if (item) {
      if (quantity <= 0) {
        removeItem(productId);
      } else {
        item.quantity = quantity;
        persistCart();
      }
    }
  };
  
  const applyDiscount = (discountCode) => {
    // In real app, validate with API
    state.discount = {
      code: discountCode,
      type: 'percentage',
      value: 10
    };
  };
  
  const removeDiscount = () => {
    state.discount = null;
  };
  
  const clear = () => {
    state.items = [];
    state.discount = null;
    persistCart();
  };
  
  const persistCart = () => {
    localStorage.setItem('cart', JSON.stringify({
      items: state.items,
      discount: state.discount
    }));
  };
  
  const restoreCart = () => {
    try {
      const saved = localStorage.getItem('cart');
      if (saved) {
        const cartData = JSON.parse(saved);
        state.items = cartData.items || [];
        state.discount = cartData.discount || null;
      }
    } catch (error) {
      console.warn('Failed to restore cart from localStorage:', error);
    }
  };
  
  // Initialize
  restoreCart();
  
  return {
    state,
    itemCount,
    subtotal,
    discountAmount,
    total,
    isEmpty,
    addItem,
    removeItem,
    updateQuantity,
    applyDiscount,
    removeDiscount,
    clear,
    restoreCart
  };
};
```

### 2. Store Composition Pattern

Combine multiple stores for complex applications:

```jsx
// Root store that combines all feature stores
const createRootStore = () => {
  const userStore = createUserStore();
  const cartStore = createCartStore();
  const notificationStore = createNotificationStore();
  
  // Cross-store effects
  effect(() => {
    // Clear cart when user logs out
    if (!userStore.isLoggedIn()) {
      cartStore.clear();
    }
  });
  
  effect(() => {
    // Apply user preferences
    const theme = userStore.state.preferences.theme;
    document.documentElement.setAttribute('data-theme', theme);
  });
  
  effect(() => {
    // Show notification when cart changes
    const itemCount = cartStore.itemCount();
    if (itemCount > 0) {
      document.title = `(${itemCount}) My Store`;
    } else {
      document.title = 'My Store';
    }
  });
  
  // Global actions that affect multiple stores
  const checkout = async () => {
    if (!userStore.isLoggedIn()) {
      throw new Error('Must be logged in to checkout');
    }
    
    if (cartStore.isEmpty()) {
      throw new Error('Cart is empty');
    }
    
    try {
      const order = await orderAPI.create({
        userId: userStore.state.user.id,
        items: cartStore.state.items,
        total: cartStore.total()
      });
      
      cartStore.clear();
      notificationStore.show({
        type: 'success',
        message: `Order #${order.id} placed successfully!`
      });
      
      return order;
    } catch (error) {
      notificationStore.show({
        type: 'error',
        message: 'Failed to place order. Please try again.'
      });
      throw error;
    }
  };
  
  const resetApp = () => {
    userStore.logout();
    cartStore.clear();
    notificationStore.clear();
  };
  
  return {
    user: userStore,
    cart: cartStore,
    notifications: notificationStore,
    
    // Global actions
    checkout,
    resetApp
  };
};

// Store provider for accessing stores in components
const StoreContext = signal(null);

const StoreProvider = ({ children }) => {
  const store = createRootStore();
  
  effect(() => {
    StoreContext(store);
  });
  
  return <div class="app">{children}</div>;
};

const useStore = () => {
  const store = StoreContext();
  if (!store) {
    throw new Error('useStore must be used within StoreProvider');
  }
  return store;
};

// Hook for specific store access
const useUserStore = () => useStore().user;
const useCartStore = () => useStore().cart;
const useNotificationStore = () => useStore().notifications;
```

## State Synchronization Patterns

### 1. Optimistic Updates

Update UI immediately, sync with server later:

```jsx
const useOptimisticTodos = () => {
  const todos = signal([]);
  const syncQueue = signal([]);
  const isSyncing = signal(false);
  
  // Generate optimistic IDs
  let optimisticId = -1;
  const getOptimisticId = () => optimisticId--;
  
  const addTodo = async (text) => {
    const optimisticTodo = {
      id: getOptimisticId(),
      text,
      completed: false,
      synced: false,
      optimistic: true
    };
    
    // Immediately update UI
    todos([...todos(), optimisticTodo]);
    
    // Queue for sync
    syncQueue([...syncQueue(), {
      type: 'create',
      optimisticId: optimisticTodo.id,
      data: { text, completed: false }
    }]);
    
    // Sync in background
    try {
      const serverTodo = await todosAPI.create({ text, completed: false });
      
      // Replace optimistic todo with server version
      todos(todos().map(todo => 
        todo.id === optimisticTodo.id 
          ? { ...serverTodo, synced: true, optimistic: false }
          : todo
      ));
      
      // Remove from sync queue
      syncQueue(syncQueue().filter(op => op.optimisticId !== optimisticTodo.id));
      
    } catch (error) {
      // Mark as failed, allow retry
      todos(todos().map(todo => 
        todo.id === optimisticTodo.id 
          ? { ...todo, syncError: error.message }
          : todo
      ));
    }
  };
  
  const toggleTodo = async (id) => {
    const todo = todos().find(t => t.id === id);
    if (!todo) return;
    
    // Optimistic update
    const updatedTodo = { ...todo, completed: !todo.completed, synced: false };
    todos(todos().map(t => t.id === id ? updatedTodo : t));
    
    try {
      const serverTodo = await todosAPI.update(id, { completed: !todo.completed });
      
      // Confirm with server version
      todos(todos().map(t => 
        t.id === id ? { ...serverTodo, synced: true } : t
      ));
      
    } catch (error) {
      // Revert optimistic update
      todos(todos().map(t => 
        t.id === id ? { ...todo, syncError: error.message } : t
      ));
    }
  };
  
  const retryFailedSync = () => {
    const failedTodos = todos().filter(todo => todo.syncError);
    failedTodos.forEach(todo => {
      if (todo.optimistic) {
        // Retry create
        addTodo(todo.text);
      } else {
        // Retry update
        toggleTodo(todo.id);
      }
    });
  };
  
  const hasUnsyncedChanges = computed(() => 
    todos().some(todo => !todo.synced || todo.syncError)
  );
  
  const failedSyncCount = computed(() => 
    todos().filter(todo => todo.syncError).length
  );
  
  return {
    todos,
    addTodo,
    toggleTodo,
    retryFailedSync,
    hasUnsyncedChanges,
    failedSyncCount,
    isSyncing
  };
};
```

### 2. Real-time Synchronization

Keep state in sync with server updates:

```jsx
const useRealtimeStore = (endpoint) => {
  const data = signal(null);
  const connected = signal(false);
  const error = signal(null);
  const retryCount = signal(0);
  
  let ws = null;
  let reconnectTimer = null;
  
  const connect = () => {
    try {
      ws = new WebSocket(endpoint);
      
      ws.onopen = () => {
        connected(true);
        error(null);
        retryCount(0);
        console.log('WebSocket connected');
      };
      
      ws.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);
          handleMessage(message);
        } catch (err) {
          console.error('Failed to parse WebSocket message:', err);
        }
      };
      
      ws.onclose = () => {
        connected(false);
        scheduleReconnect();
      };
      
      ws.onerror = (err) => {
        error(err);
        console.error('WebSocket error:', err);
      };
      
    } catch (err) {
      error(err);
      scheduleReconnect();
    }
  };
  
  const disconnect = () => {
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }
    
    if (ws) {
      ws.close();
      ws = null;
    }
    
    connected(false);
  };
  
  const scheduleReconnect = () => {
    if (reconnectTimer) return;
    
    const delay = Math.min(1000 * Math.pow(2, retryCount()), 30000); // Exponential backoff
    retryCount(retryCount() + 1);
    
    reconnectTimer = setTimeout(() => {
      reconnectTimer = null;
      connect();
    }, delay);
  };
  
  const handleMessage = (message) => {
    switch (message.type) {
      case 'init':
        data(message.data);
        break;
        
      case 'update':
        if (data()) {
          // Merge update with existing data
          data({ ...data(), ...message.data });
        }
        break;
        
      case 'create':
        if (Array.isArray(data())) {
          data([...data(), message.data]);
        }
        break;
        
      case 'delete':
        if (Array.isArray(data())) {
          data(data().filter(item => item.id !== message.id));
        }
        break;
        
      default:
        console.warn('Unknown message type:', message.type);
    }
  };
  
  const send = (message) => {
    if (ws && connected()) {
      ws.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket not connected, cannot send message');
    }
  };
  
  // Auto-connect on creation
  effect(() => {
    connect();
    
    // Cleanup on unmount
    return () => {
      disconnect();
    };
  });
  
  return {
    data,
    connected,
    error,
    retryCount,
    send,
    connect,
    disconnect
  };
};

// Usage in a chat application
const ChatRoom = ({ roomId }) => {
  const { data: messages, connected, send } = useRealtimeStore(
    `ws://localhost:8080/chat/${roomId}`
  );
  
  const newMessage = signal('');
  
  const sendMessage = () => {
    const text = newMessage().trim();
    if (!text || !connected()) return;
    
    send({
      type: 'message',
      data: {
        text,
        timestamp: Date.now(),
        roomId
      }
    });
    
    newMessage('');
  };
  
  return (
    <div class="chat-room">
      <div class="connection-status">
        {() => connected() ? (
          <span class="status-connected">Connected</span>
        ) : (
          <span class="status-disconnected">Disconnected</span>
        )}
      </div>
      
      <div class="messages">
        {() => messages()?.map(message => (
          <div key={message.id} class="message">
            <span class="author">{message.author}:</span>
            <span class="text">{message.text}</span>
            <span class="time">{formatTime(message.timestamp)}</span>
          </div>
        ))}
      </div>
      
      <div class="message-input">
        <input
          type="text"
          value={newMessage}
          oninput={(e) => newMessage(e.target.value)}
          onkeypress={(e) => e.key === 'Enter' && sendMessage()}
          placeholder="Type a message..."
          disabled={() => !connected()}
        />
        <button 
          onclick={sendMessage}
          disabled={() => !newMessage().trim() || !connected()}
        >
          Send
        </button>
      </div>
    </div>
  );
};
```

## State Normalization Patterns

### 1. Normalized Data Structures

Organize complex relational data efficiently:

```jsx
// Normalized store for entities with relationships
const createNormalizedStore = () => {
  const state = store({
    users: {},
    posts: {},
    comments: {},
    loading: {
      users: false,
      posts: false,
      comments: false
    },
    errors: {
      users: null,
      posts: null,
      comments: null
    }
  });
  
  // Normalization helpers
  const normalizeUsers = (users) => {
    const normalized = {};
    users.forEach(user => {
      normalized[user.id] = user;
    });
    return normalized;
  };
  
  const normalizePosts = (posts) => {
    const normalized = {};
    posts.forEach(post => {
      normalized[post.id] = {
        ...post,
        author: post.author.id, // Store only ID reference
        comments: post.comments?.map(comment => comment.id) || []
      };
    });
    return normalized;
  };
  
  const normalizeComments = (comments) => {
    const normalized = {};
    comments.forEach(comment => {
      normalized[comment.id] = {
        ...comment,
        author: comment.author.id,
        post: comment.post.id
      };
    });
    return normalized;
  };
  
  // Selectors for denormalized access
  const getUser = (id) => state.users[id];
  
  const getPost = (id) => {
    const post = state.posts[id];
    if (!post) return null;
    
    return {
      ...post,
      author: getUser(post.author),
      comments: post.comments.map(commentId => getComment(commentId)).filter(Boolean)
    };
  };
  
  const getComment = (id) => {
    const comment = state.comments[id];
    if (!comment) return null;
    
    return {
      ...comment,
      author: getUser(comment.author),
      post: getPost(comment.post)
    };
  };
  
  // Computed selectors
  const allUsers = computed(() => Object.values(state.users));
  const allPosts = computed(() => Object.values(state.posts).map(post => getPost(post.id)));
  const allComments = computed(() => Object.values(state.comments).map(comment => getComment(comment.id)));
  
  const getPostsByUser = (userId) => computed(() => 
    Object.values(state.posts)
      .filter(post => post.author === userId)
      .map(post => getPost(post.id))
  );
  
  const getCommentsByPost = (postId) => computed(() => 
    Object.values(state.comments)
      .filter(comment => comment.post === postId)
      .map(comment => getComment(comment.id))
  );
  
  // Actions
  const loadUsers = async () => {
    state.loading.users = true;
    state.errors.users = null;
    
    try {
      const users = await api.fetchUsers();
      state.users = { ...state.users, ...normalizeUsers(users) };
    } catch (error) {
      state.errors.users = error;
    } finally {
      state.loading.users = false;
    }
  };
  
  const loadPosts = async () => {
    state.loading.posts = true;
    state.errors.posts = null;
    
    try {
      const posts = await api.fetchPosts();
      
      // Extract and normalize users from posts
      const users = posts.map(post => post.author);
      state.users = { ...state.users, ...normalizeUsers(users) };
      
      // Extract and normalize comments
      const allComments = posts.flatMap(post => post.comments || []);
      const commentAuthors = allComments.map(comment => comment.author);
      state.users = { ...state.users, ...normalizeUsers(commentAuthors) };
      state.comments = { ...state.comments, ...normalizeComments(allComments) };
      
      // Normalize posts
      state.posts = { ...state.posts, ...normalizePosts(posts) };
      
    } catch (error) {
      state.errors.posts = error;
    } finally {
      state.loading.posts = false;
    }
  };
  
  const createPost = async (postData) => {
    try {
      const newPost = await api.createPost(postData);
      const normalizedPost = normalizePosts([newPost]);
      state.posts = { ...state.posts, ...normalizedPost };
      
      // Update user data if included
      if (newPost.author) {
        state.users = { ...state.users, [newPost.author.id]: newPost.author };
      }
      
      return newPost;
    } catch (error) {
      state.errors.posts = error;
      throw error;
    }
  };
  
  const updatePost = async (id, updates) => {
    try {
      const updatedPost = await api.updatePost(id, updates);
      state.posts[id] = { ...state.posts[id], ...updates };
      return updatedPost;
    } catch (error) {
      state.errors.posts = error;
      throw error;
    }
  };
  
  const deletePost = async (id) => {
    try {
      await api.deletePost(id);
      
      // Remove post
      const { [id]: removed, ...remainingPosts } = state.posts;
      state.posts = remainingPosts;
      
      // Remove associated comments
      const postComments = Object.keys(state.comments).filter(
        commentId => state.comments[commentId].post === id
      );
      
      const updatedComments = { ...state.comments };
      postComments.forEach(commentId => {
        delete updatedComments[commentId];
      });
      state.comments = updatedComments;
      
    } catch (error) {
      state.errors.posts = error;
      throw error;
    }
  };
  
  return {
    state,
    
    // Selectors
    getUser,
    getPost,
    getComment,
    allUsers,
    allPosts,
    allComments,
    getPostsByUser,
    getCommentsByPost,
    
    // Actions
    loadUsers,
    loadPosts,
    createPost,
    updatePost,
    deletePost
  };
};
```

## Undo/Redo Patterns

### 1. Command Pattern Implementation

Implement undo/redo functionality:

```jsx
// Command pattern for undoable actions
const createUndoableStore = (initialState) => {
  const currentState = signal(initialState);
  const history = signal([]);
  const historyIndex = signal(-1);
  
  const canUndo = computed(() => historyIndex() >= 0);
  const canRedo = computed(() => historyIndex() < history().length - 1);
  
  const saveState = (action, prevState, newState) => {
    const command = {
      action,
      prevState,
      newState,
      timestamp: Date.now()
    };
    
    // Remove any future history if we're not at the end
    const currentIndex = historyIndex();
    const newHistory = history().slice(0, currentIndex + 1);
    newHistory.push(command);
    
    // Limit history size
    const maxHistory = 50;
    if (newHistory.length > maxHistory) {
      newHistory.shift();
    }
    
    history(newHistory);
    historyIndex(newHistory.length - 1);
  };
  
  const execute = (action, reducer) => {
    const prevState = structuredClone(currentState());
    const newState = reducer(prevState);
    
    currentState(newState);
    saveState(action, prevState, newState);
    
    return newState;
  };
  
  const undo = () => {
    if (!canUndo()) return;
    
    const command = history()[historyIndex()];
    currentState(command.prevState);
    historyIndex(historyIndex() - 1);
  };
  
  const redo = () => {
    if (!canRedo()) return;
    
    const command = history()[historyIndex() + 1];
    currentState(command.newState);
    historyIndex(historyIndex() + 1);
  };
  
  const clearHistory = () => {
    history([]);
    historyIndex(-1);
  };
  
  const getHistoryPreview = () => {
    return history().map((command, index) => ({
      ...command,
      isCurrent: index === historyIndex(),
      canRevertTo: index <= historyIndex()
    }));
  };
  
  const revertToState = (targetIndex) => {
    if (targetIndex < 0 || targetIndex >= history().length) return;
    
    const command = history()[targetIndex];
    currentState(command.newState);
    historyIndex(targetIndex);
  };
  
  return {
    state: currentState,
    history,
    historyIndex,
    canUndo,
    canRedo,
    execute,
    undo,
    redo,
    clearHistory,
    getHistoryPreview,
    revertToState
  };
};

// Text editor with undo/redo
const useTextEditor = (initialText = '') => {
  const editor = createUndoableStore({ text: initialText, cursor: 0 });
  
  const insertText = (text, position) => {
    editor.execute(
      `Insert "${text}"`,
      (state) => ({
        ...state,
        text: state.text.slice(0, position) + text + state.text.slice(position),
        cursor: position + text.length
      })
    );
  };
  
  const deleteText = (start, end) => {
    const deletedText = editor.state().text.slice(start, end);
    editor.execute(
      `Delete "${deletedText}"`,
      (state) => ({
        ...state,
        text: state.text.slice(0, start) + state.text.slice(end),
        cursor: start
      })
    );
  };
  
  const replaceText = (start, end, newText) => {
    const oldText = editor.state().text.slice(start, end);
    editor.execute(
      `Replace "${oldText}" with "${newText}"`,
      (state) => ({
        ...state,
        text: state.text.slice(0, start) + newText + state.text.slice(end),
        cursor: start + newText.length
      })
    );
  };
  
  return {
    ...editor,
    insertText,
    deleteText,
    replaceText
  };
};

// Text editor component
const TextEditor = () => {
  const editor = useTextEditor('Hello, world!');
  const inputRef = signal(null);
  
  const handleInput = (e) => {
    const input = e.target;
    const newText = input.value;
    const oldText = editor.state().text;
    
    if (newText !== oldText) {
      const start = 0;
      const end = oldText.length;
      editor.replaceText(start, end, newText);
    }
  };
  
  const handleKeyDown = (e) => {
    if (e.ctrlKey || e.metaKey) {
      if (e.key === 'z' && !e.shiftKey) {
        e.preventDefault();
        editor.undo();
        // Update input value
        if (inputRef()) {
          inputRef().value = editor.state().text;
        }
      } else if (e.key === 'z' && e.shiftKey || e.key === 'y') {
        e.preventDefault();
        editor.redo();
        // Update input value
        if (inputRef()) {
          inputRef().value = editor.state().text;
        }
      }
    }
  };
  
  return (
    <div class="text-editor">
      <div class="editor-toolbar">
        <button 
          onclick={editor.undo}
          disabled={() => !editor.canUndo()}
          title="Undo (Ctrl+Z)"
        >
          ↶ Undo
        </button>
        <button 
          onclick={editor.redo}
          disabled={() => !editor.canRedo()}
          title="Redo (Ctrl+Y)"
        >
          ↷ Redo
        </button>
        <button onclick={editor.clearHistory}>
          Clear History
        </button>
      </div>
      
      <textarea
        ref={inputRef}
        value={() => editor.state().text}
        oninput={handleInput}
        onkeydown={handleKeyDown}
        class="editor-input"
        placeholder="Start typing..."
      />
      
      <div class="editor-status">
        <span>Characters: {() => editor.state().text.length}</span>
        <span>History: {() => editor.history().length} actions</span>
      </div>
    </div>
  );
};
```

## Next Steps

You've learned comprehensive state management patterns for HellaJS. Next, explore:

- [Async Patterns](/guides/patterns/async-patterns) - Data fetching and async operations
- [Error Patterns](/guides/patterns/error-patterns) - Error handling strategies
- [Performance Optimization](/guides/performance/optimization) - State performance optimization

## Troubleshooting

### Common State Management Issues

**❌ State mutations not triggering updates**
- Ensure you're creating new objects/arrays, not mutating existing ones
- Use spread syntax or `structuredClone()` for updates

**❌ Circular dependencies in computed values**
- Review computed dependencies for circular references
- Break complex computations into smaller, focused computed values

**❌ Memory leaks with persistent state**
- Clean up effects and event listeners in component cleanup
- Use weak references for large objects when appropriate

**❌ Performance issues with large state objects**
- Consider normalizing complex relational data
- Use computed values to avoid recalculating derived data
- Implement virtual scrolling for large lists

### State Architecture Guidelines

- **Start simple** - Use local state first, move to global when sharing is needed
- **Single source of truth** - Don't duplicate state between stores
- **Predictable updates** - Use clear action patterns for state changes
- **Immutable updates** - Always create new state objects
- **Separation of concerns** - Keep business logic separate from UI logic

## Related Guides

- [Component Patterns](/guides/patterns/component-patterns) - Component composition strategies
- [Async Patterns](/guides/patterns/async-patterns) - Handling async state updates
- [Performance Optimization](/guides/performance/optimization) - State performance patterns