---
title: Component Patterns
description: Reusable component strategies and composition techniques for building scalable HellaJS applications
---

import { Aside } from '@astrojs/starlight/components';

# Component Patterns

## What You'll Learn

Proven strategies for building reusable, composable components that scale from simple UIs to complex applications.

## Prerequisites

- [Best Practices](/guides/getting-started/best-practices) - Component design principles
- [Reactivity](/concepts/reactivity) - Understanding reactive patterns

**APIs you'll use:**
- [`signal()`](/api/core/signal) - For component state
- [`computed()`](/api/core/computed) - For derived values
- [`effect()`](/api/core/effect) - For side effects

## Composition Patterns

### 1. Compound Components

Build components that work together as a cohesive unit:

```jsx
// Modal compound component system
const Modal = ({ children, isOpen, onClose }) => {
  return (
    <>
      {() => isOpen() && (
        <div class="modal-overlay" onclick={onClose}>
          <div class="modal-content" onclick={(e) => e.stopPropagation()}>
            {children}
          </div>
        </div>
      )}
    </>
  );
};

const ModalHeader = ({ children, showCloseButton = true, onClose }) => (
  <header class="modal-header">
    <div class="modal-title">{children}</div>
    {showCloseButton && (
      <button class="modal-close" onclick={onClose} aria-label="Close">
        √ó
      </button>
    )}
  </header>
);

const ModalBody = ({ children }) => (
  <div class="modal-body">{children}</div>
);

const ModalFooter = ({ children }) => (
  <footer class="modal-footer">{children}</footer>
);

// Usage - Flexible and declarative
const ConfirmDeleteModal = ({ isOpen, onConfirm, onCancel, itemName }) => (
  <Modal isOpen={isOpen} onClose={onCancel}>
    <ModalHeader onClose={onCancel}>
      Confirm Deletion
    </ModalHeader>
    <ModalBody>
      <p>Are you sure you want to delete "{itemName}"?</p>
      <p>This action cannot be undone.</p>
    </ModalBody>
    <ModalFooter>
      <Button variant="secondary" onclick={onCancel}>
        Cancel
      </Button>
      <Button variant="danger" onclick={onConfirm}>
        Delete
      </Button>
    </ModalFooter>
  </Modal>
);
```

<details>
<summary>üîç Why compound components work well</summary>

Compound components provide:
- **Flexibility** - Compose different layouts without complex props
- **Maintainability** - Each part has a single responsibility
- **Discoverability** - Clear API surface with related components
- **Extensibility** - Easy to add new parts without breaking existing code

They're particularly useful for:
- Modal dialogs
- Form layouts
- Card components
- Navigation systems

</details>

### 2. Render Props Pattern

Share logic through render functions:

```jsx
// DataFetcher - Manages async data loading
const DataFetcher = ({ url, children }) => {
  const data = signal(null);
  const loading = signal(false);
  const error = signal(null);
  
  const fetch = async () => {
    loading(true);
    error(null);
    
    try {
      const response = await fetch(url);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);
      const result = await response.json();
      data(result);
    } catch (err) {
      error(err);
    } finally {
      loading(false);
    }
  };
  
  // Fetch on mount and when URL changes
  effect(() => {
    fetch();
  });
  
  // Pass state and actions to children
  return children({
    data: data(),
    loading: loading(),
    error: error(),
    refetch: fetch
  });
};

// Usage - Flexible data presentation
const UserProfile = ({ userId }) => (
  <DataFetcher url={`/api/users/${userId}`}>
    {({ data, loading, error, refetch }) => {
      if (loading) return <ProfileSkeleton />;
      if (error) return <ErrorMessage error={error} onRetry={refetch} />;
      if (!data) return <div>User not found</div>;
      
      return (
        <div class="user-profile">
          <img src={data.avatar} alt={`${data.name} avatar`} />
          <h1>{data.name}</h1>
          <p>{data.bio}</p>
          <button onclick={refetch}>Refresh</button>
        </div>
      );
    }}
  </DataFetcher>
);

// Different usage - List presentation
const UserList = () => (
  <DataFetcher url="/api/users">
    {({ data, loading, error, refetch }) => {
      if (loading) return <ListSkeleton />;
      if (error) return <ErrorBanner error={error} onRetry={refetch} />;
      
      return (
        <div class="user-list">
          <header>
            <h2>Users ({data?.length || 0})</h2>
            <button onclick={refetch}>Refresh</button>
          </header>
          <div class="user-grid">
            {data?.map(user => (
              <UserCard key={user.id} user={user} />
            ))}
          </div>
        </div>
      );
    }}
  </DataFetcher>
);
```

### 3. Custom Hooks Pattern

Extract reusable logic into custom reactive hooks:

```jsx
// useToggle - Simple toggle state
const useToggle = (initialValue = false) => {
  const value = signal(initialValue);
  
  const toggle = () => value(!value());
  const setTrue = () => value(true);
  const setFalse = () => value(false);
  
  return [value, { toggle, setTrue, setFalse }];
};

// useLocalStorage - Persistent state
const useLocalStorage = (key, defaultValue) => {
  const stored = localStorage.getItem(key);
  const value = signal(stored ? JSON.parse(stored) : defaultValue);
  
  // Save to localStorage whenever value changes
  effect(() => {
    localStorage.setItem(key, JSON.stringify(value()));
  });
  
  return [value, (newValue) => value(newValue)];
};

// useApi - HTTP request management
const useApi = (url) => {
  const data = signal(null);
  const loading = signal(false);
  const error = signal(null);
  
  const execute = async (options = {}) => {
    loading(true);
    error(null);
    
    try {
      const response = await fetch(url, {
        headers: { 'Content-Type': 'application/json' },
        ...options
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const result = await response.json();
      data(result);
      return result;
    } catch (err) {
      error(err);
      throw err;
    } finally {
      loading(false);
    }
  };
  
  return { data, loading, error, execute };
};

// Usage - Clean component code
const TodoApp = () => {
  const [showCompleted, { toggle: toggleShowCompleted }] = useToggle(false);
  const [todos, setTodos] = useLocalStorage('todos', []);
  const { data: syncData, loading: syncing, execute: sync } = useApi('/api/sync');
  
  const filteredTodos = computed(() => {
    const todoList = todos();
    return showCompleted() ? todoList : todoList.filter(t => !t.completed);
  });
  
  return (
    <div class="todo-app">
      <header>
        <h1>My Todos</h1>
        <div class="controls">
          <label>
            <input 
              type="checkbox" 
              checked={showCompleted}
              onchange={toggleShowCompleted}
            />
            Show completed
          </label>
          <button onclick={sync} disabled={syncing}>
            {() => syncing() ? 'Syncing...' : 'Sync'}
          </button>
        </div>
      </header>
      
      <TodoList todos={filteredTodos} />
    </div>
  );
};
```

## State Management Patterns

### 1. Container/Presentational Pattern

Separate data logic from presentation:

```jsx
// UserListContainer - Handles data and business logic
const UserListContainer = () => {
  const users = signal([]);
  const loading = signal(false);
  const error = signal(null);
  const searchQuery = signal('');
  
  const filteredUsers = computed(() => {
    const query = searchQuery().toLowerCase();
    return users().filter(user => 
      user.name.toLowerCase().includes(query) ||
      user.email.toLowerCase().includes(query)
    );
  });
  
  const loadUsers = async () => {
    loading(true);
    try {
      const data = await fetchUsers();
      users(data);
    } catch (err) {
      error(err);
    } finally {
      loading(false);
    }
  };
  
  const deleteUser = async (userId) => {
    try {
      await deleteUserApi(userId);
      users(users().filter(u => u.id !== userId));
    } catch (err) {
      error(err);
    }
  };
  
  // Load users on mount
  effect(() => {
    loadUsers();
  });
  
  return (
    <UserListPresentation
      users={filteredUsers()}
      loading={loading()}
      error={error()}
      searchQuery={searchQuery}
      onSearchChange={(query) => searchQuery(query)}
      onDeleteUser={deleteUser}
      onRefresh={loadUsers}
    />
  );
};

// UserListPresentation - Pure presentation component
const UserListPresentation = ({
  users,
  loading,
  error,
  searchQuery,
  onSearchChange,
  onDeleteUser,
  onRefresh
}) => {
  if (loading && users.length === 0) {
    return <LoadingSpinner />;
  }
  
  return (
    <div class="user-list">
      <header class="list-header">
        <h2>Users ({users.length})</h2>
        <div class="list-controls">
          <SearchInput 
            value={searchQuery}
            onInput={onSearchChange}
            placeholder="Search users..."
          />
          <Button onclick={onRefresh} disabled={loading}>
            {loading ? 'Refreshing...' : 'Refresh'}
          </Button>
        </div>
      </header>
      
      {error && (
        <ErrorAlert error={error} onDismiss={() => onRefresh()} />
      )}
      
      <div class="user-grid">
        {users.map(user => (
          <UserCard 
            key={user.id}
            user={user}
            onDelete={() => onDeleteUser(user.id)}
          />
        ))}
      </div>
      
      {users.length === 0 && !loading && (
        <EmptyState message="No users found" />
      )}
    </div>
  );
};
```

### 2. Provider Pattern

Share state across component trees:

```jsx
// ThemeProvider - Global theme management
const ThemeContext = signal(null);

const ThemeProvider = ({ children, initialTheme = 'light' }) => {
  const theme = signal(initialTheme);
  const isDark = computed(() => theme() === 'dark');
  
  const toggleTheme = () => {
    theme(theme() === 'light' ? 'dark' : 'light');
  };
  
  const setTheme = (newTheme) => {
    theme(newTheme);
  };
  
  // Persist theme to localStorage
  effect(() => {
    localStorage.setItem('theme', theme());
    document.documentElement.setAttribute('data-theme', theme());
  });
  
  const contextValue = {
    theme,
    isDark,
    toggleTheme,
    setTheme
  };
  
  // Set context value
  effect(() => {
    ThemeContext(contextValue);
  });
  
  return <div class={`app theme-${theme()}`}>{children}</div>;
};

// useTheme - Custom hook to access theme context
const useTheme = () => {
  const context = ThemeContext();
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

// Components using the theme
const Header = () => {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <header class="app-header">
      <h1>My App</h1>
      <button 
        class="theme-toggle"
        onclick={toggleTheme}
        aria-label={`Switch to ${theme() === 'light' ? 'dark' : 'light'} theme`}
      >
        {() => theme() === 'light' ? 'üåô' : '‚òÄÔ∏è'}
      </button>
    </header>
  );
};

const Card = ({ children, ...props }) => {
  const { isDark } = useTheme();
  
  return (
    <div 
      class={`card ${isDark() ? 'card--dark' : 'card--light'}`}
      {...props}
    >
      {children}
    </div>
  );
};

// App setup
const App = () => (
  <ThemeProvider>
    <Header />
    <main>
      <Card>
        <h2>Welcome!</h2>
        <p>This card adapts to the current theme.</p>
      </Card>
    </main>
  </ThemeProvider>
);
```

## Communication Patterns

### 1. Event Bus Pattern

Decouple components with an event system:

```jsx
// Simple event bus implementation
const createEventBus = () => {
  const listeners = new Map();
  
  const on = (event, callback) => {
    if (!listeners.has(event)) {
      listeners.set(event, new Set());
    }
    listeners.get(event).add(callback);
    
    // Return unsubscribe function
    return () => {
      listeners.get(event)?.delete(callback);
    };
  };
  
  const emit = (event, data) => {
    listeners.get(event)?.forEach(callback => {
      try {
        callback(data);
      } catch (error) {
        console.error(`Error in event listener for "${event}":`, error);
      }
    });
  };
  
  const off = (event, callback) => {
    listeners.get(event)?.delete(callback);
  };
  
  return { on, emit, off };
};

// Global event bus
const eventBus = createEventBus();

// Notification system using event bus
const useNotifications = () => {
  const notifications = signal([]);
  
  const addNotification = (notification) => {
    const id = Date.now();
    const newNotification = { id, ...notification };
    notifications([...notifications(), newNotification]);
    
    // Auto-remove after delay
    if (notification.autoRemove !== false) {
      setTimeout(() => {
        removeNotification(id);
      }, notification.duration || 5000);
    }
    
    return id;
  };
  
  const removeNotification = (id) => {
    notifications(notifications().filter(n => n.id !== id));
  };
  
  // Listen to global notification events
  effect(() => {
    const unsubscribe = eventBus.on('notification', addNotification);
    return unsubscribe;
  });
  
  return { notifications, addNotification, removeNotification };
};

// Components can emit notifications without direct coupling
const UserActions = ({ user }) => {
  const deleteUser = async () => {
    try {
      await deleteUserApi(user.id);
      
      // Emit success notification
      eventBus.emit('notification', {
        type: 'success',
        message: `${user.name} has been deleted`,
        action: {
          label: 'Undo',
          handler: () => restoreUser(user)
        }
      });
    } catch (error) {
      // Emit error notification
      eventBus.emit('notification', {
        type: 'error',
        message: 'Failed to delete user',
        duration: 8000
      });
    }
  };
  
  return (
    <div class="user-actions">
      <button onclick={deleteUser} class="btn-danger">
        Delete User
      </button>
    </div>
  );
};

// Notification display component
const NotificationCenter = () => {
  const { notifications, removeNotification } = useNotifications();
  
  return (
    <div class="notification-center">
      {() => notifications().map(notification => (
        <NotificationItem 
          key={notification.id}
          notification={notification}
          onClose={() => removeNotification(notification.id)}
        />
      ))}
    </div>
  );
};
```

### 2. Observer Pattern

Implement reactive subscriptions:

```jsx
// Observable implementation
const createObservable = (initialValue) => {
  const value = signal(initialValue);
  const subscribers = new Set();
  
  const subscribe = (callback) => {
    subscribers.add(callback);
    
    // Call immediately with current value
    callback(value());
    
    // Return unsubscribe function
    return () => subscribers.delete(callback);
  };
  
  const next = (newValue) => {
    value(newValue);
    subscribers.forEach(callback => {
      try {
        callback(newValue);
      } catch (error) {
        console.error('Error in observable subscriber:', error);
      }
    });
  };
  
  const getValue = () => value();
  
  return { subscribe, next, getValue };
};

// User presence system
const userPresence = createObservable({ online: [], away: [], offline: [] });

// WebSocket connection component
const PresenceUpdater = () => {
  effect(() => {
    const ws = new WebSocket('/ws/presence');
    
    ws.onmessage = (event) => {
      const presenceData = JSON.parse(event.data);
      userPresence.next(presenceData);
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    // Cleanup on unmount
    return () => {
      ws.close();
    };
  });
  
  return null; // This component doesn't render anything
};

// Components subscribe to presence updates
const UserList = () => {
  const users = signal([]);
  const presence = signal({ online: [], away: [], offline: [] });
  
  effect(() => {
    // Subscribe to presence updates
    const unsubscribe = userPresence.subscribe((presenceData) => {
      presence(presenceData);
    });
    
    return unsubscribe;
  });
  
  const getUserStatus = (userId) => {
    const p = presence();
    if (p.online.includes(userId)) return 'online';
    if (p.away.includes(userId)) return 'away';
    return 'offline';
  };
  
  return (
    <div class="user-list">
      {() => users().map(user => (
        <div key={user.id} class="user-item">
          <span class="user-name">{user.name}</span>
          <span class={`status status--${getUserStatus(user.id)}`}>
            {getUserStatus(user.id)}
          </span>
        </div>
      ))}
    </div>
  );
};
```

## UI Patterns

### 1. Conditional Rendering Patterns

Handle complex conditional logic cleanly:

```jsx
// Multi-state component with clear conditional logic
const UserProfile = ({ userId }) => {
  const user = signal(null);
  const loading = signal(false);
  const error = signal(null);
  
  // Define all possible states
  const isEmpty = computed(() => !user() && !loading() && !error());
  const isLoading = computed(() => loading());
  const hasError = computed(() => !!error());
  const hasUser = computed(() => !!user());
  
  // Render based on state priority
  const renderContent = () => {
    if (isLoading()) return <ProfileSkeleton />;
    if (hasError()) return <ErrorState error={error()} onRetry={loadUser} />;
    if (isEmpty()) return <EmptyState message="User not found" />;
    if (hasUser()) return <ProfileContent user={user()} />;
    return null;
  };
  
  const loadUser = async () => {
    loading(true);
    error(null);
    
    try {
      const userData = await fetchUser(userId);
      user(userData);
    } catch (err) {
      error(err);
    } finally {
      loading(false);
    }
  };
  
  effect(() => {
    loadUser();
  });
  
  return (
    <div class="user-profile">
      {renderContent}
    </div>
  );
};

// Switch-case pattern for complex conditions
const NotificationIcon = ({ type, count }) => {
  const getIcon = () => {
    switch (type) {
      case 'email':
        return count() > 0 ? '‚úâÔ∏è' : 'üì¨';
      case 'message':
        return count() > 0 ? 'üí¨' : 'üí≠';
      case 'alert':
        return count() > 0 ? 'üîî' : 'üîï';
      case 'warning':
        return count() > 0 ? '‚ö†Ô∏è' : '‚ö™';
      default:
        return 'üìÑ';
    }
  };
  
  const getColor = () => {
    if (count() === 0) return 'gray';
    if (type === 'alert' || type === 'warning') return 'red';
    return 'blue';
  };
  
  return (
    <div class={`notification-icon notification-icon--${getColor()}`}>
      <span class="icon">{getIcon}</span>
      {() => count() > 0 && (
        <span class="badge">{count() > 99 ? '99+' : count()}</span>
      )}
    </div>
  );
};
```

### 2. List Patterns

Efficient and flexible list rendering:

```jsx
import { forEach } from '@hellajs/dom';

// Virtual list for performance with large datasets
const VirtualList = ({ 
  items, 
  itemHeight, 
  containerHeight, 
  renderItem,
  keyExtractor = (item, index) => item.id || index
}) => {
  const scrollTop = signal(0);
  const containerRef = signal(null);
  
  const visibleRange = computed(() => {
    const start = Math.floor(scrollTop() / itemHeight);
    const visibleCount = Math.ceil(containerHeight / itemHeight);
    const end = Math.min(start + visibleCount + 1, items().length);
    
    return { start: Math.max(0, start - 1), end };
  });
  
  const visibleItems = computed(() => {
    const range = visibleRange();
    return items().slice(range.start, range.end).map((item, index) => ({
      item,
      index: range.start + index,
      key: keyExtractor(item, range.start + index)
    }));
  });
  
  const totalHeight = computed(() => items().length * itemHeight);
  const offsetY = computed(() => visibleRange().start * itemHeight);
  
  const handleScroll = (e) => {
    scrollTop(e.target.scrollTop);
  };
  
  return (
    <div 
      ref={containerRef}
      class="virtual-list"
      style={`height: ${containerHeight}px; overflow-y: auto;`}
      onscroll={handleScroll}
    >
      <div style={`height: ${totalHeight}px; position: relative;`}>
        <div 
          style={`transform: translateY(${offsetY}px);`}
        >
          {() => visibleItems().map(({ item, index, key }) => (
            <div 
              key={key}
              style={`height: ${itemHeight}px;`}
              class="virtual-list-item"
            >
              {renderItem(item, index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

// Grouped list with headers
const GroupedList = ({ items, groupBy, renderItem, renderGroupHeader }) => {
  const groupedItems = computed(() => {
    const groups = new Map();
    
    items().forEach(item => {
      const groupKey = groupBy(item);
      if (!groups.has(groupKey)) {
        groups.set(groupKey, []);
      }
      groups.get(groupKey).push(item);
    });
    
    return Array.from(groups.entries()).map(([groupKey, groupItems]) => ({
      key: groupKey,
      items: groupItems
    }));
  });
  
  return (
    <div class="grouped-list">
      {() => groupedItems().map(group => (
        <div key={group.key} class="list-group">
          <div class="group-header">
            {renderGroupHeader(group.key, group.items)}
          </div>
          <div class="group-items">
            {group.items.map((item, index) => (
              <div key={item.id || index} class="group-item">
                {renderItem(item, index)}
              </div>
            ))}
          </div>
        </div>
      ))}
    </div>
  );
};

// Usage examples
const TodoList = () => {
  const todos = signal([]);
  
  return (
    <GroupedList
      items={todos}
      groupBy={(todo) => todo.completed ? 'Completed' : 'Active'}
      renderGroupHeader={(groupKey, items) => (
        <h3>{groupKey} ({items.length})</h3>
      )}
      renderItem={(todo) => (
        <TodoItem todo={todo} />
      )}
    />
  );
};
```

## Form Patterns

### 1. Form State Management

Handle complex form state with validation:

```jsx
// useForm - Custom hook for form management
const useForm = ({ initialValues, validationSchema, onSubmit }) => {
  const values = signal(initialValues);
  const errors = signal({});
  const touched = signal({});
  const isSubmitting = signal(false);
  
  const setValue = (field, value) => {
    values({ ...values(), [field]: value });
    
    // Clear error when user starts typing
    if (errors()[field]) {
      errors({ ...errors(), [field]: null });
    }
  };
  
  const setTouched = (field) => {
    touched({ ...touched(), [field]: true });
  };
  
  const validate = () => {
    if (!validationSchema) return true;
    
    const validationErrors = {};
    const currentValues = values();
    
    Object.keys(validationSchema).forEach(field => {
      const fieldValue = currentValues[field];
      const fieldRules = validationSchema[field];
      
      for (const rule of fieldRules) {
        const error = rule(fieldValue, currentValues);
        if (error) {
          validationErrors[field] = error;
          break;
        }
      }
    });
    
    errors(validationErrors);
    return Object.keys(validationErrors).length === 0;
  };
  
  const handleSubmit = async (e) => {
    e?.preventDefault();
    
    // Mark all fields as touched
    const allTouched = Object.keys(initialValues).reduce(
      (acc, field) => ({ ...acc, [field]: true }), 
      {}
    );
    touched(allTouched);
    
    if (!validate()) {
      return;
    }
    
    isSubmitting(true);
    
    try {
      await onSubmit(values());
    } catch (error) {
      console.error('Form submission error:', error);
    } finally {
      isSubmitting(false);
    }
  };
  
  const reset = () => {
    values(initialValues);
    errors({});
    touched({});
    isSubmitting(false);
  };
  
  return {
    values,
    errors,
    touched,
    isSubmitting,
    setValue,
    setTouched,
    handleSubmit,
    reset,
    isValid: computed(() => Object.keys(errors()).length === 0)
  };
};

// Validation rules
const required = (message = 'This field is required') => (value) => {
  return !value || value.toString().trim() === '' ? message : null;
};

const email = (message = 'Invalid email address') => (value) => {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return value && !emailRegex.test(value) ? message : null;
};

const minLength = (min, message) => (value) => {
  return value && value.length < min ? message || `Minimum ${min} characters` : null;
};

// Form component using the hook
const UserRegistrationForm = ({ onSuccess }) => {
  const form = useForm({
    initialValues: {
      firstName: '',
      lastName: '',
      email: '',
      password: '',
      confirmPassword: ''
    },
    validationSchema: {
      firstName: [required()],
      lastName: [required()],
      email: [required(), email()],
      password: [required(), minLength(8, 'Password must be at least 8 characters')],
      confirmPassword: [
        required(),
        (value, values) => 
          value !== values.password ? 'Passwords do not match' : null
      ]
    },
    onSubmit: async (values) => {
      const response = await registerUser(values);
      onSuccess(response);
      form.reset();
    }
  });
  
  const getFieldProps = (field) => ({
    value: () => form.values()[field] || '',
    oninput: (e) => form.setValue(field, e.target.value),
    onblur: () => form.setTouched(field),
    class: () => {
      const hasError = form.touched()[field] && form.errors()[field];
      return `form-input ${hasError ? 'form-input--error' : ''}`;
    }
  });
  
  return (
    <form onsubmit={form.handleSubmit} class="registration-form">
      <div class="form-row">
        <FormField
          label="First Name"
          error={() => form.touched().firstName && form.errors().firstName}
        >
          <input 
            type="text"
            placeholder="Enter first name"
            {...getFieldProps('firstName')}
          />
        </FormField>
        
        <FormField
          label="Last Name"
          error={() => form.touched().lastName && form.errors().lastName}
        >
          <input 
            type="text"
            placeholder="Enter last name"
            {...getFieldProps('lastName')}
          />
        </FormField>
      </div>
      
      <FormField
        label="Email"
        error={() => form.touched().email && form.errors().email}
      >
        <input 
          type="email"
          placeholder="Enter email address"
          {...getFieldProps('email')}
        />
      </FormField>
      
      <FormField
        label="Password"
        error={() => form.touched().password && form.errors().password}
      >
        <input 
          type="password"
          placeholder="Enter password"
          {...getFieldProps('password')}
        />
      </FormField>
      
      <FormField
        label="Confirm Password"
        error={() => form.touched().confirmPassword && form.errors().confirmPassword}
      >
        <input 
          type="password"
          placeholder="Confirm password"
          {...getFieldProps('confirmPassword')}
        />
      </FormField>
      
      <div class="form-actions">
        <button 
          type="submit"
          disabled={() => !form.isValid() || form.isSubmitting()}
          class="btn btn--primary"
        >
          {() => form.isSubmitting() ? 'Creating Account...' : 'Create Account'}
        </button>
      </div>
    </form>
  );
};

// Reusable form field component
const FormField = ({ label, error, children, required = false }) => {
  return (
    <div class="form-field">
      <label class="form-label">
        {label}
        {required && <span class="required">*</span>}
      </label>
      {children}
      {() => error() && (
        <div class="form-error">{error()}</div>
      )}
    </div>
  );
};
```

## Performance Patterns

### 1. Memoization Patterns

Optimize expensive computations:

```jsx
// Memoized computation helper
const memoize = (fn, keyFn = (...args) => JSON.stringify(args)) => {
  const cache = new Map();
  
  return (...args) => {
    const key = keyFn(...args);
    
    if (cache.has(key)) {
      return cache.get(key);
    }
    
    const result = fn(...args);
    cache.set(key, result);
    
    // Limit cache size
    if (cache.size > 100) {
      const firstKey = cache.keys().next().value;
      cache.delete(firstKey);
    }
    
    return result;
  };
};

// Expensive filtering and sorting
const useFilteredProducts = (products, filters) => {
  const memoizedFilter = memoize(
    (productList, filterObject) => {
      return productList
        .filter(product => {
          if (filterObject.category && product.category !== filterObject.category) {
            return false;
          }
          if (filterObject.minPrice && product.price < filterObject.minPrice) {
            return false;
          }
          if (filterObject.maxPrice && product.price > filterObject.maxPrice) {
            return false;
          }
          if (filterObject.search) {
            const searchLower = filterObject.search.toLowerCase();
            return (
              product.name.toLowerCase().includes(searchLower) ||
              product.description.toLowerCase().includes(searchLower)
            );
          }
          return true;
        })
        .sort((a, b) => {
          switch (filterObject.sortBy) {
            case 'price_asc':
              return a.price - b.price;
            case 'price_desc':
              return b.price - a.price;
            case 'name':
              return a.name.localeCompare(b.name);
            default:
              return 0;
          }
        });
    },
    (productList, filterObject) => 
      `${productList.length}-${JSON.stringify(filterObject)}`
  );
  
  return computed(() => memoizedFilter(products(), filters()));
};
```

## Next Steps

You've learned the essential component patterns for HellaJS. Next, explore:

- [State Patterns](/guides/patterns/state-patterns) - Advanced state management
- [Async Patterns](/guides/patterns/async-patterns) - Data fetching strategies
- [Performance Optimization](/guides/performance/optimization) - Application performance

## Troubleshooting

### Common Pattern Issues

**‚ùå Over-abstraction**
- Don't create patterns until you need them
- Start simple, refactor when you see repetition

**‚ùå Props drilling**
- Use context/providers for deeply nested data
- Consider state management libraries for complex apps

**‚ùå Performance overhead**
- Memoize expensive computations, not simple ones
- Profile before optimizing

### Pattern Selection Guide

- **Simple apps**: Use basic composition and local state
- **Medium apps**: Add custom hooks and container/presentational patterns
- **Complex apps**: Implement providers, observers, and advanced patterns

## Related Guides

- [State Patterns](/guides/patterns/state-patterns) - Advanced state management strategies
- [Best Practices](/guides/getting-started/best-practices) - Code quality guidelines
- [Performance Optimization](/guides/performance/optimization) - Application performance