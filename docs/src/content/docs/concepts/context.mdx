---
title: Context
description: Working with context using closure functions and component patterns.
---

import { Tabs, TabItem, Aside } from '@astrojs/starlight/components';

<Aside type="note" title="Note">
  Due to the rendering approach, context is different from other frameworks.
  
  Use closure functions to share state between components.
</Aside>

<Tabs>
  <TabItem label="JSX">

```jsx
import { signal } from '@hellajs/core';
import { html, slot, forEach } from '@hellajs/dom';

function Counter() {
  const count = signal(0);
  
  const Provider = ({ children, ...props }) => <div {...props}>{children}</div>;

  const Button = ({ children, ...props }) => (
    <button {...props} onClick={() => count(count() + 1)}>
      {children}
    </button>
  );

  const Display = ({ children, ...props }) => (
    <span {...props}>{() => `Count: ${count()}`}</span>
  );

  return { Provider, Button, Display, count };
}

// Usage
const counter = createCounter();
const { Provider, Button, Display } = counter;

return (
  <Provider class="counter-app">
    <Button class="increment-btn">Increment</Button>
    <Display class="count-display" />
  </Provider>
);
```

  </TabItem>
  <TabItem label="Template Literals">

```js
import { signal } from '@hellajs/core';
import { html, slot, forEach } from '@hellajs/dom';

function createCounter() {
  const count = signal(0);
  
  // Template literal components use slot to parse arguments
  const Provider = (...args) => {
    const { props, children } = slot(args);
    return html`<div class="${props.class || ''}">${forEach(children, child => child)}</div>`;
  };

  const Button = (...args) => {
    const { props, children } = slot(args);
    return html`<button class="${props.class || ''}" onclick="${() => count(count() + 1)}">${forEach(children, child => child)}</button>`;
  };

  const Display = (...args) => {
    const { props, children } = slot(args);
    return html`<span class="${props.class || ''}">${() => `Count: ${count()}`}</span>`;
  };

  return { Provider, Button, Display, count };
}

// Usage
const counter = createCounter();
const { Provider, Button, Display } = counter;

return Provider(
  { class: 'counter-app' },
  Button({ class: 'increment-btn' }, 'Increment'),
  Display({ class: 'count-display' })
);
```

  </TabItem>
</Tabs>

## Key Differences

### JSX Pattern
- Components are functions that receive `props` and `children` separately
- Props come from JSX attributes: `<Component foo="bar">`
- Children come from JSX content: `<Component>child</Component>`
- Babel automatically transforms JSX to function calls with proper arguments

### Template Literal Pattern
- Components use `(...args)` and `slot()` to parse props and children
- Props and children are passed as function arguments
- First argument (if object) becomes props, rest become children
- Use `forEach()` to render multiple children properly

## Context Sharing

Both patterns use the same closure-based approach to share state:

1. **Create a factory function** that contains shared state
2. **Return component functions** that close over the shared state  
3. **Components access shared state** directly from the closure
4. **No prop drilling** - state is shared through closures, not props