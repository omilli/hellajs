---
title: effect
description: Automatically runs side effects when reactive dependencies change.
layout: ../../../layouts/MainLayout.astro
---

# effect

Automatically runs side effects when reactive dependencies change.

## API

```typescript
function effect(fn: () => void): () => void
```
- `fn`: The function to run as a side effect. It will be re-executed whenever a signal read inside it changes.
- **Returns**: A `cleanup` function that can be called to stop the effect and prevent further executions.

## TypeScript

The `effect` function takes a function returning `void` and returns a cleanup function.

```typescript
type EffectFunction = () => void;
type CleanupFunction = () => void;

const cleanup: CleanupFunction = effect(() => {
  // ... side effects
});

// Later...
cleanup();
```

## Basic Usage

An effect runs immediately upon creation and then again whenever any of its dependencies change. It's crucial to call the returned `cleanup` function to stop the effect when it's no longer needed, for example, when a component unmounts.

```typescript
import { signal, effect } from '@hellajs/core';

const count = signal(0);

// This effect runs immediately, then whenever `count` changes.
const cleanup = effect(() => {
  console.log(`The count is: ${count()}`);
});

count(1); // Logs: "The count is: 1"
count(2); // Logs: "The count is: 2"

// Stop the effect. Future changes to `count` will not be logged.
cleanup();
count(3); // (nothing is logged)
```

## Key Concepts

**Eager Execution**: Unlike computed values that run lazily, effects execute immediately when dependencies change, making them perfect for side effects like DOM updates and API calls.

```typescript
const data = signal('initial');
effect(() => {
  console.log('Effect runs immediately:', data());
}); // Logs immediately
data('updated'); // Effect runs again immediately
```

**Dependency Tracking**: Effects automatically track all signals read during execution, creating dynamic dependency graphs that adapt to conditional logic.

```typescript
const showData = signal(true);
const data = signal('value');
effect(() => {
  if (showData()) {
    console.log(data()); // Only tracks 'data' when showData is true
  }
});
```

**Cleanup Functions**: Return cleanup functions from effects to manage resources, cancel operations, and prevent memory leaks when dependencies change.

```typescript
effect(() => {
  const interval = setInterval(() => console.log('tick'), 1000);
  return () => clearInterval(interval); // Cleanup runs before next effect
});
```

**Async Effect Patterns**: Handle asynchronous operations safely by implementing cancellation tokens and proper cleanup to avoid race conditions.

```typescript
effect(() => {
  let cancelled = false;
  fetch('/api/data').then(result => {
    if (!cancelled) updateData(result);
  });
  return () => { cancelled = true; };
});
```


## Important Considerations

**Async Functions**: Do not pass an `async` function directly to `effect`. The cleanup logic relies on the synchronous return of a cleanup function.

```typescript
// ❌ Async function directly
effect(async () => { /* ... */ });
// ✅ Handle async operations inside
effect(() => {
  fetch('/api/data').then(data => result(data));
});
```

**Infinite Loops**: Avoid writing to signals that the effect reads from, as this creates infinite loops.

```typescript
// ❌ Effect triggers itself
effect(() => {
  count(count() + 1);
});
// ✅ Use untracked for non-reactive reads
effect(() => {
  const current = untracked(() => count());
  console.log(`Count: ${current}`);
});
```

**Cleanup Management**: Always call the returned cleanup function to prevent memory leaks and unwanted side effects.

```typescript
// ✅ Proper cleanup
const cleanup = effect(() => {
  // side effect logic
});
// Later when component unmounts
cleanup();
```


## Use Cases

### DOM Updates
Effects are the primary way to bridge the reactive world with the DOM.

```typescript
const name = signal("World");
const titleElement = document.getElementById('title');

effect(() => {
  titleElement.textContent = `Hello, ${name()}`;
});
```

### Data Fetching
Trigger API calls automatically when a dependency like a user ID changes.

```typescript
const userId = signal(1);
const userData = signal(null);

effect(() => {
  const id = userId();
  if (!id) return;

  let isCancelled = false;
  
  fetch(`/api/users/${id}`)
    .then(res => res.json())
    .then(data => {
      if (!isCancelled) userData(data);
    });

  // The cleanup function runs before the next effect execution,
  // preventing race conditions if `userId` changes quickly.
  return () => {
    isCancelled = true;
  };
});
```

### Event Listeners
Effects can manage event listeners, automatically adding and removing them.

```typescript
effect(() => {
  const handleScroll = () => console.log(window.scrollY);
  window.addEventListener('scroll', handleScroll);

  // The cleanup function removes the listener when the effect stops.
  return () => window.removeEventListener('scroll', handleScroll);
});
```
