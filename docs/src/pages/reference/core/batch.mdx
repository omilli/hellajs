---
title: batch
description: Groups multiple signal updates to trigger effects only once.
layout: ../../../layouts/MainLayout.astro
---

# batch

Groups multiple signal updates to trigger effects only once.

## API

```typescript
function batch<T>(fn: () => T): T
```

- `fn`: A function that contains the signal updates to be batched.
- **Returns**: The value returned by the function `fn`.

## TypeScript

The `batch` function is generic and preserves the return type of the function it wraps.

```typescript
type BatchFunction<T> = () => T;

const result: string = batch(() => {
  // ... signal updates
  return "done";
});
```

## Basic Usage

Without `batch`, each signal update triggers its own effect run. With `batch`, all updates are grouped, and effects run only once.

```typescript
import { signal, batch, effect } from '@hellajs/core';

const firstName = signal("John");
const lastName = signal("Doe");
let updateCount = 0;

effect(() => {
  console.log(`${firstName()} ${lastName()}`);
  updateCount++;
});
// Initial run: logs "John Doe", updateCount is 1

// Without batching: 2 separate effect runs
firstName("Jane");   // Logs "Jane Doe"
lastName("Smith"); // Logs "Jane Smith"
console.log(updateCount); // 3

// With batching: 1 effect run for both updates
batch(() => {
  firstName("Alice");
  lastName("Johnson");
}); // Logs "Alice Johnson"
console.log(updateCount); // 4 (only 1 additional update)
```

## Key Concepts

**Update Deferral**: Batch defers all reactive updates until the batch function completes, preventing intermediate state inconsistencies and reducing unnecessary computations.

**Synchronous Boundaries**: Batching only applies to synchronous signal updates within the batch function - async operations break batch boundaries.

**Performance Optimization**: Reduces the number of effect executions and DOM updates when multiple related signals change simultaneously.

**Nested Batch Behavior**: Nested batches are flattened - effects only run once the outermost batch completes, regardless of nesting depth.

## Important Considerations

**Async Operations**: Batching only applies to synchronous signal updates within the batch function. Asynchronous operations will not be batched with the initial updates.

**Nested Batching**: Batches can be nested, but effects will not run until the outermost batch has completed, providing predictable update timing.

**Performance Impact**: While batching improves performance by reducing effect runs, the batch function itself adds minimal overhead.

## Use Cases

### Form Updates
Batching is ideal for applying multiple changes to a form's state, preventing repeated validation or re-rendering.

```typescript
const formData = {
  email: signal(''),
  name: signal(''),
};

effect(() => {
  // This validation logic runs only once per batch
  console.log('Validating:', formData.name(), formData.email());
});

const loadUserData = (userData) => {
  batch(() => {
    formData.email(userData.email);
    formData.name(userData.name);
  });
};

loadUserData({ email: "user@example.com", name: "John Doe" });
```

### State Initialization
Use `batch` to initialize or update complex state objects without causing a cascade of intermediate updates.

```typescript
const appState = {
  user: signal(null),
  isLoading: signal(false),
  error: signal(null),
};

const login = async (credentials) => {
  batch(() => {
    appState.isLoading(true);
    appState.error(null);
  });

  try {
    const userData = await api.login(credentials);
    batch(() => {
      appState.user(userData);
      appState.isLoading(false);
    });
  } catch (error) {
    batch(() => {
      appState.error(error.message);
      appState.isLoading(false);
    });
  }
};
```

### Nested Batch Example
Handle complex state updates with multiple levels of batching:

```typescript
const counters = { a: signal(0), b: signal(0) };
let effectRuns = 0;

effect(() => {
  counters.a(); counters.b();
  effectRuns++;
}); // effectRuns is 1

batch(() => {
  counters.a(1);
  batch(() => {
    counters.b(2);
  });
  counters.a(10);
});

console.log(effectRuns); // 2 (only one additional run)
```

### Async Operation Handling
Properly handle asynchronous operations with separate batch calls:

```typescript
// âœ… Correct: Batch synchronous parts separately
batch(() => {
  signal1('value1');
  loadingState(true);
});

try {
  const result = await someAsyncOperation();
  batch(() => {
    signal2(result);
    loadingState(false);
  });
} catch (error) {
  batch(() => {
    errorState(error.message);
    loadingState(false);
  });
}
```
