---
title: forEach
description: Efficiently renders dynamic lists with intelligent DOM diffing and key-based optimization.
layout: ../../../layouts/MainLayout.astro
---

# foreach

Efficiently renders dynamic lists with intelligent DOM diffing and key-based optimization.

## API

```typescript
function forEach<T>(
  each: T[] | Signal<T[]> | (() => T[]),
  use: (item: T, index: number) => VNodeValue
): (parent: HellaElement) => void
```
- `each`: The data to iterate over. Can be a static array, a signal containing an array, or a function that returns an array.
- `use`: A function that is called for each item in the array and should return a renderable VNode.
- **Returns**: A function that HellaJS uses internally to append the list to a parent element.

## TypeScript

The `forEach` function is generic. The type of `item` in the render function is inferred from the array type.

```typescript
import { signal } from '@hellajs/core';
import { forEach, type VNodeValue } from '@hellajs/dom';

type User = { id: number; name: string };
const users = signal<User[]>([{ id: 1, name: 'Alice' }]);

// `item` is automatically typed as `User`
<ul>
  {forEach(users, (item) =>
    <li key={item.id}>{item.name}</li>
  )}
</ul>
```

## Basic Usage

Provide `forEach` with an array and a render function. It's designed to be used within JSX as a child element.

```jsx
import { signal } from '@hellajs/core';
import { forEach } from '@hellajs/dom';

const items = signal(['Apple', 'Banana', 'Cherry']);

<ul>
  {forEach(items, (fruit, index) =>
    <li key={index}>{fruit}</li>
  )}
</ul>
```

## Key Concepts

**Key-Based Optimization**: HellaJS automatically uses `key` or `id` properties from data items to efficiently track and update DOM nodes during list changes.

**Reactive Arrays**: When using signals, the entire array must be replaced (not mutated) to trigger reactivity and DOM updates.

**DOM Diffing**: Intelligent diffing algorithm minimizes DOM operations by reusing existing elements where possible.

## Important Considerations

- **Array Immutability**: Always create new array instances for signal updates - mutations don't trigger reactivity
- **Key Stability**: Use stable, unique keys (like database IDs) rather than array indices for optimal performance
- **Performance**: Large lists may benefit from virtualization - `forEach` renders all items in the DOM
- **Memory**: Event listeners and effects in list items should be properly cleaned up to prevent memory leaks
- **Batching**: Use `batch()` for multiple array operations to minimize DOM updates

**Correct Array Updates**:
```jsx
// ✅ Correct: Create new array
todos([...todos(), newItem]);
todos(todos().filter(item => item.id !== id));

// ❌ Incorrect: Mutation doesn't trigger updates
todos().push(newItem);
```

## Use Cases

**Dynamic Lists with Actions**: Render lists where items can be added, removed, or modified:

```jsx
const TodoList = () => {
  const todos = signal([]);
  const addTodo = (text) => todos([...todos(), { id: Date.now(), text, done: false }]);
  const removeTodo = (id) => todos(todos().filter(t => t.id !== id));
  
  return (
    <div>
      <AddTodoForm onAdd={addTodo} />
      <ul>
        {forEach(todos, (todo) => (
          <li key={todo.id}>
            <span class={todo.done ? 'completed' : ''}>{todo.text}</span>
            <button onClick={() => removeTodo(todo.id)}>Remove</button>
          </li>
        ))}
      </ul>
    </div>
  );
};
```

**Data Tables with Sorting**: Display tabular data with interactive sorting and filtering:

```jsx
const DataTable = () => {
  const data = signal([]);
  const sortBy = signal('name');
  const sortedData = computed(() => 
    [...data()].sort((a, b) => a[sortBy()].localeCompare(b[sortBy()]))
  );
  
  return (
    <table>
      <thead>
        <tr>
          <th onClick={() => sortBy('name')}>Name</th>
          <th onClick={() => sortBy('date')}>Date</th>
        </tr>
      </thead>
      <tbody>
        {forEach(sortedData, (row) => (
          <tr key={row.id}>
            <td>{row.name}</td>
            <td>{row.date}</td>
          </tr>
        ))}
      </tbody>
    </table>
  );
};
```

**Real-time Data Visualization**: Render live-updating charts and graphs:

```jsx
const LiveChart = () => {
  const dataPoints = signal([]);
  
  // Add new data points from WebSocket
  effect(() => {
    const ws = new WebSocket('ws://api.example.com/live-data');
    ws.onmessage = (event) => {
      const point = JSON.parse(event.data);
      dataPoints([...dataPoints().slice(-100), point]); // Keep last 100 points
    };
  });
  
  return (
    <svg>
      {forEach(dataPoints, (point, index) => (
        <circle key={index} cx={point.x} cy={point.y} r="2" />
      ))}
    </svg>
  );
};
```

**Infinite Scroll Lists**: Handle large datasets with virtual scrolling:

```jsx
const InfiniteList = () => {
  const items = signal([]);
  const loading = signal(false);
  
  const loadMore = async () => {
    loading(true);
    const newItems = await fetchNextPage();
    items([...items(), ...newItems]);
    loading(false);
  };
  
  return (
    <div onScroll={(e) => handleScroll(e, loadMore)}>
      {forEach(items, (item) => (
        <div key={item.id} class="list-item">{item.title}</div>
      ))}
      {loading() && <div class="loading">Loading more...</div>}
    </div>
  );
};
```
