---
title: store
description: A deeply reactive store for managing application state with full type safety and flexible readonly controls.
layout: ../../../layouts/MainLayout.astro
---

# store

A deeply reactive store for managing application state with full type safety and flexible readonly controls.

## API

```typescript
function store<T>(initial: T, options?: StoreOptions<T>): Store<T>

interface Store<T> {
  // Properties from T are converted to signals or nested stores
  [K in keyof T]: // ...

  // Methods
  computed(): T;
  // Replace the entire state by calling the store with a new object: `store(newState)`
  update(partial: PartialDeep<T>): void;
  cleanup(): void;
}

interface StoreOptions<T> {
  readonly?: boolean | readonly (keyof T)[];
}
```

## TypeScript

The `store` function is fully type-safe, preserving your initial object's structure and providing type inference for all properties and methods.

```typescript
import { store } from '@hellajs/store';

interface User {
  name: string;
  age: number;
  settings: { theme: 'dark' | 'light' };
}

const userStore = store<User>({
  name: 'John Doe',
  age: 30,
  settings: { theme: 'dark' },
});

// userStore.name is Signal<string>
// userStore.settings.theme is Signal<'dark' | 'light'>
```

## Basic Usage

Create a store by passing a plain JavaScript object. Access properties as signal functions to read their values, and call them with a new value to update.

```typescript
import { store } from '@hellajs/store';
import { effect } from '@hellajs/core';

const user = store({
  name: 'John Doe',
  address: {
    city: 'New York',
  },
});

effect(() => {
  console.log(`${user.name()} lives in ${user.address.city()}`);
});
// Logs: "John Doe lives in New York"

// Update a top-level property
user.name('Jane Doe');
// Logs: "Jane Doe lives in New York"

// Update a nested property
user.address.city('San Francisco');
// Logs: "Jane Doe lives in San Francisco"
```

## Key Concepts

**Deep Reactivity**: All nested objects and arrays are automatically converted to reactive stores, creating a fully reactive state tree.

```typescript
const userStore = store({
  profile: { name: 'John', age: 30 },
  settings: { theme: 'dark' }
});

// All nested properties are reactive
effect(() => {
  console.log(userStore.profile.name()); // Reactive to name changes
  console.log(userStore.settings.theme()); // Reactive to theme changes
});
```

**Signal Properties**: Each store property becomes a signal that can be read and written using function call syntax.

```typescript
const appStore = store({ count: 0, user: { name: 'Alice' } });

// Read values (getter syntax)
console.log(appStore.count()); // 0
console.log(appStore.user.name()); // 'Alice'

// Write values (setter syntax)
appStore.count(5);
appStore.user.name('Bob');
```

**Flexible Updates**: Choose between complete state replacement or partial deep updates using the `update()` method.

```typescript
const store = store({ user: { name: 'John', age: 30 }, ui: { theme: 'light' } });

// Partial update - only changes specified properties
store.update({ user: { name: 'Jane' } }); // age remains 30

// Complete replacement - replaces entire state
store({ user: { name: 'Alice', age: 25 }, ui: { theme: 'dark' } });
```

**Readonly Control**: Granular control over which properties can be modified, with full TypeScript support.

```typescript
const configStore = store(
  { apiUrl: 'https://api.com', theme: 'light', debug: false },
  { readonly: ['apiUrl'] } // apiUrl cannot be modified
);

configStore.theme('dark'); // ✅ Works
configStore.apiUrl('new-url'); // ❌ TypeScript error + runtime error
```

## Important Considerations

**Performance**: Large stores create many signals - consider splitting into smaller, focused stores for better performance.

```typescript
// ❌ Monolithic store
const appStore = store({ user: {...}, ui: {...}, data: {...} });
// ✅ Split into specialized stores
const userStore = store({ name: '', email: '' });
const uiStore = store({ theme: 'light', sidebar: false });
```

**Memory Management**: Call `cleanup()` when stores are no longer needed to prevent memory leaks.

```typescript
// ✅ Clean up when done
const userStore = store({ name: 'John' });
// Later...
userStore.cleanup();
```

**Nested Updates**: Always use the `update()` method for partial changes to avoid replacing entire nested objects.

```typescript
// ✅ Efficient partial update
store.update({ settings: { theme: 'dark' } });
// ❌ Replaces entire nested object
store.settings({ theme: 'dark', other: undefined });
```

## Use Cases

**Application State Management**: Centralize global application state with reactive updates:

```typescript
const appStore = store({
  user: { id: null, name: '', isAuthenticated: false },
  ui: { theme: 'light', sidebar: false, modal: null },
  data: { posts: [], comments: [], loading: false }
});

// Components automatically re-render when relevant state changes
const Header = () => (
  <header class={appStore.ui.theme() === 'dark' ? 'dark' : 'light'}>
    {appStore.user.isAuthenticated() ? appStore.user.name() : 'Guest'}
  </header>
);
```

**Form State with Validation**: Manage complex form state with real-time validation:

```typescript
const formStore = store({
  fields: {
    email: '',
    password: '',
    confirmPassword: ''
  },
  errors: {},
  isSubmitting: false
});

// Real-time validation
effect(() => {
  const { email, password, confirmPassword } = formStore.fields;
  formStore.errors.update({
    email: email().includes('@') ? '' : 'Invalid email',
    password: password().length >= 8 ? '' : 'Password too short',
    confirmPassword: password() === confirmPassword() ? '' : 'Passwords don\'t match'
  });
});
```

**Shopping Cart Management**: Handle e-commerce cart state with item calculations:

```typescript
const cartStore = store({
  items: [],
  discounts: { code: '', amount: 0 },
  shipping: { method: 'standard', cost: 0 }
});

const cartTotal = computed(() => {
  const itemsTotal = cartStore.items().reduce((sum, item) => sum + item.price * item.quantity, 0);
  return itemsTotal - cartStore.discounts.amount() + cartStore.shipping.cost();
});

const addToCart = (product) => {
  const existingItem = cartStore.items().find(item => item.id === product.id);
  if (existingItem) {
    existingItem.quantity(existingItem.quantity() + 1);
  } else {
    cartStore.items([...cartStore.items(), { ...product, quantity: 1 }]);
  }
};
```

**Real-time Collaboration State**: Manage collaborative application state with WebSocket integration:

```typescript
const collaborationStore = store({
  document: { title: '', content: '', lastModified: null },
  users: [],
  cursors: {},
  comments: []
});

// Sync with WebSocket
effect(() => {
  const ws = new WebSocket('ws://api.example.com/collaborate');
  ws.onmessage = (event) => {
    const update = JSON.parse(event.data);
    collaborationStore.update(update);
  };
  
  return () => ws.close();
});
```