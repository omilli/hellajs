---
layout: ../../../layouts/MainLayout.astro
title: Styling
description: Flexible styling with CSS-in-JS support, automatic scoping and static CSS object creation.
---

import { Icon } from "astro-icon/components";

# Flexible Styling

HellaJS supports both traditional CSS classes and CSS-in-JS styling approaches. Use regular CSS classes for existing stylesheets or CSS-in-JS for automatically scoped styles. Achieve dynamic styling through reactive class name bindings that respond to state changes.

## Traditional CSS Classes

Apply CSS classes to elements using the `class` attribute, with full support for reactive class names and arrays using [signal](/reference/core/signal) bindings.

### Static Classes

Use regular CSS classes with external stylesheets.

```jsx
const SimpleCounter = () => {
  const count = signal(0);
  
  return (
    <div class="counter-container">
      <h1 class="counter-display">{count}</h1>
      <button class="btn btn-primary" onClick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

### Reactive Classes

Make CSS classes reactive using arrow functions.

```jsx
const Counter = () => {
  const count = signal(0);
  
  return (
    <div class="counter-container">
      <h1 class={`counter-display ${count() % 2 === 0 ? 'even' : 'odd'}`}>
        {count}
      </h1>
      <button 
        class={`btn ${count() > 5 ? 'btn-success' : 'btn-primary'}`}
        onClick={() => count(count() + 1)}
      >
        {count() > 5 ? 'Great job!' : 'Increment'}
      </button>
    </div>
  );
};
```

### Class Arrays

Use arrays for conditional classes.

```jsx
const TodoItem = ({ todo }) => {
  return (
    <div class={[
      'todo-item',
      todo().done && 'completed',
      todo().priority === 'high' && 'priority-high',
      todo().editing && 'editing'
    ]}>
      {todo().text}
    </div>
  );
};
```

## CSS-in-JS

HellaJS provides a [css](/reference/css/css) function for creating scoped styles with JavaScript objects. While the CSS objects themselves are static, you can achieve dynamic styling by reactively choosing which CSS classes to apply.

### Basic CSS Objects

Create styles using JavaScript objects with [css](/reference/css/css) properties:

```jsx
const Counter = () => {
  const count = signal(0);
  
  const buttonStyle = css({
    padding: '0.75rem 1.5rem',
    border: 'none',
    borderRadius: '0.5rem',
    background: '#3b82f6',
    color: 'white',
    fontWeight: '600',
    cursor: 'pointer',
    transition: 'all 0.2s ease',
    
    '&:hover': {
      background: '#2563eb',
      transform: 'translateY(-1px)'
    }
  });
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <button class={buttonStyle} onClick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

### Dynamic Styling with Multiple Classes

Create different static CSS objects and choose between them reactively using class name bindings.

```jsx
const Counter = () => {
  const count = signal(0);
  
  const evenStyle = css({
    padding: '2rem',
    borderRadius: '0.75rem',
    background: '#ecfdf5',
    border: '2px solid #d97706',
    transform: 'scale(1)',
    transition: 'all 0.3s ease'
  });
  
  const oddStyle = css({
    padding: '2rem',
    borderRadius: '0.75rem',
    background: '#fef3c7',
    border: '2px solid #059669',
    transform: 'scale(1.05)',
    transition: 'all 0.3s ease'
  });
  
  return (
    <div class={() => count() % 2 === 0 ? evenStyle : oddStyle}>
      <h1>Count: {count}</h1>
      <button onClick={() => count(count() + 1)}>Increment</button>
    </div>
  );
};
```

### Style Composition

Create multiple CSS objects for different states and combine them with traditional CSS classes or conditional logic.

```jsx
const TodoApp = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', done: false },
    { id: 2, text: 'Build an app', done: true }
  ]);
  
  const baseItemStyle = css({
    padding: '1rem',
    margin: '0.5rem 0',
    borderRadius: '0.5rem',
    border: '1px solid #e5e7eb',
    background: 'white',
    transition: 'all 0.3s ease'
  });
  
  const completedItemStyle = css({
    padding: '1rem',
    margin: '0.5rem 0',
    borderRadius: '0.5rem',
    border: '1px solid #10b981',
    background: '#f0fdf4',
    opacity: 0.6,
    textDecoration: 'line-through',
    transition: 'all 0.3s ease'
  });
  
  const toggleTodo = (id) => {
    todos(todos().map(t => 
      t.id === id ? { ...t, done: !t.done } : t
    ));
  };
  
  return (
    <div>
      <h1>Todo List</h1>
      {forEach(todos, todo => (
        <div key={todo.id} class={todo.done ? completedItemStyle : baseItemStyle}>
          <input 
            type="checkbox" 
            checked={todo.done}
            onChange={() => toggleTodo(todo.id)}
          />
          <span>{todo.text}</span>
        </div>
      ))}
    </div>
  );
};
```

### Style Scoping

HellaJS provides three scoping mechanisms to handle different styling scenarios.

#### Automatic Scoping (Default)
Every CSS object receives a unique class name based on its content hash, ensuring isolation without additional configuration.

#### Manual Scoping
You can add an additional scope prefix for extra organization, useful when building component libraries or complex applications.

#### Global Scoping
Styles are applied globally without any scoping, useful for base styles, resets, or library-wide utilities.

```jsx
const ScopingExamples = () => {
  const isActive = signal(false);
  
  // Automatic scoping - generates unique class like 'c1a2b3c'
  const autoScopedButton = css({
    padding: '0.5rem 1rem',
    border: 'none',
    borderRadius: '0.25rem',
    background: '#f3f4f6',
    cursor: 'pointer'
  });
  
  // Manual scoping - applies styles within .my-component scope
  const manuallyScopedStyles = css({
    '.button': {
      padding: '0.5rem 1rem',
      border: 'none',
      borderRadius: '0.25rem'
    },
    '.button.active': {
      background: '#059669',
      color: 'white'
    }
  }, { scoped: 'my-component' });
  
  // Global scoping - applies styles globally (no class name returned)
  css({
    '*': {
      boxSizing: 'border-box'
    },
    'body': {
      margin: 0,
      fontFamily: 'system-ui, sans-serif'
    }
  }, { global: true });
  
  return (
    <div>
      {/* Automatic scoping example */}
      <button class={autoScopedButton}>
        Auto-scoped Button
      </button>
      
      {/* Manual scoping example */}
      <div class={manuallyScopedStyles}>
        <button 
          class={`button ${isActive() ? 'active' : ''}`}
          onClick={() => isActive(!isActive())}
        >
          Manually Scoped Button
        </button>
      </div>
      
      {/* Global styles are already applied document-wide */}
    </div>
  );
};
```

### CSS Variables

HellaJS provides a dedicated [cssVars](/reference/css/cssVars) function for managing CSS custom properties and theming.

- Flattens nested objects into CSS custom property names (e.g., `bg.primary` becomes `--bg-primary`)
- Injects properties into a `:root` rule in the document head
- Returns an object mapping flattened keys to `var()` references
- Manages cleanup when no longer referenced

```jsx
import { cssVars } from '@hellajs/css';

const ThemeProvider = () => {
  const theme = signal('light');
  const accent = signal('#3b82f6');
  
  // Create CSS variables for theming - these should be updated when theme changes
  const lightVars = cssVars({
    bg: {
      primary: '#ffffff',
      secondary: '#f8fafc'
    },
    text: {
      primary: '#1e293b'
    },
    accent: '#3b82f6'
  });
  
  const darkVars = cssVars({
    bg: {
      primary: '#0f172a',
      secondary: '#1e293b'
    },
    text: {
      primary: '#f1f5f9'
    },
    accent: '#3b82f6'
  });
  
  // Apply the appropriate theme variables when theme changes
  const currentVars = () => theme() === 'light' ? lightVars : darkVars;
  
  const containerStyle = css({
    minHeight: '100vh',
    background: 'var(--bg-primary)',
    color: 'var(--text-primary)',
    padding: '2rem'
  });
  
  const cardStyle = css({
    background: 'var(--bg-secondary)',
    padding: '1.5rem',
    borderRadius: '0.75rem',
    border: '1px solid var(--accent)',
    margin: '1rem 0'
  });
  
  // Update CSS variables when theme changes
  const updateTheme = (newTheme) => {
    theme(newTheme);
    const vars = newTheme === 'light' ? lightVars : darkVars;
    cssVars({
      bg: {
        primary: newTheme === 'light' ? '#ffffff' : '#0f172a',
        secondary: newTheme === 'light' ? '#f8fafc' : '#1e293b'
      },
      text: {
        primary: newTheme === 'light' ? '#1e293b' : '#f1f5f9'
      },
      accent: accent()
    });
  };
  
  return (
    <div class={containerStyle}>
      <div class={cardStyle}>
        <h1>Dynamic Theme System</h1>
        <button onClick={() => updateTheme(theme() === 'light' ? 'dark' : 'light')}>
          Toggle Theme
        </button>
        <input 
          type="color"
          value={accent}
          onChange={e => {
            accent(e.target.value);
            // Update CSS variables with new accent color
            cssVars({
              bg: {
                primary: theme() === 'light' ? '#ffffff' : '#0f172a',
                secondary: theme() === 'light' ? '#f8fafc' : '#1e293b'
              },
              text: {
                primary: theme() === 'light' ? '#1e293b' : '#f1f5f9'
              },
              accent: e.target.value
            });
          }}
        />
      </div>
    </div>
  );
};
```

## Internal Mechanics

High performing CSS-in-JS through intelligent design.

#### Reactive Style Integration

The styling system seamlessly integrates with HellaJS's reactive core, creating a unified approach where style updates benefit from the same dependency tracking and batching optimizations as other reactive computations.

```
Signal Change → Effect Update → Style Recalculation → DOM Update
     ↑                                                     ↓
     └─── Batched Updates & Dependency Tracking ──────────┘
```

Key integration benefits:
- **Granular Updates** - Only styles that depend on changed signals recalculate
- **Automatic Batching** - Multiple style changes are grouped into single DOM updates
- **Dependency Tracking** - System knows exactly which styles need updates
- **Effect Cleanup** - Reactive style bindings are automatically disposed with components

#### Smart Caching System

HellaJS implements an intelligent multi-layer caching system that recognizes when identical CSS objects are used across different components.

```
CSS Object → Content Hash → Cache Lookup → Class Name
    ↓              ↓              ↓             ↓
{color:'red'} → 'abc123' → Hit/Miss → '.cabc123'
```

Caching layers:
- **Content-Based Hashing** - Identical CSS objects always produce the same hash
- **Class Name Cache** - Maps CSS hashes to generated class names
- **Reference Counting** - Tracks usage for automatic cleanup
- **Inline Memoization** - Fast lookup for recently used styles

Performance benefits:
- **Reduced Bundle Size** - Duplicate styles create only one CSS rule
- **Memory Efficiency** - Shared class names across components
- **O(1) Lookups** - Previously processed styles return instantly

#### Automatic Memory Management

Unlike traditional CSS-in-JS solutions that can accumulate styles over time, HellaJS provides comprehensive memory management through reference counting.

```
Component Mount    → Style Used     → Reference Count++
Component Unmount  → Style Unused   → Reference Count--
Reference Count 0  → Style Cleanup  → CSS Rule Removed
```

Memory management features:
- **Reference Tracking** - Each style tracks how many components use it
- **Automatic Cleanup** - Unused styles are removed from DOM automatically
- **Leak Prevention** - No CSS accumulation in long-running applications
- **Manual Control** - `css.remove()` for precise lifecycle management

#### Scoping and Isolation

Every CSS-in-JS style receives automatic scoping through content-based hashing, ensuring complete style isolation without configuration.

```
Input:  css({ padding: '1rem', color: 'blue' })
Hash:   'a1b2c3'
Output: '.ca1b2c3 { padding: 1rem; color: blue; }'
```

Scoping mechanisms:
- **Automatic Scoping** - Content-based hashing creates unique class names
- **Manual Scoping** - Optional prefixes for component libraries
- **Global Scoping** - Bypass scoping for application-wide styles
- **Predictable Names** - Identical styles always generate same class names