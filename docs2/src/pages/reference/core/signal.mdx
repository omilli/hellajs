---
title: signal
description: Create reactive state that automatically updates your UI when values change.
layout: ../../../layouts/MainLayout.astro
---

The fundamental building block of HellaJS reactivity. Create values that automatically update connected UI elements when changed.

## API

```typescript
function signal<T>(): {
  (): T | undefined;
  (value: T | undefined): void;
};
function signal<T>(initialValue: T): {
  (): T;
  (value: T): void;
};
```
- `initialValue`: The initial value for the signal (optional).
- **Returns**: A signal function that can be called to read (no arguments) or write (with argument) the value.

## TypeScript

The `signal` function infers its type from the initial value, or can be explicitly typed.

```typescript
import { signal, Signal } from '@hellajs/core';

// Type is inferred as Signal<number>
const count = signal(0);

// Type is inferred as Signal<string>
const name = signal('Alice');

// Explicit typing for complex types
type Status = 'loading' | 'success' | 'error';
const status = signal<Status>('loading');

// Optional signals  
const user = signal<User | undefined>();

// The Signal<T> type represents the returned function
const getValue: Signal<number> = signal(42);
```

## Basic Usage

Signals are reactive containers that automatically notify dependents when their value changes.

```typescript
import { signal } from '@hellajs/core';

// Create a signal with an initial value
const count = signal(0);
const name = signal('World');

// Read the current value
console.log(count()); // 0

// Update the value  
count(5);
console.log(count()); // 5

// Use in JSX - pass the signal function, not the called value
const App = () => {
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Count: {count}</p>
      <button onClick={() => count(count() + 1)}>
        Increment
      </button>
      <input 
        value={name} 
        onInput={e => name(e.target.value)} 
      />
    </div>
  );
};
```

> **Key Point**: Use `{count}` in JSX (not `{count()}`). HellaJS automatically calls the signal function and creates reactive bindings.

## Core Concepts

### Working with Objects and Arrays

Signals use **strict equality** (`===`) to detect changes. For objects and arrays, you must provide a new reference:

```tsx
const user = signal({ name: 'John', age: 30 });

// ❌ Incorrect: Mutating doesn't trigger updates
user().age = 31;
user(user()); // No change detected

// ✅ Correct: Create new object
user({ ...user(), age: 31 });

// Array updates
const items = signal(['a', 'b']);

// ❌ Incorrect: Mutation doesn't work
items().push('c');

// ✅ Correct: Create new array
items([...items(), 'c']);

// Alternative patterns for readability
const currentItems = items();
items([...currentItems, 'c']);                    // Add item
items(currentItems.filter(x => x !== 'a'));       // Remove item
```

### Reactive Integration
Signals work seamlessly with computed values and effects, creating an efficient dependency graph.

```tsx
import { signal, computed, effect } from '@hellajs/core';

const firstName = signal('John');
const lastName = signal('Doe');

// Computed values automatically track dependencies
const fullName = computed(() => `${firstName()} ${lastName()}`);

// Effects run when dependencies change
effect(() => {
  console.log(`User: ${fullName()}`);
});

firstName('Jane'); // Logs: "User: Jane Doe"
```

## Important Considerations

### Object and Array Updates
Signals use strict equality (`===`) to detect changes. Always create new references for objects and arrays.

```tsx
const user = signal({ name: 'John', age: 30 });
const items = signal(['a', 'b']);

// ❌ Incorrect: Mutation doesn't trigger updates
user().age = 31;
items().push('c');

// ✅ Correct: Create new references
user({ ...user(), age: 31 });
items([...items(), 'c']);
```

### JSX Integration
Always pass the signal function to JSX, never call it directly.

```jsx
// ✅ Correct: Pass signal function
<div>{count}</div>

// ❌ Incorrect: Calling signal breaks reactivity
<div>{count()}</div>
```

### TypeScript Best Practices
Initialize signals with proper default values to avoid runtime errors.

```typescript
// ✅ Safe: Proper null handling
const user = signal<User | null>(null);
return user() ? <div>{user().name}</div> : <div>Loading...</div>;

// ❌ Unsafe: Undefined initial value
const user = signal<User>();
return <div>{user().name}</div>; // Runtime error!
```
