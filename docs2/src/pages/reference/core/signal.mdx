---
title: signal
description: Create reactive state that automatically updates your UI when values change.
layout: ../../../layouts/MainLayout.astro
---

The fundamental building block of HellaJS reactivity. Create values that automatically update connected UI elements when changed.

## Quick Example

```jsx
import { signal } from '@hellajs/core';
import { mount } from '@hellajs/dom';

const App = () => {
  const name = signal('World');

  return (
    <div>
      <h1>Hello, {name}!</h1>
      <input 
        value={name} 
        oninput={e => name(e.target.value)} 
      />
    </div>
  );
};

mount(App, "#app");
```

The input automatically updates the heading as you type‚Äîno manual DOM manipulation needed.

## Basic Usage

### Creating Signals

```tsx
import { signal } from '@hellajs/core';

// Number signal
const count = signal(0);

// String signal  
const message = signal('Hello');

// Boolean signal
const isVisible = signal(true);

// Object signal
const user = signal({ name: 'John', age: 30 });

// Array signal
const items = signal(['apple', 'banana']);

// Undefined initial value
const data = signal<string>();
```

### Reading and Writing

```tsx
// Read the current value
console.log(count()); // 0

// Update the value  
count(5);
console.log(count()); // 5

// Use in expressions
const doubled = count() * 2;
```

### In JSX Components

```jsx
const Counter = () => {
  const count = signal(0);

  return (
    <div>
      <p>Count: {count}</p>
      <button onclick={count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

> **Key Point**: Use `{count}` in JSX (not `{count()}`). HellaJS automatically calls the signal function and creates reactive bindings.

## TypeScript Integration

TypeScript provides full type safety with automatic type inference:

```typescript
// Inferred as Signal<number>
const count = signal(0);

// Inferred as Signal<string>
const name = signal("Alice");

// Explicit typing for complex types
type Status = 'loading' | 'success' | 'error';
const status = signal<Status>('loading');

// Union types
const theme = signal<'light' | 'dark'>('light');

// Optional signals  
const user = signal<User | undefined>();
```

## Advanced Usage

### Working with Objects and Arrays

Signals use **strict equality** (`===`) to detect changes. For objects and arrays, you must provide a new reference:

```tsx
const user = signal({ name: 'John', age: 30 });

// ‚ùå Incorrect: Mutating doesn't trigger updates
user().age = 31;
user(user()); // No change detected

// ‚úÖ Correct: Create new object
user({ ...user(), age: 31 });

// Array updates
const items = signal(['a', 'b']);

// ‚ùå Incorrect: Mutation doesn't work
items().push('c');

// ‚úÖ Correct: Create new array
items([...items(), 'c']);

// Alternative patterns
items(prev => [...prev, 'c']);         // Functional update
items(prev => prev.filter(x => x !== 'a')); // Remove items
```

### Conditional Updates

```tsx
const count = signal(0);

// Update only when condition is met
const increment = () => {
  if (count() < 10) {
    count(count() + 1);
  }
};

// Toggle boolean values
const isVisible = signal(false);
const toggle = () => isVisible(!isVisible());

// Complex state updates
const status = signal<'idle' | 'loading' | 'success'>('idle');
const fetchData = async () => {
  status('loading');
  try {
    const result = await fetch('/api/data');
    status('success');
  } catch {
    status('idle');
  }
};
```

### Performance Optimization

<details>
<summary>‚ö° **Performance Considerations**</summary>

**Granular Updates**: Signals enable fine-grained reactivity‚Äîonly DOM nodes that depend on the changed signal update.

```tsx
const App = () => {
  const name = signal('John');
  const age = signal(30);
  const email = signal('john@example.com');

  return (
    <div>
      <h1>{name}</h1>     {/* Only updates when name changes */}
      <p>{age}</p>        {/* Only updates when age changes */}
      <p>{email}</p>      {/* Only updates when email changes */}
    </div>
  );
};
```

**Avoid Over-signaling**: Don't create unnecessary signals for static data:

```tsx
// ‚ùå Unnecessary signal for static data
const title = signal('My App'); // Never changes

// ‚úÖ Use regular variable for static data
const title = 'My App';
```

**Batch Updates**: Use [`batch()`](/packages/core/batch) for multiple related updates:

```tsx
import { batch } from '@hellajs/core';

const updateUser = (newUser) => {
  batch(() => {
    name(newUser.name);
    age(newUser.age);
    email(newUser.email);
  });
};
```

</details>

### Integration with Other Reactives

```tsx
import { signal, computed, effect } from '@hellajs/core';

const firstName = signal('John');
const lastName = signal('Doe');

// Computed values automatically track dependencies
const fullName = computed(() => `${firstName()} ${lastName()}`);

// Effects run when dependencies change
effect(() => {
  console.log(`User: ${fullName()}`);
});

firstName('Jane'); // Logs: "User: Jane Doe"
```

## How It Works

<details>
<summary>üîç **Signal Internals**</summary>

Signals implement a **push-pull hybrid** reactive system:

1. **Creation**: `signal(value)` creates a reactive container
2. **Reading**: `signal()` registers the current computation as a dependency  
3. **Writing**: `signal(newValue)` notifies all dependents to re-run
4. **Cleanup**: Dependencies are automatically cleaned when components unmount

```tsx
// When you write this:
const count = signal(0);
const doubled = computed(() => count() * 2);

// HellaJS creates this dependency graph:
// count ‚Üí doubled ‚Üí (any effects or DOM nodes)
```

The reactive graph is a **Directed Acyclic Graph (DAG)** that ensures efficient, glitch-free updates.

</details>

## Best Practices

### ‚úÖ Do This

```tsx
// Use descriptive names
const userCount = signal(0);
const isLoggedIn = signal(false);

// Group related signals
const user = {
  name: signal(''),
  email: signal(''),
  age: signal(0)
};

// Create new objects/arrays for updates
items([...items(), newItem]);
user({ ...user(), name: 'New Name' });
```

### ‚ùå Avoid This

```tsx
// Don't call signals unnecessarily
const badComputed = computed(() => {
  return someSignal()(); // Extra call - should be someSignal()
});

// Don't mutate signal contents
items().push(newItem); // Won't trigger updates

// Don't create signals for static data
const PI = signal(3.14159); // Use const PI = 3.14159
```

## Common Pitfalls

### Issue: UI Not Updating

**Problem**: Component doesn't re-render when signal changes.

```jsx
// ‚ùå Wrong: Calling signal in JSX
<div>{count()}</div>

// ‚úÖ Correct: Pass signal function  
<div>{count}</div>
```

### Issue: Object/Array Updates Not Working

**Problem**: Mutating objects doesn't trigger updates.

```tsx
// ‚ùå Wrong: Mutating existing object
user().name = 'New Name';

// ‚úÖ Correct: Create new object
user({ ...user(), name: 'New Name' });
```

### Issue: TypeScript Errors

**Problem**: Type inference isn't working correctly.

```typescript
// ‚ùå Problematic: Ambiguous types
const data = signal(); // Type is unknown

// ‚úÖ Better: Explicit typing
const data = signal<User | null>(null);
```

## Troubleshooting

<details>
<summary>üêõ **Common Issues & Solutions**</summary>

**Q: My signal updates but the UI doesn't change**

A: Make sure you're passing the signal function to JSX, not calling it:
```jsx
// ‚úÖ Correct
<div>{mySignal}</div>

// ‚ùå Incorrect  
<div>{mySignal()}</div>
```

**Q: Array/object changes aren't detected**

A: Signals use reference equality. Create new objects:
```tsx
// ‚úÖ Correct
setItems([...items(), newItem]);

// ‚ùå Incorrect
items().push(newItem);
```

**Q: Getting "Cannot read property" errors**

A: Initialize signals with proper default values:
```tsx
// ‚úÖ Safe
const user = signal<User | null>(null);
return user() ? <div>{user().name}</div> : <div>Loading...</div>;

// ‚ùå Unsafe
const user = signal<User>(); // undefined initial value
return <div>{user().name}</div>; // Error!
```

</details>

## Related APIs

### Related APIs

- **[computed()](/packages/core/computed)** - Create derived values that update automatically when dependencies change.
- **[effect()](/packages/core/effect)** - Run side effects when signals change, like API calls or logging.
- **[batch()](/packages/core/batch)** - Group multiple updates together for better performance.
- **[store()](/packages/store/store)** - Manage complex state with nested objects and automatic reactivity.

## See Also

- **[Understanding Reactivity](/concepts/reactivity)** - How the reactive system works
- **[Quick Start Guide](/learn/quick-start)** - Build your first reactive component
- **[Todo Tutorial](/learn/todo-tutorial)** - Complete application example

---

Signals are the foundation of HellaJS reactivity. Master them, and you'll have fine-grained control over how your application updates.
