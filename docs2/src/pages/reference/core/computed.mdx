---
title: computed
description: A read-only signal that automatically updates when dependencies change.
layout: ../../../layouts/MainLayout.astro
---

A read-only <a href="/packages/core/signal">signal</a> that derives its value from other signals. It automatically tracks dependencies and re-evaluates its value only when those dependencies change.

## API

```typescript
function computed<T>(getter: (previousValue?: T) => T): () => T
```
- `getter`: A function that computes the value. It receives the previously computed value as an optional argument.
- **Returns**: A read-only signal.

## TypeScript

The `computed` function infers its type from the `getter`'s return value.

```typescript
import { signal, computed } from '@hellajs/core';

const count = signal(0);

// Type is inferred as () => number
const double = computed(() => count() * 2);

// Explicit typing
type User = { firstName: string; lastName: string };
const user = signal<User>({ firstName: 'John', lastName: 'Doe' });
const fullName = computed<string>(() => `${user().firstName} ${user().lastName}`);
```

## Basic Usage

Computed signals update automatically when any of their dependencies (signals read during execution) change.

```typescript
import { signal, computed } from '@hellajs/core';

const firstName = signal("John");
const lastName = signal("Doe");
const fullName = computed(() => `${firstName()} ${lastName()}`);

console.log(fullName()); // "John Doe"

firstName("Jane");
console.log(fullName()); // "Jane Doe"
```

## Core Concepts

### Lazy Evaluation
Computed signals are lazy. They only recompute when their value is requested and a dependency has changed.

```typescript
const a = signal(1);
const b = signal(2);

const sum = computed(() => {
  console.log('Computing sum...');
  return a() + b();
});

// Computation does not run if the value is not accessed
a(10);

// Computation runs now, because sum() is accessed
console.log(sum()); // Logs: "Computing sum..." then "12"

// Accessing again returns the cached value without recomputing
console.log(sum()); // "12"
```

### Chaining Computations
Computed signals can depend on other computed signals, creating an efficient graph of reactive dependencies.

```typescript
const price = signal(100);
const quantity = signal(2);

const subtotal = computed(() => price() * quantity());
const tax = computed(() => subtotal() * 0.07); // 7% tax
const total = computed(() => subtotal() + tax());

console.log(total()); // 214

quantity(3);
console.log(total()); // 321
```

### Conditional Dependencies
A computed signal only depends on the signals that are actually read during its *last* execution.

```typescript
const showAdvanced = signal(false);
const basic = signal('basic');
const advanced = signal('advanced');

const setting = computed(() => {
  if (showAdvanced()) {
    return `Advanced: ${advanced()}`;
  }
  return `Basic: ${basic()}`;
});

// Initially, `setting` only depends on `showAdvanced` and `basic`.
// Changing `advanced` will not trigger a re-computation.
advanced('new advanced'); 
console.log(setting()); // "Basic: basic"

// After this, `setting` depends on `showAdvanced` and `advanced`.
showAdvanced(true);
console.log(setting()); // "Advanced: new advanced"
```

## Using the Previous Value
The `getter` function receives the previously computed value as its first argument. This can be used for optimizations or incremental calculations.

```typescript
const numbers = signal([1, 2, 3]);

const sum = computed((previousSum) => {
  const currentNumbers = numbers();
  
  // Optimization: if a number was just added, add it to the previous sum
  if (previousSum && currentNumbers.length === previousNumbers.length + 1) {
    return previousSum + currentNumbers[currentNumbers.length - 1];
  }

  // Full computation
  return currentNumbers.reduce((acc, n) => acc + n, 0);
});
```

## Best Practices

- **Keep Getters Pure**: The `getter` function should not have side effects (like modifying other signals or making API calls). Use <a href="/packages/core/effect">`effect`</a> for side effects.
- **Avoid Complex Logic**: If a computed signal becomes too complex, break it down into smaller, chained computed signals.
