---
layout: ../../../layouts/MainLayout.astro
title: Components
description: Function components that create reactive DOM structures without re-rendering.
---

# Components

Components in HellaJS are functions that return JSX. Unlike traditional frameworks, they execute once to create DOM structure and establish reactive connections, then never run again.

## Run Once, Update Automatically

**Traditional frameworks** re-run components on every state change. **HellaJS components** run once to create structure, then reactive updates happen automatically:

```jsx
// HellaJS - function runs once, reactivity handles updates
const Counter = () => {
  const count = signal(0);
  console.log('Component created!'); // Only logs once ever
  
  return (
    <div>
      <h1>Count: {count}</h1>  {/* Direct reactive connection */}
      <button onclick={() => count(count() + 1)}>+</button>
    </div>
  );
};
```

**Benefits:**
- Better performance - no re-rendering or reconciliation
- Simpler mental model - components are setup functions  
- Direct DOM updates - changes go straight to nodes that need them
- No lifecycle complexity - no useEffect, useMemo, useCallback

## Creating Components

### Static Components
```jsx
const Header = ({ title }) => <h1>{title}</h1>;
const Footer = ({ year = 2024 }) => <footer>© {year} My App</footer>;
```

### Interactive Components
```jsx
const ToggleButton = ({ initialState = false }) => {
  const isOn = signal(initialState);
  
  return (
    <button 
      class={isOn() ? 'on' : 'off'}
      onclick={() => isOn(!isOn())}
    >
      {isOn() ? 'ON' : 'OFF'}
    </button>
  );
};
```

### Async Data Components
```jsx
const UserProfile = ({ userId }) => {
  const user = signal(null);
  const loading = signal(true);
  
  fetch(`/api/users/${userId}`)
    .then(response => response.json())
    .then(data => {
      user(data);
      loading(false);
    });
    
  return (
    <div class="user-profile">
      {loading() && <div>Loading...</div>}
      {user() && <div><h2>{user().name}</h2></div>}
    </div>
  );
};
```

## Component Composition

Build complex UIs by combining components through props and children:

```jsx
const Card = ({ title, variant = 'default' }, children) => (
  <div class={`card card-${variant}`}>
    <div class="card-header"><h2>{title}</h2></div>
    <div class="card-content">{children}</div>
  </div>
);

const Button = ({ variant = 'primary', onclick, children }) => (
  <button class={`btn btn-${variant}`} onclick={onclick}>
    {children}
  </button>
);

// Components compose naturally
const MyPage = () => (
  <Card title="Welcome" variant="highlighted">
    <p>Welcome to our application!</p>
    <Button onclick={() => alert('Hello!')}>Get Started</Button>
  </Card>
);
```

## Reactive Data Flow

Pass reactive signals between components for automatic updates:

```jsx
const UserCard = ({ user }) => (
  <div class="user-card">
    <h3>{user().name}</h3>
    <p>{user().email}</p>
    <span class={`status ${user().isOnline ? 'online' : 'offline'}`}>
      {user().isOnline ? 'Online' : 'Offline'}
    </span>
  </div>
);

const UserList = () => {
  const selectedUser = signal({ 
    name: 'John Doe', 
    email: 'john@example.com',
    isOnline: true
  });
  
  return (
    <div class="user-list">
      <UserCard user={selectedUser} />
      <button onclick={() => selectedUser({
        name: 'Jane Smith',
        email: 'jane@example.com', 
        isOnline: false
      })}>
        Switch User
      </button>
    </div>
  );
};
```

## State Management

Choose the right approach based on your needs:

**Local State** - For component-specific data:
```jsx
const Counter = () => {
  const count = signal(0);
  const doubled = computed(() => count() * 2);
  
  return (
    <div>
      <p>Count: {count} (doubled: {doubled})</p>
      <button onclick={() => count(count() + 1)}>+</button>
    </div>
  );
};
```

**Shared State** - For data used across components:
```jsx
// Defined outside components
const globalTheme = signal('light');
const globalUser = signal(null);

const Header = () => (
  <header class={`header theme-${globalTheme()}`}>
    <h1>My App</h1>
    {globalUser() ? (
      <span>Welcome, {globalUser().name}</span>
    ) : (
      <span>Not logged in</span>
    )}
  </header>
);
```

**Complex State with Stores:**
```jsx
import { store } from '@hellajs/store';

const ShoppingCart = () => {
  const cartStore = store({
    items: [],
    
    get total() {
      return this.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    },
    
    addItem(product) {
      const existingItem = this.items.find(item => item.id === product.id);
      if (existingItem) {
        existingItem.quantity += 1;
      } else {
        this.items.push({ ...product, quantity: 1 });
      }
    }
  });
  
  return (
    <div class="shopping-cart">
      <h2>Shopping Cart ({cartStore.items.length} items)</h2>
      <div class="cart-total">
        <strong>Total: ${cartStore.total.toFixed(2)}</strong>
      </div>
    </div>
  );
};
```

## Best Practices

### ✅ Do This
```jsx
// Use computed for derived values
const ExpensiveList = ({ items }) => {
  const sortedItems = computed(() => 
    items().sort((a, b) => a.name.localeCompare(b.name))
  );
  
  return (
    <ul>
      {sortedItems().map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
};

// Keep components focused and composable
const UserCard = ({ user }) => (
  <div class="user-card">
    <UserAvatar src={user().avatar} />
    <UserInfo user={user} />
    <UserActions userId={user().id} />
  </div>
);
```

### ❌ Avoid This
```jsx
// Don't create signals inside components
const BadComponent = ({ data }) => {
  const processedData = signal(expensiveOperation(data)); // Wrong!
  return <div>{processedData}</div>;
};

// Don't mutate props
const BadComponent = ({ items }) => {
  items().push(newItem); // Don't mutate!
  return <ul>{items().map(item => <li>{item}</li>)}</ul>;
};
```

## Next Steps

Now that you understand HellaJS components deeply, explore these related topics:

### Foundation Concepts
- **[Reactivity](/learn/concepts/reactivity)** - Master signals, computed, and effects
- **[State Management](/learn/concepts/state)** - Organize state in larger applications
- **[Styling](/learn/concepts/styling)** - Add CSS and dynamic styles to components

### Practical Application
- **[Counter Tutorial](/learn/tutorials/counter-app)** - Build your first interactive component
- **[Todo App Tutorial](/learn/tutorials/todo-app)** - Create a complete application
- **[Performance](/learn/concepts/performance)** - Optimize component rendering

### Advanced Integration
- **[Resources](/learn/concepts/resources)** - Handle async data in components
- **[Routing](/learn/concepts/routing)** - Build multi-page component applications