---
layout: ../../../layouts/MainLayout.astro
title: Component Architecture
description: Master component patterns in HellaJS - composition, props, children, lifecycle, and reusable component design.
---

HellaJS components are **functions that return JSX**. Unlike traditional component frameworks, HellaJS components don't have lifecycle methods, state management hooks, or re-rendering cycles - they're just functions that describe the initial structure and reactive connections.

## Basic Component Patterns

### Functional Components

The simplest HellaJS component is a function that returns JSX:

```jsx
import { signal } from '@hellajs/core';
import { mount } from '@hellajs/dom';

// Simple component
const Greeting = () => {
  return <h1>Hello, World!</h1>;
};

// Component with local state
const Counter = () => {
  const count = signal(0);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};

// Component with props
const UserCard = ({ name, email, avatar }) => {
  return (
    <div class="user-card">
      <img src={avatar} alt={name} />
      <h3>{name}</h3>
      <p>{email}</p>
    </div>
  );
};

const App = () => {
  return (
    <div>
      <Greeting />
      <Counter />
      <UserCard 
        name="John Doe" 
        email="john@example.com"
        avatar="/avatar.jpg"
      />
    </div>
  );
};

mount(App, "#app");
```

### Props and Reactivity

Components can receive both static values and reactive signals as props:

```jsx
const ReactiveUserCard = ({ user, onEdit, onDelete }) => {
  const isEditing = signal(false);
  const editName = signal('');

  const startEdit = () => {
    editName(user().name);
    isEditing(true);
  };

  const saveEdit = () => {
    onEdit({ ...user(), name: editName() });
    isEditing(false);
  };

  const cancelEdit = () => {
    isEditing(false);
  };

  return (
    <div class="user-card">
      {isEditing() ? (
        <div class="editing">
          <input 
            value={editName}
            oninput={e => editName(e.target.value)}
          />
          <button onclick={saveEdit}>Save</button>
          <button onclick={cancelEdit}>Cancel</button>
        </div>
      ) : (
        <div class="display">
          <h3>{user().name}</h3>
          <p>{user().email}</p>
          <div class="actions">
            <button onclick={startEdit}>Edit</button>
            <button onclick={() => onDelete(user().id)}>Delete</button>
          </div>
        </div>
      )}
    </div>
  );
};

const UserManager = () => {
  const users = signal([
    { id: 1, name: 'John Doe', email: 'john@example.com' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
  ]);

  const editUser = (updatedUser) => {
    users(users().map(u => 
      u.id === updatedUser.id ? updatedUser : u
    ));
  };

  const deleteUser = (id) => {
    users(users().filter(u => u.id !== id));
  };

  return (
    <div>
      <h1>Users</h1>
      {users().map(user => (
        <ReactiveUserCard
          key={user.id}
          user={() => user} // Pass as reactive getter
          onEdit={editUser}
          onDelete={deleteUser}
        />
      ))}
    </div>
  );
};
```

**Key Pattern**: When passing data that might change, pass it as a reactive getter `() => data` rather than the value directly.

## Component Composition

### Children and Slots

Components can accept children and provide flexible composition patterns:

```jsx
// Container component that accepts children
const Card = ({ title, children, footer }) => {
  return (
    <div class="card">
      {title && <div class="card-header">{title}</div>}
      <div class="card-body">
        {children}
      </div>
      {footer && <div class="card-footer">{footer}</div>}
    </div>
  );
};

// Layout component with named slots
const Layout = ({ header, sidebar, children, footer }) => {
  return (
    <div class="layout">
      <header class="layout-header">
        {header}
      </header>
      <div class="layout-content">
        <aside class="layout-sidebar">
          {sidebar}
        </aside>
        <main class="layout-main">
          {children}
        </main>
      </div>
      <footer class="layout-footer">
        {footer}
      </footer>
    </div>
  );
};

// Using composition
const BlogApp = () => {
  const posts = signal([
    { id: 1, title: 'First Post', content: 'Hello World' },
    { id: 2, title: 'Second Post', content: 'More content' }
  ]);

  return (
    <Layout
      header={<h1>My Blog</h1>}
      sidebar={
        <nav>
          <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/about">About</a></li>
            <li><a href="/contact">Contact</a></li>
          </ul>
        </nav>
      }
      footer={<p>&copy; 2024 My Blog</p>}
    >
      {posts().map(post => (
        <Card 
          key={post.id}
          title={post.title}
          footer={<small>Published today</small>}
        >
          <p>{post.content}</p>
        </Card>
      ))}
    </Layout>
  );
};
```

### Higher-Order Components

Functions that create and return components:

```jsx
// HOC that adds loading state to any component
const withLoading = (Component) => {
  return (props) => {
    const isLoading = signal(false);
    
    const withLoadingProps = {
      ...props,
      isLoading,
      setLoading: isLoading
    };

    return (
      <>
        {isLoading() && <div class="loading">Loading...</div>}
        <div style={isLoading() ? 'opacity: 0.5' : ''}>
          <Component {...withLoadingProps} />
        </div>
      </>
    );
  };
};

// HOC that adds error boundary
const withErrorBoundary = (Component) => {
  return (props) => {
    const error = signal(null);

    const resetError = () => error(null);

    const withErrorProps = {
      ...props,
      onError: error,
      resetError
    };

    return error() ? (
      <div class="error-boundary">
        <h2>Something went wrong!</h2>
        <p>{error().message}</p>
        <button onclick={resetError}>Try again</button>
      </div>
    ) : (
      <Component {...withErrorProps} />
    );
  };
};

// Component that uses HOCs
const DataComponent = ({ isLoading, setLoading, onError }) => {
  const data = signal(null);

  const fetchData = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/data');
      if (!response.ok) throw new Error('Failed to fetch');
      const result = await response.json();
      data(result);
    } catch (err) {
      onError(err);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div>
      <button onclick={fetchData}>Fetch Data</button>
      {data() && <pre>{JSON.stringify(data(), null, 2)}</pre>}
    </div>
  );
};

// Enhanced component with both HOCs
const EnhancedDataComponent = withErrorBoundary(withLoading(DataComponent));
```

## Advanced Component Patterns

### Component State Management

```jsx
import { store } from '@hellajs/store';

// Component with complex internal state using store
const TodoList = ({ initialTodos = [] }) => {
  const todoStore = store({
    todos: initialTodos,
    filter: 'all', // 'all', 'active', 'completed'
    newTodoText: '',

    get filteredTodos() {
      switch (this.filter) {
        case 'active': return this.todos.filter(t => !t.completed);
        case 'completed': return this.todos.filter(t => t.completed);
        default: return this.todos;
      }
    },

    get stats() {
      return {
        total: this.todos.length,
        active: this.todos.filter(t => !t.completed).length,
        completed: this.todos.filter(t => t.completed).length
      };
    },

    addTodo() {
      if (!this.newTodoText.trim()) return;
      
      this.todos.push({
        id: Date.now(),
        text: this.newTodoText.trim(),
        completed: false
      });
      this.newTodoText = '';
    },

    toggleTodo(id) {
      const todo = this.todos.find(t => t.id === id);
      if (todo) todo.completed = !todo.completed;
    },

    deleteTodo(id) {
      const index = this.todos.findIndex(t => t.id === id);
      if (index > -1) this.todos.splice(index, 1);
    },

    setFilter(filter) {
      this.filter = filter;
    }
  });

  return (
    <div class="todo-list">
      <div class="todo-input">
        <input
          value={todoStore.newTodoText}
          oninput={e => todoStore.newTodoText = e.target.value}
          onkeydown={e => e.key === 'Enter' && todoStore.addTodo()}
          placeholder="Add a new todo..."
        />
        <button onclick={() => todoStore.addTodo()}>Add</button>
      </div>

      <div class="todo-filters">
        {['all', 'active', 'completed'].map(filter => (
          <button
            key={filter}
            class={todoStore.filter === filter ? 'active' : ''}
            onclick={() => todoStore.setFilter(filter)}
          >
            {filter} ({
              filter === 'all' ? todoStore.stats.total :
              filter === 'active' ? todoStore.stats.active :
              todoStore.stats.completed
            })
          </button>
        ))}
      </div>

      <ul class="todos">
        {todoStore.filteredTodos.map(todo => (
          <li key={todo.id} class={todo.completed ? 'completed' : ''}>
            <input
              type="checkbox"
              checked={todo.completed}
              onchange={() => todoStore.toggleTodo(todo.id)}
            />
            <span>{todo.text}</span>
            <button onclick={() => todoStore.deleteTodo(todo.id)}>×</button>
          </li>
        ))}
      </ul>
    </div>
  );
};
```

### Controlled vs Uncontrolled Components

```jsx
// Uncontrolled component - manages its own state
const UncontrolledInput = ({ onSubmit, placeholder }) => {
  const value = signal('');

  const handleSubmit = () => {
    onSubmit(value());
    value('');
  };

  return (
    <div>
      <input
        value={value}
        oninput={e => value(e.target.value)}
        onkeydown={e => e.key === 'Enter' && handleSubmit()}
        placeholder={placeholder}
      />
      <button onclick={handleSubmit}>Submit</button>
    </div>
  );
};

// Controlled component - state managed by parent
const ControlledInput = ({ value, onInput, onSubmit, placeholder }) => {
  const handleSubmit = () => {
    onSubmit(value());
  };

  return (
    <div>
      <input
        value={value}
        oninput={e => onInput(e.target.value)}
        onkeydown={e => e.key === 'Enter' && handleSubmit()}
        placeholder={placeholder}
      />
      <button onclick={handleSubmit}>Submit</button>
    </div>
  );
};

// Parent component demonstrating both patterns
const InputDemo = () => {
  const controlledValue = signal('');
  const messages = signal([]);

  const addMessage = (text) => {
    messages([...messages(), text]);
  };

  return (
    <div>
      <h3>Uncontrolled Input</h3>
      <UncontrolledInput
        onSubmit={addMessage}
        placeholder="Type and press enter..."
      />

      <h3>Controlled Input</h3>
      <ControlledInput
        value={controlledValue}
        onInput={controlledValue}
        onSubmit={(text) => {
          addMessage(text);
          controlledValue('');
        }}
        placeholder="Controlled input..."
      />

      <h3>Messages</h3>
      <ul>
        {messages().map((msg, index) => (
          <li key={index}>{msg}</li>
        ))}
      </ul>
    </div>
  );
};
```

### Component Libraries and Design Systems

```jsx
// Base components with consistent styling
const Button = ({ 
  variant = 'primary', 
  size = 'medium', 
  disabled, 
  children, 
  onclick,
  ...props 
}) => {
  const baseClasses = 'btn';
  const variantClasses = `btn-${variant}`;
  const sizeClasses = `btn-${size}`;
  const className = [baseClasses, variantClasses, sizeClasses].join(' ');

  return (
    <button
      class={className}
      disabled={disabled}
      onclick={onclick}
      {...props}
    >
      {children}
    </button>
  );
};

const Input = ({ 
  type = 'text', 
  value, 
  onInput, 
  error, 
  label, 
  placeholder,
  ...props 
}) => {
  return (
    <div class="input-group">
      {label && <label class="input-label">{label}</label>}
      <input
        type={type}
        class={`input ${error ? 'input-error' : ''}`}
        value={value}
        oninput={e => onInput?.(e.target.value)}
        placeholder={placeholder}
        {...props}
      />
      {error && <span class="input-error-text">{error}</span>}
    </div>
  );
};

const Modal = ({ isOpen, onClose, title, children, size = 'medium' }) => {
  return (
    <>
      {isOpen() && (
        <>
          <div 
            class="modal-overlay"
            onclick={onClose}
          />
          <div class={`modal modal-${size}`}>
            <div class="modal-header">
              <h2 class="modal-title">{title}</h2>
              <button class="modal-close" onclick={onClose}>×</button>
            </div>
            <div class="modal-body">
              {children}
            </div>
          </div>
        </>
      )}
    </>
  );
};

// Using the design system
const UserForm = () => {
  const formData = store({
    name: '',
    email: '',
    errors: {}
  });

  const isModalOpen = signal(false);
  const isSubmitting = signal(false);

  const validateForm = () => {
    const errors = {};
    
    if (!formData.name.trim()) {
      errors.name = 'Name is required';
    }
    
    if (!formData.email.trim()) {
      errors.email = 'Email is required';
    } else if (!formData.email.includes('@')) {
      errors.email = 'Please enter a valid email';
    }

    formData.errors = errors;
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = async () => {
    if (!validateForm()) return;

    isSubmitting(true);
    try {
      // Simulate API call
      await new Promise(resolve => setTimeout(resolve, 1000));
      console.log('Form submitted:', formData);
      isModalOpen(false);
      // Reset form
      formData.name = '';
      formData.email = '';
      formData.errors = {};
    } catch (error) {
      formData.errors = { submit: 'Failed to submit form' };
    } finally {
      isSubmitting(false);
    }
  };

  return (
    <div>
      <Button onclick={() => isModalOpen(true)}>
        Open User Form
      </Button>

      <Modal
        isOpen={isModalOpen}
        onClose={() => isModalOpen(false)}
        title="Add User"
        size="large"
      >
        <div style="display: flex; flex-direction: column; gap: 1rem;">
          <Input
            label="Name"
            value={formData.name}
            onInput={value => formData.name = value}
            error={formData.errors.name}
            placeholder="Enter your name"
          />
          
          <Input
            type="email"
            label="Email"
            value={formData.email}
            onInput={value => formData.email = value}
            error={formData.errors.email}
            placeholder="Enter your email"
          />
          
          {formData.errors.submit && (
            <div class="error-message">{formData.errors.submit}</div>
          )}
          
          <div style="display: flex; gap: 0.5rem; justify-content: flex-end;">
            <Button 
              variant="secondary" 
              onclick={() => isModalOpen(false)}
              disabled={isSubmitting}
            >
              Cancel
            </Button>
            <Button 
              onclick={handleSubmit}
              disabled={isSubmitting}
            >
              {isSubmitting() ? 'Submitting...' : 'Submit'}
            </Button>
          </div>
        </div>
      </Modal>
    </div>
  );
};
```

## Component Performance

### Avoiding Unnecessary Re-renders

```jsx
// ❌ Less efficient - creates new functions every render
const InefficientList = ({ items }) => {
  return (
    <ul>
      {items().map(item => (
        <li key={item.id}>
          {item.name}
          {/* This creates a new function every time items() changes */}
          <button onclick={() => console.log('Clicked', item.id)}>
            Click me
          </button>
        </li>
      ))}
    </ul>
  );
};

// ✅ More efficient - stable event handlers
const EfficientList = ({ items, onItemClick }) => {
  return (
    <ul>
      {items().map(item => (
        <li key={item.id}>
          {item.name}
          <button onclick={() => onItemClick(item.id)}>
            Click me
          </button>
        </li>
      ))}
    </ul>
  );
};

// ✅ Even better - extract item component
const ListItem = ({ item, onItemClick }) => {
  return (
    <li>
      {item.name}
      <button onclick={() => onItemClick(item.id)}>
        Click me
      </button>
    </li>
  );
};

const OptimalList = ({ items, onItemClick }) => {
  return (
    <ul>
      {items().map(item => (
        <ListItem 
          key={item.id} 
          item={item} 
          onItemClick={onItemClick} 
        />
      ))}
    </ul>
  );
};
```

### Memoization Patterns

```jsx
import { computed } from '@hellajs/core';

const ExpensiveComponent = ({ data, config }) => {
  // Memoize expensive calculations
  const processedData = computed(() => {
    console.log('Processing data...'); // Only logs when data() changes
    return data().map(item => ({
      ...item,
      processed: heavyComputation(item, config())
    }));
  });

  const stats = computed(() => {
    console.log('Calculating stats...'); // Only logs when processedData changes
    return {
      count: processedData().length,
      average: processedData().reduce((sum, item) => sum + item.value, 0) / processedData().length
    };
  });

  return (
    <div>
      <div>Items: {stats().count}</div>
      <div>Average: {stats().average.toFixed(2)}</div>
      
      <ul>
        {processedData().map(item => (
          <li key={item.id}>
            {item.name}: {item.processed}
          </li>
        ))}
      </ul>
    </div>
  );
};

function heavyComputation(item, config) {
  // Simulate expensive operation
  let result = item.value;
  for (let i = 0; i < 10000; i++) {
    result = (result * config.multiplier) % config.modulus;
  }
  return result;
}
```

## Testing Components

```jsx
// Testable component design
const SearchableList = ({ 
  items, 
  onSearch, 
  onItemClick,
  placeholder = 'Search...' 
}) => {
  const searchTerm = signal('');
  
  const filteredItems = computed(() => {
    const term = searchTerm().toLowerCase();
    return items().filter(item => 
      item.name.toLowerCase().includes(term)
    );
  });

  const handleSearch = (value) => {
    searchTerm(value);
    onSearch?.(value);
  };

  return (
    <div data-testid="searchable-list">
      <input
        data-testid="search-input"
        value={searchTerm}
        oninput={e => handleSearch(e.target.value)}
        placeholder={placeholder}
      />
      
      <ul data-testid="results-list">
        {filteredItems().map(item => (
          <li 
            key={item.id}
            data-testid={`item-${item.id}`}
            onclick={() => onItemClick?.(item)}
          >
            {item.name}
          </li>
        ))}
      </ul>
      
      {filteredItems().length === 0 && (
        <div data-testid="no-results">No items found</div>
      )}
    </div>
  );
};

// Usage in tests (pseudo-code)
/*
test('SearchableList filters items correctly', () => {
  const items = signal([
    { id: 1, name: 'Apple' },
    { id: 2, name: 'Banana' },
    { id: 3, name: 'Cherry' }
  ]);

  const onSearch = vi.fn();
  const onItemClick = vi.fn();

  mount(SearchableList, {
    items,
    onSearch,
    onItemClick
  });

  const searchInput = screen.getByTestId('search-input');
  fireEvent.input(searchInput, { target: { value: 'app' } });

  expect(screen.getByText('Apple')).toBeInTheDocument();
  expect(screen.queryByText('Banana')).not.toBeInTheDocument();
  expect(onSearch).toHaveBeenCalledWith('app');
});
*/
```

## Best Practices

### ✅ Do This

- **Keep components focused** - Single responsibility principle
- **Use props for customization** - Make components flexible
- **Extract reusable logic** - Create custom hooks or utilities
- **Use composition over inheritance** - Build complex UIs from simple components
- **Provide clear interfaces** - Well-defined props and callbacks
- **Handle edge cases** - Empty states, loading states, error states

### ❌ Avoid This

- **Don't create overly complex components** - Break them down
- **Don't tightly couple components** - Use props and callbacks
- **Don't ignore performance** - Consider expensive operations
- **Don't skip prop validation** - Use TypeScript or runtime checks
- **Don't forget accessibility** - Add proper ARIA attributes

## Related Concepts

- **⚛️ [Reactivity](/learn/concepts/reactivity)** - Understanding reactive state in components
- **📝 [Templating](/learn/concepts/templating)** - JSX patterns and reactive bindings
- **🎨 [Styling](/learn/concepts/styling)** - Styling components effectively
- **📊 [State Management](/learn/concepts/state)** - Managing state across components
- **🧪 [Testing](/learn/concepts/testing)** - Testing component behavior

## Related APIs

- **[`signal()`](/reference/core/signal)** - Component local state
- **[`computed()`](/reference/core/computed)** - Derived component state
- **[`store()`](/reference/store/store)** - Complex component state
- **[`mount()`](/reference/dom/mount)** - Rendering components

---

> **Component Philosophy**: HellaJS components are simple functions that describe structure and behavior. Focus on composition, clear interfaces, and reactive state management to build maintainable applications.