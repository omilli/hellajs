---
layout: ../../../layouts/MainLayout.astro
title: Components
description: Building UIs with function components in HellaJS.
---

# Components

Components in HellaJS are **functions that return JSX** - but unlike traditional frameworks, they run once to create the DOM structure and set up reactive connections, then never run again.

## What Makes HellaJS Components Different

**Traditional frameworks** re-run components every time state changes:

```jsx
// React - entire function re-runs on every state change
function Counter() {
  const [count, setCount] = useState(0);
  console.log('Component function running!'); // Logs on every click
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

**HellaJS components** run once to create the structure, then reactive updates happen automatically:

```jsx
// HellaJS - function runs once, reactivity handles updates
const Counter = () => {
  const count = signal(0);
  console.log('Component created!'); // Only logs once ever
  
  return (
    <div>
      <h1>Count: {count}</h1>  {/* Direct reactive connection */}
      <button onclick={() => count(count() + 1)}>+</button>
    </div>
  );
};
```

**Why This Matters:**
- 🚀 **Better Performance** - No re-rendering, no reconciliation, no waste
- 🧠 **Simpler Mental Model** - Components are just setup functions
- 🎯 **Direct Updates** - Changes go straight to the DOM nodes that need them
- ⚡ **No Lifecycle Hooks** - No useEffect, useMemo, useCallback complexity

## Creating Components

### Simple Static Components

For content that never changes, components are just functions:

```jsx
const Header = ({ title }) => <h1>{title}</h1>;
const Footer = ({ year = 2024 }) => <footer>© {year} My App</footer>;
const WelcomeMessage = () => <div class="welcome">Welcome to HellaJS!</div>;
```

### Components with State

Add reactivity with signals for components that change:

```jsx
const ToggleButton = ({ initialState = false }) => {
  const isOn = signal(initialState);
  
  return (
    <button 
      class={isOn() ? 'on' : 'off'}
      onclick={() => isOn(!isOn())}
    >
      {isOn() ? 'ON' : 'OFF'}
    </button>
  );
};

const InputField = ({ placeholder = 'Type here...' }) => {
  const value = signal('');
  const charCount = computed(() => value().length);
  
  return (
    <div>
      <input 
        value={value}
        oninput={e => value(e.target.value)}
        placeholder={placeholder}
      />
      <small>Characters: {charCount}</small>
    </div>
  );
};
```

### Components with Async Data

Handle loading and data fetching:

```jsx
const UserProfile = ({ userId }) => {
  const user = signal(null);
  const loading = signal(true);
  const error = signal(null);
  
  // This runs once when component is created
  fetch(`/api/users/${userId}`)
    .then(response => response.json())
    .then(data => {
      user(data);
      loading(false);
    })
    .catch(err => {
      error(err.message);
      loading(false);
    });
    
  return (
    <div class="user-profile">
      {loading() && <div class="loading">Loading user...</div>}
      {error() && <div class="error">Error: {error}</div>}
      {user() && (
        <div class="user-info">
          <h2>{user().name}</h2>
          <p>{user().email}</p>
          <p>Joined: {new Date(user().createdAt).toLocaleDateString()}</p>
        </div>
      )}
    </div>
  );
};
```

## Component Composition

Components work together through props and children to build complex UIs:

### Props and Children

```jsx
const Card = ({ title, variant = 'default' }, children) => {
  return (
    <div class={`card card-${variant}`}>
      <div class="card-header">
        <h2>{title}</h2>
      </div>
      <div class="card-content">
        {children}
      </div>
    </div>
  );
};

const Button = ({ variant = 'primary', onclick, children }) => (
  <button class={`btn btn-${variant}`} onclick={onclick}>
    {children}
  </button>
);

// Usage - components compose naturally
const MyPage = () => (
  <div>
    <Card title="Welcome" variant="highlighted">
      <p>Welcome to our application!</p>
      <Button onclick={() => alert('Hello!')}>
        Get Started
      </Button>
    </Card>
  </div>
);
```

### Layout Components

```jsx
const Layout = ({ header, sidebar, children }) => (
  <div class="layout">
    <header class="layout-header">{header}</header>
    <div class="layout-body">
      <aside class="layout-sidebar">{sidebar}</aside>
      <main class="layout-main">{children}</main>
    </div>
  </div>
);

// Usage
const App = () => (
  <Layout
    header={<h1>My App</h1>}
    sidebar={<nav><a href="/">Home</a></nav>}
  >
    <h2>Main Content</h2>
    <p>This is the main content area.</p>
  </Layout>
);
```

## Reactive Props and Data Flow

Pass reactive data between components to create dynamic, interconnected UIs:

### Passing Reactive State

```jsx
const UserCard = ({ user }) => (
  <div class="user-card">
    <div class="user-avatar">
      <img src={user().avatar} alt={user().name} />
    </div>
    <div class="user-info">
      <h3>{user().name}</h3>
      <p>{user().email}</p>
      <span class={`status ${user().isOnline ? 'online' : 'offline'}`}>
        {user().isOnline ? '🟢 Online' : '🔴 Offline'}
      </span>
    </div>
  </div>
);

const UserList = () => {
  const selectedUser = signal({ 
    name: 'John Doe', 
    email: 'john@example.com',
    avatar: '/avatars/john.jpg',
    isOnline: true
  });
  
  return (
    <div class="user-list">
      <UserCard user={selectedUser} />
      <button onclick={() => selectedUser({
        name: 'Jane Smith',
        email: 'jane@example.com', 
        avatar: '/avatars/jane.jpg',
        isOnline: false
      })}>
        Switch User
      </button>
    </div>
  );
};
```

### Event Handling Across Components

```jsx
const SearchInput = ({ onSearch, placeholder }) => {
  const query = signal('');
  
  const handleSearch = () => {
    if (onSearch) onSearch(query());
  };
  
  return (
    <div class="search-input">
      <input 
        value={query}
        oninput={e => query(e.target.value)}
        onkeydown={e => e.key === 'Enter' && handleSearch()}
        placeholder={placeholder}
      />
      <button onclick={handleSearch}>Search</button>
    </div>
  );
};

const SearchableList = () => {
  const items = signal(['Apple', 'Banana', 'Cherry', 'Date']);
  const searchResults = signal([]);
  
  const handleSearch = (query) => {
    const results = items().filter(item => 
      item.toLowerCase().includes(query.toLowerCase())
    );
    searchResults(results);
  };
  
  return (
    <div>
      <SearchInput 
        onSearch={handleSearch} 
        placeholder="Search items..." 
      />
      <ul>
        {searchResults().map(item => (
          <li key={item}>{item}</li>
        ))}
      </ul>
    </div>
  );
};
```

## Managing Component State

### Local State vs Shared State

```jsx
// Local state - only used within this component
const Counter = () => {
  const count = signal(0);
  const doubled = computed(() => count() * 2);
  
  return (
    <div>
      <p>Count: {count} (doubled: {doubled})</p>
      <button onclick={() => count(count() + 1)}>+</button>
    </div>
  );
};

// Shared state - defined outside, used by multiple components
const globalTheme = signal('light');
const globalUser = signal(null);

const ThemeToggle = () => (
  <button onclick={() => globalTheme(globalTheme() === 'light' ? 'dark' : 'light')}>
    Switch to {globalTheme() === 'light' ? 'dark' : 'light'} mode
  </button>
);

const Header = () => (
  <header class={`header theme-${globalTheme()}`}>
    <h1>My App</h1>
    {globalUser() ? (
      <span>Welcome, {globalUser().name}</span>
    ) : (
      <span>Not logged in</span>
    )}
    <ThemeToggle />
  </header>
);
```

### Complex State with Stores

```jsx
import { store } from '@hellajs/store';

const ShoppingCart = () => {
  const cartStore = store({
    items: [],
    
    get total() {
      return this.items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    },
    
    get itemCount() {
      return this.items.reduce((sum, item) => sum + item.quantity, 0);
    },
    
    addItem(product) {
      const existingItem = this.items.find(item => item.id === product.id);
      if (existingItem) {
        existingItem.quantity += 1;
      } else {
        this.items.push({ ...product, quantity: 1 });
      }
    },
    
    removeItem(id) {
      const index = this.items.findIndex(item => item.id === id);
      if (index > -1) this.items.splice(index, 1);
    }
  });
  
  return (
    <div class="shopping-cart">
      <h2>Shopping Cart ({cartStore.itemCount} items)</h2>
      
      <div class="cart-items">
        {cartStore.items.map(item => (
          <div key={item.id} class="cart-item">
            <span>{item.name}</span>
            <span>${item.price} x {item.quantity}</span>
            <button onclick={() => cartStore.removeItem(item.id)}>Remove</button>
          </div>
        ))}
      </div>
      
      <div class="cart-total">
        <strong>Total: ${cartStore.total.toFixed(2)}</strong>
      </div>
      
      <button 
        class="add-sample"
        onclick={() => cartStore.addItem({ id: Date.now(), name: 'Sample Item', price: 9.99 })}
      >
        Add Sample Item
      </button>
    </div>
  );
};
```

## Advanced Component Patterns

### Higher-Order Components (HOCs)

Enhance components with reusable functionality:

```jsx
const withErrorBoundary = (Component) => {
  return (props) => {
    const error = signal(null);
    
    const handleError = (err) => {
      console.error('Component error:', err);
      error(err.message);
    };
    
    if (error()) {
      return (
        <div class="error-boundary">
          <h3>Something went wrong</h3>
          <p>{error()}</p>
          <button onclick={() => error(null)}>Try Again</button>
        </div>
      );
    }
    
    return <Component {...props} onError={handleError} />;
  };
};

const withLoading = (Component) => {
  return (props) => {
    const isLoading = signal(false);
    
    return (
      <div class="loading-wrapper">
        {isLoading() && (
          <div class="loading-overlay">
            <div class="spinner">Loading...</div>
          </div>
        )}
        <Component {...props} isLoading={isLoading} setLoading={isLoading} />
      </div>
    );
  };
};

// Combine multiple HOCs
const EnhancedComponent = withErrorBoundary(withLoading(MyComponent));
```

### Component Factories

Generate specialized components programmatically:

```jsx
const createFormField = (fieldType, validation) => {
  return ({ label, value, onchange, ...props }) => {
    const error = signal(null);
    
    const handleChange = (newValue) => {
      const validationError = validation ? validation(newValue) : null;
      error(validationError);
      
      if (!validationError && onchange) {
        onchange(newValue);
      }
    };
    
    return (
      <div class="form-field">
        <label>{label}</label>
        <input 
          type={fieldType}
          value={value}
          oninput={e => handleChange(e.target.value)}
          class={error() ? 'error' : ''}
          {...props}
        />
        {error() && <span class="error-message">{error()}</span>}
      </div>
    );
  };
};

// Create specialized field components
const EmailField = createFormField('email', (value) => {
  if (!value.includes('@')) return 'Please enter a valid email';
  return null;
});

const PasswordField = createFormField('password', (value) => {
  if (value.length < 8) return 'Password must be at least 8 characters';
  return null;
});
```

### Render Props Pattern

Share logic between components using function props:

```jsx
const DataFetcher = ({ url, children }) => {
  const data = signal(null);
  const loading = signal(true);
  const error = signal(null);
  
  // Fetch data when component mounts
  fetch(url)
    .then(response => response.json())
    .then(result => {
      data(result);
      loading(false);
    })
    .catch(err => {
      error(err);
      loading(false);
    });
  
  return children({ data: data(), loading: loading(), error: error() });
};

// Usage
const UserList = () => (
  <DataFetcher url="/api/users">
    {({ data, loading, error }) => {
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error.message}</div>;
      
      return (
        <ul>
          {data?.map(user => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      );
    }}
  </DataFetcher>
);
```

## Component Architecture Principles

### Design Guidelines
- **Single Responsibility** - Each component should have one clear purpose
- **Composition over Inheritance** - Build complex UIs by combining simple components
- **Props for Configuration** - Make components flexible and reusable through props
- **Reactive Data Flow** - Use signals for automatic UI updates
- **Predictable Interface** - Component APIs should be intuitive and consistent

### State Management Strategies

**Local State** - For component-specific data:
```jsx
const ToggleSwitch = ({ onToggle }) => {
  const isOn = signal(false); // Local to this component
  
  const handleToggle = () => {
    isOn(!isOn());
    onToggle?.(isOn());
  };
  
  return (
    <button 
      class={`toggle ${isOn() ? 'on' : 'off'}`}
      onclick={handleToggle}
    >
      {isOn() ? 'ON' : 'OFF'}
    </button>
  );
};
```

**Shared State** - For data used across components:
```jsx
// Shared across app
const theme = signal('light');
const user = signal(null);

const Header = () => (
  <header class={`header theme-${theme()}`}>
    {user() ? `Welcome, ${user().name}` : 'Please log in'}
  </header>
);
```

**Store State** - For complex, structured data:
```jsx
import { store } from '@hellajs/store';

const cartStore = store({
  items: [],
  
  get total() {
    return this.items.reduce((sum, item) => sum + item.price, 0);
  },
  
  addItem(item) {
    this.items.push(item);
  }
});
```

### Performance Optimization

**Efficient Signal Usage:**
```jsx
// ✅ Good - computed values cache results
const ExpensiveList = ({ items }) => {
  const sortedItems = computed(() => 
    items().sort((a, b) => a.name.localeCompare(b.name))
  );
  
  return (
    <ul>
      {sortedItems().map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
};

// ❌ Avoid - computation runs on every render
const InefficientList = ({ items }) => {
  const sortedItems = items().sort((a, b) => a.name.localeCompare(b.name));
  
  return (
    <ul>
      {sortedItems.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
};
```

**Component Splitting:**
```jsx
// ✅ Good - small, focused components
const UserCard = ({ user }) => (
  <div class="user-card">
    <UserAvatar src={user().avatar} name={user().name} />
    <UserInfo user={user} />
    <UserActions userId={user().id} />
  </div>
);

// ❌ Avoid - monolithic components
const MassiveUserComponent = ({ user }) => {
  // 200+ lines of mixed concerns
};
```

### Code Organization Patterns

**Component Composition:**
```jsx
const Button = ({ variant = 'primary', size = 'md', children, ...props }) => (
  <button class={`btn btn-${variant} btn-${size}`} {...props}>
    {children}
  </button>
);

const IconButton = ({ icon, ...props }) => (
  <Button variant="icon" {...props}>
    <i class={`icon-${icon}`} />
  </Button>
);

const SaveButton = ({ onSave, disabled }) => (
  <IconButton 
    icon="save" 
    onclick={onSave} 
    disabled={disabled}
    title="Save changes"
  >
    Save
  </IconButton>
);
```

**Error Boundaries:**
```jsx
const ErrorBoundary = ({ fallback, children }) => {
  const error = signal(null);
  
  const handleError = (err) => {
    console.error('Component error:', err);
    error(err);
  };
  
  if (error()) {
    return fallback ? fallback(error()) : (
      <div class="error-fallback">
        <h3>Something went wrong</h3>
        <button onclick={() => error(null)}>Try Again</button>
      </div>
    );
  }
  
  // In a real implementation, you'd wire this to catch component errors
  return children;
};
```

## Component Testing Strategies

### Testing Component Logic

```jsx
// Component
const Counter = ({ initialValue = 0 }) => {
  const count = signal(initialValue);
  const increment = () => count(count() + 1);
  
  return (
    <div>
      <span data-testid="count">{count}</span>
      <button data-testid="increment" onclick={increment}>+</button>
    </div>
  );
};

// Test
test('counter increments when button clicked', () => {
  const counter = <Counter initialValue={5} />;
  
  // Mount and test
  const countElement = counter.querySelector('[data-testid="count"]');
  const buttonElement = counter.querySelector('[data-testid="increment"]');
  
  expect(countElement.textContent).toBe('5');
  
  buttonElement.click();
  expect(countElement.textContent).toBe('6');
});
```

### Testing with External State

```jsx
// Test with shared signals
test('component responds to external state changes', () => {
  const sharedCount = signal(10);
  
  const Component = () => (
    <div data-testid="display">{sharedCount}</div>
  );
  
  const component = <Component />;
  const display = component.querySelector('[data-testid="display"]');
  
  expect(display.textContent).toBe('10');
  
  sharedCount(20);
  expect(display.textContent).toBe('20');
});
```

## Common Patterns and Anti-Patterns

### ✅ Good Patterns

**Predictable Props Interface:**
```jsx
const Modal = ({ 
  isOpen, 
  onClose, 
  title, 
  children, 
  size = 'md',
  closable = true 
}) => {
  if (!isOpen()) return null;
  
  return (
    <div class="modal-overlay" onclick={onClose}>
      <div class={`modal modal-${size}`} onclick={e => e.stopPropagation()}>
        <header class="modal-header">
          <h2>{title}</h2>
          {closable && <button onclick={onClose}>×</button>}
        </header>
        <div class="modal-content">{children}</div>
      </div>
    </div>
  );
};
```

**Controlled vs Uncontrolled Components:**
```jsx
// Controlled - parent manages state
const ControlledInput = ({ value, onchange, placeholder }) => (
  <input 
    value={value} 
    oninput={e => onchange(e.target.value)}
    placeholder={placeholder}
  />
);

// Uncontrolled - manages own state
const UncontrolledInput = ({ defaultValue, onsubmit, placeholder }) => {
  const value = signal(defaultValue || '');
  
  const handleSubmit = () => {
    onsubmit(value());
    value('');
  };
  
  return (
    <div>
      <input 
        value={value}
        oninput={e => value(e.target.value)}
        placeholder={placeholder}
        onkeydown={e => e.key === 'Enter' && handleSubmit()}
      />
      <button onclick={handleSubmit}>Submit</button>
    </div>
  );
};
```

### ❌ Anti-Patterns to Avoid

**Don't create signals inside render:**
```jsx
// ❌ Wrong - creates new signal on every render
const BadComponent = ({ data }) => {
  const processedData = signal(expensiveOperation(data)); // Wrong!
  
  return <div>{processedData}</div>;
};

// ✅ Correct - use computed for derived state
const GoodComponent = ({ data }) => {
  const processedData = computed(() => expensiveOperation(data()));
  
  return <div>{processedData}</div>;
};
```

**Don't mutate props:**
```jsx
// ❌ Wrong - mutating props
const BadComponent = ({ items }) => {
  items().push(newItem); // Don't mutate!
  return <ul>{items().map(item => <li>{item}</li>)}</ul>;
};

// ✅ Correct - create new state
const GoodComponent = ({ items }) => {
  const localItems = signal([...items(), newItem]);
  return <ul>{localItems().map(item => <li>{item}</li>)}</ul>;
};
```

## Next Steps

Now that you understand HellaJS components deeply, explore these related topics:

### Foundation Concepts
- **[Reactivity](/learn/concepts/reactivity)** - Master signals, computed, and effects
- **[State Management](/learn/concepts/state)** - Organize state in larger applications
- **[Styling](/learn/concepts/styling)** - Add CSS and dynamic styles to components

### Practical Application
- **[Counter Tutorial](/learn/tutorials/counter-app)** - Build your first interactive component
- **[Todo App Tutorial](/learn/tutorials/todo-app)** - Create a complete application
- **[Performance](/learn/concepts/performance)** - Optimize component rendering

### Advanced Integration
- **[Resources](/learn/concepts/resources)** - Handle async data in components
- **[Routing](/learn/concepts/routing)** - Build multi-page component applications