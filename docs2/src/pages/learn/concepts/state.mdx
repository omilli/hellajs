---
layout: ../../../layouts/MainLayout.astro
title: State Management
description: Strategies for managing state in HellaJS applications.
---

# State Management

As applications grow, managing state becomes critical. HellaJS provides multiple state management patterns, from simple local state to complex application stores, so you can choose the right approach for each situation.

## Choosing Your State Strategy

Different scenarios require different state management approaches:

| **Use Case** | **Best Approach** | **Example** |
|--------------|-------------------|-------------|
| **Component UI state** | Local signals | Toggle buttons, form inputs, loading states |
| **Shared simple state** | Module-level signals | Current user, theme, simple global flags |
| **Complex nested state** | Stores | Shopping carts, user profiles, app configuration |
| **Async data** | Resources | API data, real-time updates |

## The Decision Framework

```jsx
// Ask yourself: "Who needs this state?"

// ðŸ  One component only â†’ Use local signals
const Toggle = () => {
  const isOn = signal(false);
  return <button onclick={() => isOn(!isOn())}>{isOn() ? 'On' : 'Off'}</button>;
};

// ðŸŒ Multiple components â†’ Use shared signals  
const globalTheme = signal('light');

// ðŸ¢ Complex related data â†’ Use stores
const userStore = store({ profile: {...}, preferences: {...} });
```

## Local Component State

Use signals for state that belongs to a single component:

### Simple Local State

```jsx
const Counter = () => {
  const count = signal(0);
  const isEven = computed(() => count() % 2 === 0);
  
  return (
    <div>
      <p>Count: {count} ({isEven() ? 'even' : 'odd'})</p>
      <button onclick={() => count(count() + 1)}>+</button>
      <button onclick={() => count(count() - 1)}>-</button>
      <button onclick={() => count(0)}>Reset</button>
    </div>
  );
};
```

### Form State

```jsx
const ContactForm = () => {
  const name = signal('');
  const email = signal('');
  const message = signal('');
  const isSubmitting = signal(false);
  
  const isValid = computed(() => 
    name().trim() && email().includes('@') && message().trim()
  );
  
  const handleSubmit = async () => {
    if (!isValid()) return;
    
    isSubmitting(true);
    try {
      await fetch('/api/contact', {
        method: 'POST',
        body: JSON.stringify({ name: name(), email: email(), message: message() })
      });
      // Reset form on success
      name(''); email(''); message('');
    } finally {
      isSubmitting(false);
    }
  };
  
  return (
    <form onsubmit={e => { e.preventDefault(); handleSubmit(); }}>
      <input value={name} oninput={e => name(e.target.value)} placeholder="Name" />
      <input value={email} oninput={e => email(e.target.value)} placeholder="Email" />
      <textarea value={message} oninput={e => message(e.target.value)} placeholder="Message" />
      <button type="submit" disabled={!isValid() || isSubmitting()}>
        {isSubmitting() ? 'Sending...' : 'Send Message'}
      </button>
    </form>
  );
};
```

## Shared State Across Components

When multiple components need the same state, define it at the module level:

### Simple Shared State

```jsx
// stores/theme.js
import { signal } from '@hellajs/core';

export const theme = signal('light');
export const toggleTheme = () => {
  theme(theme() === 'light' ? 'dark' : 'light');
};

// Apply theme to document
effect(() => {
  document.documentElement.setAttribute('data-theme', theme());
});
```

```jsx
// components/ThemeToggle.jsx
import { theme, toggleTheme } from '../stores/theme.js';

export const ThemeToggle = () => (
  <button onclick={toggleTheme}>
    Switch to {theme() === 'light' ? 'dark' : 'light'} mode
  </button>
);
```

```jsx
// components/Header.jsx
import { theme } from '../stores/theme.js';

export const Header = () => (
  <header class={`header theme-${theme()}`}>
    <h1>My App</h1>
  </header>
);
```

### Shared State with Logic

```jsx
// stores/auth.js
import { signal, computed } from '@hellajs/core';

export const user = signal(null);
export const isLoggedIn = computed(() => !!user());
export const isAdmin = computed(() => user()?.role === 'admin');

export const login = async (credentials) => {
  const response = await fetch('/api/login', {
    method: 'POST',
    body: JSON.stringify(credentials)
  });
  const userData = await response.json();
  user(userData);
};

export const logout = () => {
  user(null);
};

// Persist login state
effect(() => {
  if (user()) {
    localStorage.setItem('user', JSON.stringify(user()));
  } else {
    localStorage.removeItem('user');
  }
});
```

## Complex State with Stores

For complex, nested state objects with related data and methods, use stores:

### Creating a Store

```jsx
import { store } from '@hellajs/store';

const userStore = store({
  // State properties
  profile: {
    name: 'John Doe',
    email: 'john@example.com',
    avatar: null
  },
  preferences: {
    theme: 'light',
    notifications: true,
    language: 'en'
  },
  isLoggedIn: false,
  loginAttempts: 0,

  // Computed getters - automatically reactive
  get displayName() {
    return this.profile.name || 'Guest';
  },
  
  get canLogin() {
    return this.loginAttempts < 3;
  },
  
  get isAdmin() {
    return this.profile.role === 'admin';
  },

  // Methods for state changes
  async login(credentials) {
    if (!this.canLogin) throw new Error('Too many login attempts');
    
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        body: JSON.stringify(credentials)
      });
      
      if (response.ok) {
        const userData = await response.json();
        this.profile = userData;
        this.isLoggedIn = true;
        this.loginAttempts = 0;
      } else {
        this.loginAttempts += 1;
        throw new Error('Invalid credentials');
      }
    } catch (error) {
      this.loginAttempts += 1;
      throw error;
    }
  },

  logout() {
    this.profile = { name: '', email: '', avatar: null };
    this.isLoggedIn = false;
    this.loginAttempts = 0;
  },

  updateProfile(changes) {
    Object.assign(this.profile, changes);
  },

  updatePreferences(prefs) {
    Object.assign(this.preferences, prefs);
  }
});
```

### Using Stores in Components

```jsx
// All store properties are automatically reactive
const UserProfile = () => (
  <div class="user-profile">
    <h1>Welcome, {userStore.displayName}!</h1>
    
    {userStore.isLoggedIn ? (
      <div class="logged-in">
        <p>Email: {userStore.profile.email}</p>
        <p>Theme: {userStore.preferences.theme}</p>
        {userStore.isAdmin && <badge>Admin</badge>}
        
        <button onclick={() => userStore.preferences.theme = 
          userStore.preferences.theme === 'light' ? 'dark' : 'light'
        }>
          Switch Theme
        </button>
        
        <button onclick={() => userStore.logout()}>
          Logout
        </button>
      </div>
    ) : (
      <div class="logged-out">
        <p>Please log in</p>
        <LoginForm store={userStore} />
      </div>
    )}
  </div>
);

const LoginForm = ({ store }) => {
  const email = signal('');
  const password = signal('');
  const isLoading = signal(false);
  const error = signal(null);
  
  const handleSubmit = async () => {
    isLoading(true);
    error(null);
    
    try {
      await store.login({ email: email(), password: password() });
    } catch (err) {
      error(err.message);
    } finally {
      isLoading(false);
    }
  };
  
  return (
    <form onsubmit={e => { e.preventDefault(); handleSubmit(); }}>
      {error() && <div class="error">{error()}</div>}
      {!store.canLogin && <div class="error">Too many failed attempts</div>}
      
      <input 
        value={email} 
        oninput={e => email(e.target.value)} 
        placeholder="Email" 
        disabled={isLoading()}
      />
      <input 
        type="password"
        value={password} 
        oninput={e => password(e.target.value)} 
        placeholder="Password"
        disabled={isLoading()}
      />
      <button type="submit" disabled={isLoading() || !store.canLogin}>
        {isLoading() ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
};
```

### Global Application Store

Create a centralized store for app-wide state and functionality:

```jsx
// stores/app.js
import { store } from '@hellajs/store';

export const appStore = store({
  // Core app state
  user: null,
  theme: 'light',
  notifications: [],
  isOnline: true,
  currentRoute: '/',
  sidebarOpen: false,
  
  // Loading states
  loading: {
    user: false,
    notifications: false,
    general: false
  },

  // Computed getters
  get isLoggedIn() {
    return !!this.user;
  },

  get unreadNotifications() {
    return this.notifications.filter(n => !n.read).length;
  },
  
  get isLoading() {
    return Object.values(this.loading).some(Boolean);
  },

  // User actions
  setUser(user) {
    this.user = user;
  },
  
  async loadUserData() {
    this.loading.user = true;
    try {
      const response = await fetch('/api/user');
      if (response.ok) {
        const userData = await response.json();
        this.setUser(userData);
      }
    } finally {
      this.loading.user = false;
    }
  },

  // Theme actions
  setTheme(theme) {
    this.theme = theme;
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
  },
  
  toggleTheme() {
    this.setTheme(this.theme === 'light' ? 'dark' : 'light');
  },

  // Notification actions
  addNotification(notification) {
    this.notifications.unshift({
      id: Date.now(),
      ...notification,
      read: false,
      timestamp: new Date(),
      type: notification.type || 'info'
    });
    
    // Auto-remove after 5 seconds for success messages
    if (notification.type === 'success') {
      setTimeout(() => this.removeNotification(notification.id), 5000);
    }
  },

  markNotificationRead(id) {
    const notification = this.notifications.find(n => n.id === id);
    if (notification) notification.read = true;
  },
  
  removeNotification(id) {
    const index = this.notifications.findIndex(n => n.id === id);
    if (index > -1) this.notifications.splice(index, 1);
  },
  
  clearAllNotifications() {
    this.notifications = [];
  },

  // UI actions
  toggleSidebar() {
    this.sidebarOpen = !this.sidebarOpen;
  },
  
  setRoute(route) {
    this.currentRoute = route;
    this.sidebarOpen = false; // Auto-close sidebar on navigation
  },
  
  // Network status
  setOnlineStatus(online) {
    this.isOnline = online;
    if (!online) {
      this.addNotification({ 
        type: 'warning', 
        message: 'You are offline. Some features may not work.' 
      });
    }
  }
});

// Initialize app store
if (typeof window !== 'undefined') {
  // Load saved theme
  const savedTheme = localStorage.getItem('theme');
  if (savedTheme) appStore.setTheme(savedTheme);
  
  // Monitor online status
  window.addEventListener('online', () => appStore.setOnlineStatus(true));
  window.addEventListener('offline', () => appStore.setOnlineStatus(false));
  
  // Load user data if not already loaded
  if (!appStore.user) appStore.loadUserData();
}
```

## Advanced State Patterns

### State Synchronization

Keep different types of state synchronized:

```jsx
// Sync with URL parameters
const ProductFilter = () => {
  const urlParams = new URLSearchParams(window.location.search);
  const category = signal(urlParams.get('category') || 'all');
  const search = signal(urlParams.get('search') || '');
  
  // Sync URL when filters change
  effect(() => {
    const url = new URL(window.location);
    if (category() !== 'all') {
      url.searchParams.set('category', category());
    } else {
      url.searchParams.delete('category');
    }
    
    if (search().trim()) {
      url.searchParams.set('search', search());
    } else {
      url.searchParams.delete('search');
    }
    
    window.history.replaceState({}, '', url);
  });

  return (
    <div class="filters">
      <input
        value={search}
        oninput={e => search(e.target.value)}
        placeholder="Search..."
      />
      <select value={category} onchange={e => category(e.target.value)}>
        <option value="all">All Categories</option>
        <option value="electronics">Electronics</option>
        <option value="clothing">Clothing</option>
      </select>
    </div>
  );
};
```

### Performance Optimization

Use computed values for expensive operations:

```jsx
const DataDashboard = () => {
  const rawData = signal([]);
  const filters = signal({ category: 'all', dateRange: 'month' });
  const sortBy = signal('date');
  
  // Expensive filtering - only recalculates when dependencies change
  const filteredData = computed(() => {
    let data = rawData();
    const { category, dateRange } = filters();
    
    // Filter by category
    if (category !== 'all') {
      data = data.filter(item => item.category === category);
    }
    
    // Filter by date range
    const now = new Date();
    const cutoff = new Date();
    if (dateRange === 'week') cutoff.setDate(now.getDate() - 7);
    else if (dateRange === 'month') cutoff.setMonth(now.getMonth() - 1);
    else if (dateRange === 'year') cutoff.setFullYear(now.getFullYear() - 1);
    
    return data.filter(item => new Date(item.date) >= cutoff);
  });
  
  // Expensive sorting - only recalculates when data or sort changes
  const sortedData = computed(() => {
    const data = [...filteredData()];
    const sort = sortBy();
    
    return data.sort((a, b) => {
      if (sort === 'date') return new Date(b.date) - new Date(a.date);
      if (sort === 'value') return b.value - a.value;
      return a.name.localeCompare(b.name);
    });
  });
  
  // Expensive calculations - cached until data changes
  const stats = computed(() => {
    const data = filteredData();
    return {
      total: data.length,
      sum: data.reduce((sum, item) => sum + item.value, 0),
      average: data.length > 0 ? data.reduce((sum, item) => sum + item.value, 0) / data.length : 0,
      max: Math.max(...data.map(item => item.value)),
      min: Math.min(...data.map(item => item.value))
    };
  });
  
  return (
    <div class="dashboard">
      <div class="stats">
        <div>Total: {stats().total}</div>
        <div>Sum: {stats().sum}</div>
        <div>Average: {stats().average.toFixed(2)}</div>
      </div>
      
      <div class="controls">
        <select 
          value={filters().category} 
          onchange={e => filters({ ...filters(), category: e.target.value })}
        >
          <option value="all">All Categories</option>
          <option value="sales">Sales</option>
          <option value="support">Support</option>
        </select>
        
        <select value={sortBy} onchange={e => sortBy(e.target.value)}>
          <option value="date">Sort by Date</option>
          <option value="value">Sort by Value</option>
          <option value="name">Sort by Name</option>
        </select>
      </div>
      
      <div class="data-list">
        {sortedData().map(item => (
          <div key={item.id} class="data-item">
            <h3>{item.name}</h3>
            <p>Value: {item.value}</p>
            <p>Date: {new Date(item.date).toLocaleDateString()}</p>
          </div>
        ))}
      </div>
    </div>
  );
};
```

## State Management Best Practices

### Choosing the Right Tool

| **Scenario** | **Use** | **Why** |
|--------------|---------|----------|
| Component UI state (visible, editing, focused) | `signal()` | Simple, local, contained |
| Form state (inputs, validation) | `signal()` or local store | Easy to manage, clear ownership |
| User authentication, app theme | Shared signals | Simple global state, few dependencies |
| Shopping cart, user profile | `store()` | Complex related data, multiple actions |
| Real-time data, API cache | `resource()` | Async data with loading/error states |

### Organization Patterns

```jsx
// âœ… Good - organized by domain
stores/
  auth.js       // User authentication state
  cart.js       // Shopping cart state  
  ui.js         // Global UI state (theme, sidebar)
  api.js        // API cache and loading states

// âœ… Good - clear separation
const ShoppingCart = () => {
  // Local UI state
  const isOpen = signal(false);
  const isAnimating = signal(false);
  
  // Global cart data
  const { items, total, addItem, removeItem } = useCartStore();
  
  return (
    <div class={`cart ${isOpen() ? 'open' : ''}`}>
      {/* ... */}
    </div>
  );
};
```

### Performance Tips

- **Use computed for expensive operations** - they're cached and only recalculate when dependencies change
- **Break complex state into focused pieces** - smaller, targeted reactivity
- **Use batch() for related updates** - prevents intermediate states
- **Keep stores focused** - don't put everything in one giant store

### Common Pitfalls to Avoid

```jsx
// âŒ Don't put everything in global state
const globalStore = store({
  user: {},
  cart: {},
  ui: {},
  forms: {},
  api: {},
  // ... becomes unmaintainable
});

// âœ… Do organize by domain
const userStore = store({ /* user stuff */ });
const cartStore = store({ /* cart stuff */ });
const uiStore = store({ /* ui stuff */ });

// âŒ Don't use stores for simple local state
const Component = () => {
  const localStore = store({ isVisible: false }); // Overkill
  
// âœ… Do use simple signals for simple state
const Component = () => {
  const isVisible = signal(false); // Perfect
```

## Next Steps

Now that you understand HellaJS state management, explore these related topics:

- **[Reactivity](/learn/concepts/reactivity)** - Deep dive into signals, computed, and effects
- **[Resources](/learn/concepts/resources)** - Managing async data and API calls
- **[Todo Tutorial](/learn/tutorials/todo-app)** - Build a complete app with state management
- **[Performance](/learn/concepts/performance)** - Optimizing state for large applications