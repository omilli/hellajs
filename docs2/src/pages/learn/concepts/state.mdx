---
layout: ../../../layouts/MainLayout.astro
title: State Management
description: State management patterns from local signals to complex application stores.
---

import { Icon } from "astro-icon/components";

# Fine-Grained State Management

The HellaJS store package provides sophisticated state management patterns that scale from simple component state to complex application architectures. Built on the reactive core, stores deliver fine-grained updates where only the specific properties that change trigger re-computation, eliminating the performance penalties of monolithic state updates.

<div role="alert" class="alert alert-info alert-soft text-base">
  <Icon name="ph:info" width={24} height={24} />
  <span>Stores are reactive objects where each property is individually trackable, enabling surgical updates.</span>
</div>

## Store Fundamentals

### Creating Stores

[`store(initial)`](/reference/store/store) creates reactive objects with fine-grained property tracking. Unlike signals that treat entire objects atomically, stores make each property independently reactive.

```js
import { store } from '@hellajs/store';

// Create a reactive store
const counter = store({
  count: 0,
  step: 1,
  max: 10
});

// Each property is individually reactive
console.log(counter.count()); // 0
console.log(counter.step());  // 1
console.log(counter.max());   // 10
```

### Property Access

Store properties behave like signals - call them to read values, call them with arguments to set values:

```js
const counter = store({
  count: 0,
  label: 'Counter'
});

// Reading values
const currentCount = counter.count();
const currentLabel = counter.label();

// Setting values (triggers only dependent computations)
counter.count(5);
counter.label('Advanced Counter');

// Individual property updates
counter.count(counter.count() + 1); // Only count-dependent code runs
```
### Complete Update
```js
const counter = store({
  count: 0,
  label: 'Counter'
});

// Complete update - replaces entire store object
counter({
  count: 10,
  label: 'Updated Counter'
});
```


### Partial Updates

The `update()` method allows partial updates to store properties:

```js
const user = store({
  name: 'John',
  email: 'john@example.com',
  age: 30,
  address: {
    street: '123 Main St',
    city: 'Anytown',
    zip: '12345'
  }
});

// Partial update - only updates specified properties
user.update({
  age: 31,
  address: {
    city: 'New City' // Merges with existing address
  }
});
```


## Advanced Patterns

### Nested Stores

Stores can contain other stores, creating hierarchical state structures with fine-grained reactivity at every level:

```js
const appState = store({
  user: store({
    name: 'John Doe',
    email: 'john@example.com',
    preferences: store({
      theme: 'dark',
      language: 'en',
      notifications: true
    })
  }),
  ui: store({
    sidebarOpen: false,
    activeTab: 'dashboard',
    loading: false
  })
});

// Access nested properties
console.log(appState.user.name()); // 'John Doe'
console.log(appState.user.preferences.theme()); // 'dark'

// Update nested properties - only affects dependent computations
appState.user.preferences.theme('light');
appState.ui.sidebarOpen(true);
```

### Readonly Properties

Control which properties can be modified using readonly options:

```js
// Specific readonly properties
const config = store({
  apiUrl: 'https://api.example.com',
  version: '1.0.0',
  debug: true
}, { 
  readonly: ['apiUrl', 'version'] 
});

config.debug(false); // ✅ Allowed
config.apiUrl('new-url'); // ❌ Runtime error - readonly

// All properties readonly
const constants = store({
  PI: 3.14159,
  MAX_USERS: 100
}, { readonly: true });
```

### Store Composition

Compose multiple stores for modular state management:

```js
const createUserStore = (initialUser) => store({
  ...initialUser,
  isLoggedIn: !!initialUser.id,
  login: (credentials) => {
    // Login logic
  },
  logout: () => {
    // Logout logic  
  }
});

const createUIStore = () => store({
  theme: 'light',
  sidebarOpen: false,
  notifications: [],
  toggleTheme: () => {
    // Theme toggle logic
  }
});

const createAppStore = (user) => {
  const userStore = createUserStore(user);
  const uiStore = createUIStore();
  
  return store({
    user: userStore,
    ui: uiStore,
    
    // Cross-store computed values
    canAccessAdmin: computed(() => 
      userStore.isLoggedIn() && userStore.role() === 'admin'
    )
  });
};
```

## Performance Optimizations

### Computed Values

Store properties can be computed values for derived state:

```js
const inventory = store({
  items: [
    { id: 1, name: 'Widget', price: 10, quantity: 5 },
    { id: 2, name: 'Gadget', price: 25, quantity: 2 }
  ],
  
  // Computed properties
  totalValue: computed(() => 
    inventory.items().reduce((sum, item) => 
      sum + (item.price * item.quantity), 0
    )
  ),
  
  lowStockItems: computed(() =>
    inventory.items().filter(item => item.quantity < 3)
  )
});

console.log(inventory.totalValue()); // 100
console.log(inventory.lowStockItems()); // [{ id: 2, ... }]
```

### Batched Updates

Use `batch()` for multiple store updates:

```js
import { batch } from '@hellajs/core';

const updateUser = (updates) => {
  batch(() => {
    user.name(updates.name);
    user.email(updates.email);
    user.lastUpdated(new Date());
  });
  // All dependent computations run once after batch
};
```

### Memory Management

Stores provide cleanup methods for memory management:

```js
const subscription = effect(() => {
  console.log('User changed:', user.name());
});

const cleanup = () => {
  subscription(); // Clean up effect
  user.cleanup(); // Clean up store and nested reactive values
};
```

## Internal Mechanics
Understanding how stores work internally reveals the sophisticated mechanisms behind fine-grained reactivity.

#### Store Architecture

Each store is fundamentally a **reactive proxy** that intercepts property access and converts object properties into individual reactive primitives. This architecture enables surgical updates where only the specific properties that change trigger re-computation.

```
Store Object
├── Property A → Signal<T>
├── Property B → Signal<T>  
└── Nested Store
    ├── Property C → Signal<T>
    └── Property D → Computed<T>
```

#### Property Transformation

When a store is created, the system transforms each property based on its type and characteristics:

- **Primitive values** (strings, numbers, booleans) become individual signals
- **Objects and arrays** become nested stores with recursive property transformation  
- **Functions** remain as-is, preserving their original behavior
- **Computed expressions** maintain their reactive computation capabilities

This transformation process occurs once during store creation, establishing a permanent reactive structure that efficiently handles all subsequent updates.

#### Dependency Graph Integration

Store properties integrate seamlessly with the core reactive dependency graph. Each property signal maintains its own set of dependencies and subscribers, creating a distributed network where changes propagate only through the specific paths that need updates.

```
Signal Property → Computed Values → Effects
       ↑                ↑              ↑
  (individual)    (property-specific)  (targeted)
```

This distributed approach eliminates the cascade re-computation problems common in monolithic state systems, where changing any property forces re-evaluation of all dependent code.

#### Reactive Property Binding

Store properties use the same **function reference binding** system as the templating engine. When a store property is used in a template or computed value, the system establishes a direct reactive link without intermediate wrapper objects or proxy layers.

```js
// Direct reactive binding
const displayName = computed(() => user.name());

// Template binding
<h1>{user.name}</h1> // Automatically reactive
```

#### Update Propagation

Store updates follow the same efficient propagation mechanism as the core reactive system:

1. **Property Change** - A store property is updated via setter
2. **Dependency Marking** - Only computations dependent on that specific property are marked dirty
3. **Selective Propagation** - Changes propagate only through affected dependency chains
4. **Lazy Evaluation** - Computed values recalculate only when accessed AND dependencies changed
5. **Effect Execution** - Effects run immediately for properties they depend on

#### Memory Efficiency

The store system includes several memory optimization strategies:

- **Property Reuse** - Reactive primitives are reused across property access patterns
- **Lazy Initialization** - Nested stores are created only when properties are first accessed
- **Automatic Cleanup** - The cleanup system recursively disposes of all nested reactive values
- **Reference Management** - Circular references are prevented through careful property definition

#### Immutability Support

While stores provide mutable interfaces for developer convenience, they maintain compatibility with immutable update patterns. The `update()` method performs shallow merging that respects the reactive system's change detection while preserving the convenience of partial updates.

This design creates a state management system that scales efficiently from simple component state to complex application architectures, delivering predictable performance characteristics and memory usage regardless of state complexity.