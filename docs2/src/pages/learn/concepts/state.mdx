---
layout: ../../../layouts/MainLayout.astro
title: State Management
description: State management patterns from local signals to complex application stores.
---

# State Management

Managing state effectively becomes crucial as applications grow. HellaJS offers multiple state management patterns to fit different scenarios.

## Choosing Your State Strategy

Different scenarios require different state management approaches:

| **Use Case** | **Best Approach** | **Example** |
|--------------|-------------------|-------------|
| **Component UI state** | Local signals | Toggle buttons, form inputs, loading states |
| **Shared simple state** | Module-level signals | Current user, theme, simple global flags |
| **Complex nested state** | Stores | Shopping carts, user profiles, app configuration |
| **Async data** | Resources | API data, real-time updates |

## The Decision Framework

```jsx
// Ask yourself: "Who needs this state?"

// üè† One component only ‚Üí Use local signals
const Toggle = () => {
  const isOn = signal(false);
  return <button onclick={() => isOn(!isOn())}>{isOn() ? 'On' : 'Off'}</button>;
};

// üåç Multiple components ‚Üí Use shared signals  
const globalTheme = signal('light');

// üè¢ Complex related data ‚Üí Use stores
const userStore = store({ profile: {...}, preferences: {...} });
```

## Local Component State

Use signals for state that belongs to a single component:

### Simple Local State

```jsx
const Counter = () => {
  const count = signal(0);
  const isEven = computed(() => count() % 2 === 0);
  
  return (
    <div>
      <p>Count: {count} ({isEven() ? 'even' : 'odd'})</p>
      <button onclick={() => count(count() + 1)}>+</button>
      <button onclick={() => count(count() - 1)}>-</button>
      <button onclick={() => count(0)}>Reset</button>
    </div>
  );
};
```

### Form State

```jsx
const ContactForm = () => {
  const name = signal('');
  const email = signal('');
  const message = signal('');
  const isSubmitting = signal(false);
  
  const isValid = computed(() => 
    name().trim() && email().includes('@') && message().trim()
  );
  
  const handleSubmit = async () => {
    if (!isValid()) return;
    
    isSubmitting(true);
    try {
      await fetch('/api/contact', {
        method: 'POST',
        body: JSON.stringify({ name: name(), email: email(), message: message() })
      });
      // Reset form on success
      name(''); email(''); message('');
    } finally {
      isSubmitting(false);
    }
  };
  
  return (
    <form onsubmit={e => { e.preventDefault(); handleSubmit(); }}>
      <input value={name} oninput={e => name(e.target.value)} placeholder="Name" />
      <input value={email} oninput={e => email(e.target.value)} placeholder="Email" />
      <textarea value={message} oninput={e => message(e.target.value)} placeholder="Message" />
      <button type="submit" disabled={!isValid() || isSubmitting()}>
        {isSubmitting() ? 'Sending...' : 'Send Message'}
      </button>
    </form>
  );
};
```

## Shared State Across Components

When multiple components need the same state, define it at the module level:

### Simple Shared State

```jsx
// stores/theme.js
import { signal } from '@hellajs/core';

export const theme = signal('light');
export const toggleTheme = () => {
  theme(theme() === 'light' ? 'dark' : 'light');
};

// Apply theme to document
effect(() => {
  document.documentElement.setAttribute('data-theme', theme());
});
```

```jsx
// components/ThemeToggle.jsx
import { theme, toggleTheme } from '../stores/theme.js';

export const ThemeToggle = () => (
  <button onclick={toggleTheme}>
    Switch to {theme() === 'light' ? 'dark' : 'light'} mode
  </button>
);
```

```jsx
// components/Header.jsx
import { theme } from '../stores/theme.js';

export const Header = () => (
  <header class={`header theme-${theme()}`}>
    <h1>My App</h1>
  </header>
);
```

### Shared State with Logic

```jsx
// stores/auth.js
import { signal, computed } from '@hellajs/core';

export const user = signal(null);
export const isLoggedIn = computed(() => !!user());
export const isAdmin = computed(() => user()?.role === 'admin');

export const login = async (credentials) => {
  const response = await fetch('/api/login', {
    method: 'POST',
    body: JSON.stringify(credentials)
  });
  const userData = await response.json();
  user(userData);
};

export const logout = () => {
  user(null);
};

// Persist login state
effect(() => {
  if (user()) {
    localStorage.setItem('user', JSON.stringify(user()));
  } else {
    localStorage.removeItem('user');
  }
});
```

## Complex State with Stores

For complex, nested state objects with related data and methods, use stores:

### Creating a Store

```jsx
import { store } from '@hellajs/store';

const userStore = store({
  // State properties
  profile: {
    name: 'John Doe',
    email: 'john@example.com',
    avatar: null
  },
  preferences: {
    theme: 'light',
    notifications: true,
    language: 'en'
  },
  isLoggedIn: false,
  loginAttempts: 0,

  // Computed getters - automatically reactive
  get displayName() {
    return this.profile.name || 'Guest';
  },
  
  get canLogin() {
    return this.loginAttempts < 3;
  },
  
  get isAdmin() {
    return this.profile.role === 'admin';
  },

  // Methods for state changes
  async login(credentials) {
    if (!this.canLogin) throw new Error('Too many login attempts');
    
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        body: JSON.stringify(credentials)
      });
      
      if (response.ok) {
        const userData = await response.json();
        this.profile = userData;
        this.isLoggedIn = true;
        this.loginAttempts = 0;
      } else {
        this.loginAttempts += 1;
        throw new Error('Invalid credentials');
      }
    } catch (error) {
      this.loginAttempts += 1;
      throw error;
    }
  },

  logout() {
    this.profile = { name: '', email: '', avatar: null };
    this.isLoggedIn = false;
    this.loginAttempts = 0;
  },

  updateProfile(changes) {
    Object.assign(this.profile, changes);
  },

  updatePreferences(prefs) {
    Object.assign(this.preferences, prefs);
  }
});
```

### Using Stores in Components

```jsx
// All store properties are automatically reactive
const UserProfile = () => (
  <div class="user-profile">
    <h1>Welcome, {userStore.displayName}!</h1>
    
    {userStore.isLoggedIn ? (
      <div class="logged-in">
        <p>Email: {userStore.profile.email}</p>
        <p>Theme: {userStore.preferences.theme}</p>
        {userStore.isAdmin && <badge>Admin</badge>}
        
        <button onclick={() => userStore.preferences.theme = 
          userStore.preferences.theme === 'light' ? 'dark' : 'light'
        }>
          Switch Theme
        </button>
        
        <button onclick={() => userStore.logout()}>
          Logout
        </button>
      </div>
    ) : (
      <div class="logged-out">
        <p>Please log in</p>
        <LoginForm store={userStore} />
      </div>
    )}
  </div>
);

const LoginForm = ({ store }) => {
  const email = signal('');
  const password = signal('');
  const isLoading = signal(false);
  const error = signal(null);
  
  const handleSubmit = async () => {
    isLoading(true);
    error(null);
    
    try {
      await store.login({ email: email(), password: password() });
    } catch (err) {
      error(err.message);
    } finally {
      isLoading(false);
    }
  };
  
  return (
    <form onsubmit={e => { e.preventDefault(); handleSubmit(); }}>
      {error() && <div class="error">{error()}</div>}
      {!store.canLogin && <div class="error">Too many failed attempts</div>}
      
      <input 
        value={email} 
        oninput={e => email(e.target.value)} 
        placeholder="Email" 
        disabled={isLoading()}
      />
      <input 
        type="password"
        value={password} 
        oninput={e => password(e.target.value)} 
        placeholder="Password"
        disabled={isLoading()}
      />
      <button type="submit" disabled={isLoading() || !store.canLogin}>
        {isLoading() ? 'Logging in...' : 'Login'}
      </button>
    </form>
  );
};
```



## State Management Best Practices

### Choosing the Right Tool

| **Scenario** | **Use** | **Why** |
|--------------|---------|----------|
| Component UI state (visible, editing, focused) | `signal()` | Simple, local, contained |
| Form state (inputs, validation) | `signal()` or local store | Easy to manage, clear ownership |
| User authentication, app theme | Shared signals | Simple global state, few dependencies |
| Shopping cart, user profile | `store()` | Complex related data, multiple actions |
| Real-time data, API cache | `resource()` | Async data with loading/error states |

### Organization Patterns

```jsx
// ‚úÖ Good - organized by domain
stores/
  auth.js       // User authentication state
  cart.js       // Shopping cart state  
  ui.js         // Global UI state (theme, sidebar)
  api.js        // API cache and loading states

// ‚úÖ Good - clear separation
const ShoppingCart = () => {
  // Local UI state
  const isOpen = signal(false);
  const isAnimating = signal(false);
  
  // Global cart data
  const { items, total, addItem, removeItem } = useCartStore();
  
  return (
    <div class={`cart ${isOpen() ? 'open' : ''}`}>
      {/* ... */}
    </div>
  );
};
```

### Performance Tips

- **Use computed for expensive operations** - they're cached and only recalculate when dependencies change
- **Break complex state into focused pieces** - smaller, targeted reactivity
- **Use batch() for related updates** - prevents intermediate states
- **Keep stores focused** - don't put everything in one giant store

### Common Pitfalls to Avoid

```jsx
// ‚ùå Don't put everything in global state
const globalStore = store({
  user: {},
  cart: {},
  ui: {},
  forms: {},
  api: {},
  // ... becomes unmaintainable
});

// ‚úÖ Do organize by domain
const userStore = store({ /* user stuff */ });
const cartStore = store({ /* cart stuff */ });
const uiStore = store({ /* ui stuff */ });

// ‚ùå Don't use stores for simple local state
const Component = () => {
  const localStore = store({ isVisible: false }); // Overkill
  
// ‚úÖ Do use simple signals for simple state
const Component = () => {
  const isVisible = signal(false); // Perfect
```

## Next Steps

Now that you understand HellaJS state management, explore these related topics:

- **[Reactivity](/learn/concepts/reactivity)** - Deep dive into signals, computed, and effects
- **[Resources](/learn/concepts/resources)** - Managing async data and API calls
- **[Todo Tutorial](/learn/tutorials/todo-app)** - Build a complete app with state management
- **[Performance](/learn/concepts/performance)** - Optimizing state for large applications