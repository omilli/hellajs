---
layout: ../../../layouts/MainLayout.astro
title: Performance
description: Understanding HellaJS performance characteristics and optimization techniques.
---

# Performance

Most web frameworks struggle with performance as apps grow. HellaJS is designed to stay fast by default through fine-grained reactivity and zero overhead updates.

## How HellaJS Stays Fast

### The Traditional Framework Problem

**React and similar frameworks** re-render entire component trees on state changes:

```jsx
// React - entire list re-renders when one item changes
function UserList() {
  const [users, setUsers] = useState([...1000 users]);
  
  const toggleUser = (id) => {
    setUsers(users.map(user => 
      user.id === id ? {...user, online: !user.online} : user
    ));
  };

  console.log('UserList re-rendered!'); // Logs on every toggle
  
  return (
    <div>
      {users.map(user => (
        <UserItem key={user.id} user={user} onToggle={toggleUser} />
      ))}
    </div>
  );
}
```

This gets expensive with large lists, complex components, or frequent updates.

### HellaJS: Surgical Updates

**Only the exact DOM element that needs to change gets updated:**

```jsx
const UserList = () => {
  const users = signal([
    { id: 1, name: 'John', online: true },
    { id: 2, name: 'Jane', online: false }
  ]);

  const toggleUser = (id) => {
    const updated = users().map(user => 
      user.id === id ? { ...user, online: !user.online } : user
    );
    users(updated);
  };

  return (
    <div>
      {users().map(user => (
        <div key={user.id} onclick={() => toggleUser(user.id)}>
          {user.name} is {user.online ? 'online' : 'offline'}
        </div>
      ))}
    </div>
  );
};
```

> **Key Insight**: When you toggle one user, only that specific DOM element updates. No virtual DOM diffing, no component re-renders.

### Core Performance Characteristics

- **Fine-grained updates**: Only individual text nodes, attributes, and styles change
- **No re-rendering**: Component functions run once to set up structure
- **No virtual DOM**: Direct DOM manipulation eliminates diffing overhead
- **Minimal memory**: Lightweight signals with automatic cleanup
- **Cached computations**: Computed values shared across reactive dependencies

## Optimization Techniques

### Smart Caching with Computed

Use computed for expensive calculations that should only run when dependencies change:

```jsx
const ProductList = () => {
  const products = signal([]);
  const filters = signal({ category: 'all', minPrice: 0 });

  // Expensive filtering - only recalculates when dependencies change
  const filteredProducts = computed(() => {
    console.log('Filtering products...'); // Only logs when needed
    
    return products()
      .filter(p => filters().category === 'all' || p.category === filters().category)
      .filter(p => p.price >= filters().minPrice)
      .sort((a, b) => a.name.localeCompare(b.name));
  });

  return (
    <div>
      <input
        placeholder="Min price"
        type="number"
        value={filters().minPrice}
        oninput={e => filters({ ...filters(), minPrice: +e.target.value })}
      />
      
      <div>
        {filteredProducts().map(product => (
          <div key={product.id}>
            {product.name} - ${product.price}
          </div>
        ))}
      </div>
    </div>
  );
};
```

### Update Batching

Group related updates to avoid multiple render cycles:

```jsx
import { batch } from '@hellajs/core';

const UserForm = () => {
  const firstName = signal('');
  const lastName = signal('');
  const email = signal('');

  const loadUser = (userData) => {
    // Without batch: 3 separate update cycles
    // firstName(userData.firstName);
    // lastName(userData.lastName);
    // email(userData.email);

    // With batch: single update cycle
    batch(() => {
      firstName(userData.firstName);
      lastName(userData.lastName);
      email(userData.email);
    });
  };

  return (
    <form>
      <input value={firstName} oninput={e => firstName(e.target.value)} />
      <input value={lastName} oninput={e => lastName(e.target.value)} />
      <input value={email} oninput={e => email(e.target.value)} />
    </form>
  );
};
```

## Large-Scale Performance

### Virtualization for Large Lists

For very large datasets, render only visible items:

```jsx
const VirtualizedList = () => {
  const items = signal(Array.from({ length: 10000 }, (_, i) => ({ 
    id: i, 
    name: `Item ${i}` 
  })));
  
  const scrollTop = signal(0);
  const itemHeight = 50;
  const containerHeight = 400;
  
  const visibleItems = computed(() => {
    const startIndex = Math.floor(scrollTop() / itemHeight);
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + 1,
      items().length
    );
    
    return {
      startIndex,
      endIndex,
      items: items().slice(startIndex, endIndex),
      totalHeight: items().length * itemHeight
    };
  });

  return (
    <div 
      style={`height: ${containerHeight}px; overflow: auto;`}
      onscroll={e => scrollTop(e.target.scrollTop)}
    >
      <div style={`height: ${visibleItems().totalHeight}px; position: relative;`}>
        {visibleItems().items.map((item, index) => (
          <div
            key={item.id}
            style={`
              position: absolute;
              top: ${(visibleItems().startIndex + index) * itemHeight}px;
              height: ${itemHeight}px;
              width: 100%;
            `}
          >
            {item.name}
          </div>
        ))}
      </div>
    </div>
  );
};
```

### Avoiding Unnecessary Work

Structure code to minimize recalculation:

```jsx
// ❌ Inefficient - creates new objects on every render
const InefficientComponent = () => {
  const items = signal([]);
  
  return (
    <div>
      {items().map(item => (
        <div 
          key={item.id}
          style={{ color: item.priority === 'high' ? 'red' : 'black' }}
          onclick={() => handleClick({ item, timestamp: Date.now() })}
        >
          {item.name}
        </div>
      ))}
    </div>
  );
};

// ✅ Efficient - stable references and computed values
const EfficientComponent = () => {
  const items = signal([]);
  
  const itemStyles = computed(() => 
    items().reduce((acc, item) => {
      acc[item.id] = { color: item.priority === 'high' ? 'red' : 'black' };
      return acc;
    }, {})
  );
  
  const handleClick = (item) => {
    console.log('Clicked:', item.name, 'at', Date.now());
  };
  
  return (
    <div>
      {items().map(item => (
        <div 
          key={item.id}
          style={itemStyles()[item.id]}
          onclick={() => handleClick(item)}
        >
          {item.name}
        </div>
      ))}
    </div>
  );
};
```

## Performance Monitoring and Debugging

### Measuring Performance

Use the browser's Performance tab and add timing to reactive computations:

```jsx
const PerformanceMonitor = () => {
  const data = signal([]);
  
  const processedData = computed(() => {
    const start = performance.now();
    const result = expensiveOperation(data());
    const duration = performance.now() - start;
    
    if (duration > 16) { // Longer than one frame
      console.warn(`Slow computation: ${duration}ms`);
    }
    
    return result;
  });
  
  return <div>{processedData().length} items</div>;
};
```

### Common Performance Anti-Patterns

```jsx
// ❌ Don't create new functions in render paths
const BadExample = () => {
  const items = signal([]);
  return (
    <div>
      {items().map(item => (
        <button onclick={() => handleClick(item)}>{item.name}</button>
      ))}
    </div>
  );
};

// ✅ Create stable function references
const GoodExample = () => {
  const items = signal([]);
  const handleClick = (item) => console.log(item);
  
  return (
    <div>
      {items().map(item => (
        <button onclick={() => handleClick(item)}>{item.name}</button>
      ))}
    </div>
  );
};
```

## Best Practices for Performance

### Design for Speed
- **Use computed** for expensive calculations that depend on reactive state
- **Batch updates** when setting multiple signals at once
- **Choose appropriate granularity** - not too fine, not too coarse for signals
- **Always use keys** for dynamic lists to help with efficient updates
- **Prefer immutable updates** for arrays and objects to trigger proper reactivity

### Avoid Common Pitfalls
- **Don't create unnecessary reactive values** - static data doesn't need signals
- **Don't read signals in tight loops** - cache the value if used repeatedly
- **Don't ignore performance tools** - measure before optimizing
- **Don't create new objects in render** - move them outside or use computed

### Performance Patterns
- **Memoization**: Use computed for caching expensive operations
- **Debouncing**: Delay updates for rapid user input changes
- **Lazy loading**: Load data only when components need it
- **Code splitting**: Split large applications into smaller chunks
- **Resource optimization**: Set appropriate cache times for external data

## See Also

- [Reactivity](/learn/concepts/reactivity) - Understanding the reactive system
- [Components](/learn/concepts/components) - Component optimization techniques
- [Resources](/learn/concepts/resources) - Async data performance