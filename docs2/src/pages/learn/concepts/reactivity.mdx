---
layout: ../../../layouts/MainLayout.astro
title: Reactivity
description: Understanding fine-grained reactivity and core primitives.
---
import { Icon } from "astro-icon/components";


# Reactivity With Signals

The HellaJS core package is a reactive system that automatically tracks dependencies between data and computations. This lets you to build applications where changes in state automatically propagate, eliminating the need for manual subscriptions.

<div role="alert" class="alert alert-info alert-soft text-base">
  <Icon name="ph:info" width={24} height={24} />
  <span>The core package is a heavily modified fork of the excellent Alien Signals library.</span>
</div>

## Reactive Primitives

Three core primitives form the foundation of reactivity.

```js
// Create reactive state
const count = signal(0);

// Derive values automatically 
const doubled = computed(() => count() * 2);

// React to changes
effect(() => {
  console.log(`Count: ${count()}, Doubled: ${doubled()}`);
});

count(5); // Logs: "Count: 5, Doubled: 10"
```

### Signals - Reactive State

[`signal(value)`](/reference/core/signal) - Reactive containers that notify dependent computations when their value changes.

```js
const count = signal(0);

// Reading values (getter)
console.log(count()); // 0

// Setting values (setter) - triggers dependency updates
count(5);

// Update value
console.log(count()); // 5
```

### Computed - Derived Values

[`computed(fn)`](/reference/core/computed) - Derived values that automatically recompute when their dependencies change.

Computed values are lazily evaluated and cached, only recalculating when accessed AND their dependencies have changed.

```js
const count = signal(0);
const doubled = computed(() => count() * 2);

console.log(doubled()); // 0

count(5);

console.log(doubled()); // 10 - automatically recalculated
```

### Effects - Reactive Side Effects

[`effect(fn)`](/reference/core/effect) - Side effects that run immediately when reactive dependencies change. Unlike computed values, effects run eagerly.

```js
const count = signal(0);
const doubled = computed(() => count() * 2);

// Effect automatically tracks dependencies
effect(() => {
  console.log(`Count: ${count()}, Doubled: ${doubled()}`);
});

count(5); // Logs: "Count: 5, Doubled: 10"
```

## Working with Data

### Immutable Updates

Signals detect changes using reference equality (`===`), which means you must create new objects or arrays rather than mutating existing ones. This design choice enables efficient change detection and prevents accidental mutations.

```js
const todos = signal([
  { id: 1, text: 'Learn HellaJS', done: false },
  { id: 2, text: 'Build an app', done: false }
]);

// ❌ Mutation doesn't trigger reactivity
todos().push({ id: 3, text: 'New todo', done: false }); // No update
todos()[0].done = true;                                 // No update

// ✅ Immutable updates trigger reactivity
todos([...todos(), { id: 3, text: 'New todo', done: false }]);  // Creates new array
```

### Async Effects

Effects can handle asynchronous operations naturally. When an effect function is async, it will re-run whenever its tracked dependencies change, automatically canceling any previous execution.

```js
const todoId = signal(1);
const todoDetails = signal(null);
const loading = signal(false);

effect(async () => {
  const id = todoId();
  
  loading(true);
  try {
    const response = await fetch(`/api/todos/${id}`);
    const todo = await response.json();
    todoDetails(todo);
  } catch (error) {
    console.error('Failed to load todo:', error);
    todoDetails(null);
  } finally {
    loading(false);
  }
});

// Changing todoId automatically triggers new API call
todoId(2);
```

### Conditional Dependencies

Conditional logic in computed values and effects determines which signals become dependencies. Only signals that are actually accessed during execution will be tracked, enabling dynamic dependency relationships.

```js
const view = signal('counter');
const count = signal(0);
const todos = signal([]);

const currentTitle = computed(() => {
  const currentView = view();
  
  // Only the relevant signal becomes a dependency
  if (currentView === 'counter') {
    return `Count: ${count()}`;  // Only tracks count
  } else {
    return `Todos: ${todos().length}`;  // Only tracks todos
  }
});

todos([...todos(), { id: 1, text: 'New todo', done: false }]); // currentTitle doesn't update
view('todos'); // currentTitle updates and now tracks todos
```

### Transformation Chains

Computed values can depend on other computed values, creating transformation pipelines that efficiently propagate changes through complex data flows. Each step in the chain only recalculates when its specific dependencies change.

```js
const todos = signal([
  { id: 1, text: 'Learn HellaJS', done: false },
  { id: 2, text: 'Build an app', done: false },
  { id: 3, text: 'Write docs', done: true }
]);

const activeTodos = computed(() => todos().filter(t => !t.done));

const todoTotals = computed(() => ({
  total: todos().length,
  active: activeTodos().length,
}));

console.log(todoTotals()); // { total: 3, active: 2 }

todos([...todos(), { id: 4, text: 'New task', done: false}]);
console.log(todoTotals()); // { total: 4, active: 3 } - entire chain updates
```

## Optimization Strategies

### Batching Updates

[`batch()`](/reference/core/batch) groups multiple signal updates into a single update cycle, preventing intermediate computations and effects from running until all updates complete. This optimization is essential when making several related state changes.

```js
const count = signal(0);
const multiplier = signal(1);
const result = computed(() => count() * multiplier());

// Effect runs when result changes
effect(() => {
  console.log(`Result: ${result()}`);
});

// Without batching - result computes twice
count(5);        // Logs: "Result: 5"
multiplier(2);   // Logs: "Result: 10"

// With batching - result computes once
batch(() => {
  count(10);     // No effect execution yet
  multiplier(3); // No effect execution yet
});              // Logs: "Result: 30"
```

### Reactive Stores

[`store()`](/reference/store/store) creates objects with fine-grained reactivity, where each property is individually trackable. This prevents over-reactive updates that occur when using a single signal for complex objects.

```js
// ❌ Over-reactive - any property change updates everything
const counter = signal({ value: 0, max: 10, multiplier: 1 });
const displayText = computed(() => `Count: ${counter().value}`);

counter({ ...counter(), priority: 'medium' }); // displayText recalculates unnecessarily

// ✅ Fine-grained - using store for related data
const counter = store({
  value: 0,
  max: 10,
  multiplier: 1,
});

const displayText = computed(() => `Count: ${counter().value()}`);
counter().multiplier(2); // Updates multiplier, displayText unaffected
counter().value(1); // Updates value, displayText recalculates

console.log(displayText()); // "Count: 1"

```

### Untracked Reads

[`untracked()`](/reference/core/untracked) allows you to read signal values without establishing a dependency relationship. This is useful when you need to access a signal's value for logic or debugging without triggering updates when that signal changes.

```js
const count = signal(0);
const expensiveComputation = computed(() => {
  // Simulate expensive operation
  return untracked(() => {
    console.log('Expensive computation running');
    return count() * 1000;
  });
});

```

### Effect Cleanup

Effects return a cleanup function that removes the effect from the reactive system. Always call this function when an effect is no longer needed to prevent memory leaks and unnecessary computations.

```js
const count = signal(0);
const cleanup = effect(() => {
  console.log(`Count: ${count()}`);
});
// Later, when no longer needed
cleanup(); // Stops tracking count changes
```

## Internal Mechanics

Understanding how the reactive system works internally can help you write more efficient reactive code. The system uses a graph-based approach to track dependencies and propagate changes efficiently.

#### Reactive Nodes

Every signal, computed, and effect is a **reactive node** in the dependency graph. Each node maintains:
- **Dependencies** - The reactive values it reads from
- **Subscribers** - The reactive computations that read from it
- **State flags** - Internal status for efficient update coordination

```
Signal A ── Computed B ── Effect C
    ↑            ↑            ↑
 (source)    (dependency)  (subscriber)
```

#### Dependency Graph

The reactive system forms a directed graph where each edge represents a dependency relationship. This graph structure enables efficient propagation of changes from source signals to all dependent computations and effects.

The graph uses doubly-linked connections for efficient addition and removal of dependencies as computations re-execute and establish new dependency relationships.

#### State Management

Each reactive node uses efficient bit flags to track its current state throughout the update cycle:
- **Clean** - The value is current and no recalculation is needed
- **Dirty** - Dependencies have changed and re-evaluation is required
- **Pending** - Marked during propagation as potentially needing updates
- **Computing** - Currently executing a computation function
- **Tracking** - Actively recording new dependencies during execution

#### Update Propagation

When a signal changes, the system orchestrates updates through a carefully designed process:

1. **Mark subscribers** - All dependent nodes are marked as dirty
2. **Schedule effects** - Effects are queued for immediate execution  
3. **Process updates** - The system processes updates in dependency order
4. **Lazy evaluation** - Computed values recalculate only when accessed
5. **Execute effects** - Scheduled effects run after all signal updates complete

This hybrid approach optimizes performance by making computed values lazy (calculated on-demand) while keeping effects eager (executing immediately when dependencies change).

#### Memory Management

The reactive system includes automatic memory management to prevent leaks and optimize performance:

- **Dependency cleanup** - Old dependencies are automatically removed when computations re-execute
- **Link recycling** - Internal connection objects are reused to minimize memory allocation
- **Effect disposal** - Cleanup functions fully disconnect effects from the dependency graph

This design delivers fine-grained reactivity with minimal memory overhead and automatic cleanup, ensuring your applications remain performant as they scale.