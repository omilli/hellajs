---
layout: ../../../layouts/MainLayout.astro
title: Reactivity
description: Understanding HellaJS's fine-grained reactive system and core primitives.
---
import { Icon } from "astro-icon/components";


# Reactive System

The reactive system tracks dependencies automatically, allowing for efficient updates.

## Core Reactive Primitives

Three functions working together to create automatic dependency tracking.

```js
import { signal, computed, effect, batch } from '@hellajs/core';

// Create reactive state
const count = signal(0);

// Derive values automatically 
const doubled = computed(() => count() * 2);

// React to changes
effect(() => {
  console.log(`Count: ${count()}, Doubled: ${doubled()}`);
});

count(5); // Logs: "Count: 5, Doubled: 10"
```

### Signals - Reactive State

[`signal(value)`](/reference/core/signal) creates reactive state containers that can hold any value.

```js
import { signal } from '@hellajs/core';

const count = signal(0);
const name = signal('John');
const user = signal({ id: 1, name: 'John' });
const items = signal([1, 2, 3]);

// Reading values (getter)
console.log(count());     // 0
console.log(name());      // 'John'

// Setting values (setter) - triggers dependency updates
count(5);
name('Jane');
user({ id: 2, name: 'Jane' });
items([1, 2, 3, 4]);
```

<div role="alert" class="alert alert-info">
  <Icon name="ph:info" width={24} height={24} />
  <span>Signals are the foundation of reactivity - they hold state and notify dependents when values change.</span>
</div>


### Computed - Derived Values

[`computed(fn)`](/reference/core/computed) creates cached derived values that automatically update when dependencies change.

```js
import { computed } from '@hellajs/core';

const firstName = signal('John');
const lastName = signal('Doe');
const fullName = computed(() => `${firstName()} ${lastName()}`);

console.log(fullName()); // 'John Doe'

firstName('Jane'); 
console.log(fullName()); // 'Jane Doe' - automatically recalculated!

// Computed values are cached
console.log(fullName()); // 'Jane Doe' - returns cached result
```

**Key Characteristics:**
- **Lazy evaluation** - only computes when accessed and dependencies have changed
- **Automatic tracking** - dependencies detected by reading signals during computation
- **Caching** - results cached until dependencies change
- **Composable** - computed values can depend on other computed values

### Effects - Reactive Side Effects

[`effect(fn)`](/reference/core/effect) executes side effects when reactive dependencies change:

```js
import { effect } from '@hellajs/core';

const temperature = signal(20);
const humidity = signal(50);

// Effect automatically tracks dependencies
effect(() => {
  const temp = temperature();
  const hum = humidity();
  console.log(`Temperature: ${temp}°C, Humidity: ${hum}%`);
});

temperature(25); // Logs: "Temperature: 25°C, Humidity: 50%"
humidity(60);    // Logs: "Temperature: 25°C, Humidity: 60%"
```

**Use Cases:**
- Data persistence (localStorage, databases)
- API calls triggered by state changes
- Logging and debugging
- External system synchronization

## Reactive Patterns

### Data Transformation Chains

Create complex data flows using computed values that depend on other computed values:

```js
const rawData = signal([1, 2, 3, 4, 5, 6]);
const filtered = computed(() => rawData().filter(n => n > 3));
const doubled = computed(() => filtered().map(n => n * 2));
const sum = computed(() => doubled().reduce((a, b) => a + b, 0));

console.log(sum()); // 30 (8 + 10 + 12)

rawData([2, 4, 6, 8]); 
console.log(sum()); // 36 (8 + 12 + 16) - entire chain updates automatically
```

### Conditional Logic

```js
const temperature = signal(20);
const unit = signal('C');

const displayTemp = computed(() => {
  const temp = temperature();
  const u = unit();
  
  if (u === 'F') {
    return `${(temp * 9/5) + 32}°F`;
  }
  return `${temp}°C`;
});

console.log(displayTemp()); // "20°C"
unit('F');
console.log(displayTemp()); // "68°F"
```

### State Aggregation

```js
const users = signal([
  { name: 'John', age: 25, active: true },
  { name: 'Jane', age: 30, active: false },
  { name: 'Bob', age: 35, active: true }
]);

const activeUsers = computed(() => users().filter(u => u.active));
const averageAge = computed(() => {
  const active = activeUsers();
  return active.reduce((sum, u) => sum + u.age, 0) / active.length;
});
const stats = computed(() => ({
  total: users().length,
  active: activeUsers().length,
  averageAge: Math.round(averageAge())
}));

console.log(stats()); // { total: 3, active: 2, averageAge: 30 }
```

## Performance Optimization

### Batching Updates

Use [`batch()`](/reference/core/batch) to group related updates and avoid unnecessary intermediate calculations:

```js
import { batch } from '@hellajs/core';

const firstName = signal('John');
const lastName = signal('Doe');
const fullName = computed(() => `${firstName()} ${lastName()}`);

// Effect runs when fullName changes
effect(() => {
  console.log(`Full name: ${fullName()}`);
});

// Without batching - fullName computes twice
firstName('Jane');    // Logs: "Full name: Jane Doe"
lastName('Smith');    // Logs: "Full name: Jane Smith"

// With batching - fullName computes once
batch(() => {
  firstName('Alice');   // No effect execution yet
  lastName('Johnson');  // No effect execution yet
});                     // Logs: "Full name: Alice Johnson"
```

### Avoiding Over-reactivity

Break down complex objects to minimize unnecessary updates:

```js
// ❌ Over-reactive - any property change updates everything
const user = signal({ name: 'John', age: 30, email: 'john@example.com' });
const displayName = computed(() => user().name.toUpperCase());

user({ ...user(), email: 'newemail@example.com' }); // displayName recalculates unnecessarily

// ✅ Fine-grained - only relevant changes trigger updates
const userName = signal('John');
const userAge = signal(30);
const userEmail = signal('john@example.com');
const displayName = computed(() => userName().toUpperCase());

userEmail('newemail@example.com'); // displayName doesn't recalculate
```

## Working with Data

### Immutable Updates

Signals use reference equality (`===`) to detect changes, requiring immutable updates:

```js
const user = signal({ name: 'John', age: 30 });
const items = signal([1, 2, 3]);

// ❌ Mutation doesn't trigger reactivity
user().age = 31;          // No update
items().push(4);          // No update

// ✅ Immutable updates trigger reactivity
user({ ...user(), age: 31 });           // Creates new object
items([...items(), 4]);                 // Creates new array

// Helper patterns for common operations
const updateUser = (changes) => user({ ...user(), ...changes });
const addItem = (item) => items([...items(), item]);
const removeItem = (index) => items(items().filter((_, i) => i !== index));
```

### Async Effects

Handle asynchronous operations in effects:

```js
const userId = signal(1);
const userProfile = signal(null);
const loading = signal(false);

effect(async () => {
  const id = userId();
  
  loading(true);
  try {
    const response = await fetch(`/api/users/${id}`);
    const profile = await response.json();
    userProfile(profile);
  } catch (error) {
    console.error('Failed to load user:', error);
    userProfile(null);
  } finally {
    loading(false);
  }
});

// Changing userId automatically triggers new API call
userId(2);
```

### Conditional Dependencies

Use conditional logic to control which signals are tracked:

```js
const feature = signal('feature-a');
const featureAData = signal('data-a');
const featureBData = signal('data-b');

const currentData = computed(() => {
  const currentFeature = feature();
  
  // Only the relevant signal becomes a dependency
  if (currentFeature === 'feature-a') {
    return featureAData();  // Only tracks featureAData
  } else {
    return featureBData();  // Only tracks featureBData
  }
});

featureBData('new-data-b'); // currentData doesn't update (not a dependency)
feature('feature-b');       // currentData updates and now tracks featureBData
```

## See Also

- [**signal()**](/reference/core/signal) - Create reactive state containers
- [**computed()**](/reference/core/computed) - Derive values from reactive dependencies  
- [**effect()**](/reference/core/effect) - Execute side effects reactively
- [**batch()**](/reference/core/batch) - Optimize multiple updates
- [**untracked()**](/reference/core/untracked) - Read values without creating dependencies