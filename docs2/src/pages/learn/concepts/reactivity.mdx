---
layout: ../../../layouts/MainLayout.astro
title: Reactivity
description: How HellaJS creates automatic, efficient UI updates through fine-grained reactivity.
---

# Reactivity

HellaJS achieves automatic UI updates through **fine-grained reactivity** - a system that creates direct, surgical connections between your data and specific DOM elements.

## What Makes HellaJS Different

**Most frameworks are inefficient** - they re-render entire component trees on every change:

```jsx
// React - expensive diffing on every state change
function App() {
  const [count, setCount] = useState(0);
  console.log('Component re-rendered!');
  return (
    <div>
      <h1>Count: {count}</h1>           // Entire component re-runs
      <p>Double: {count * 2}</p>        // Every element gets checked
      <button onClick={() => setCount(count + 1)}>+</button>
    </div>
  );
}
```

**HellaJS is surgical** - only the exact DOM nodes that need updates get touched:

```jsx
const App = () => {
  const count = signal(0);
  const double = computed(() => count() * 2);
  console.log('Component created once!');
  
  return (
    <div>
      <h1>Count: {count}</h1>           // Direct connection: count → text node
      <p>Double: {double}</p>           // Direct connection: double → text node  
      <button onclick={() => count(count() + 1)}>+</button>
    </div>
  );
};
```

When you click the button:
1. `count` signal updates (no re-render)
2. `double` computed recalculates automatically
3. **Only** the two text nodes update - nothing else
4. Component never re-runs

## How the Reactive System Works

HellaJS builds a **reactive graph** during the initial render that connects your data to DOM nodes:

```
count (signal)
  ├─→ <h1> text node
  └─→ double (computed)
        └─→ <p> text node
```

Changes propagate through this graph instantly and precisely - no virtual DOM, no diffing, no waste.

## The Three Reactive Primitives

HellaJS reactivity is built on three primitives that automatically connect your data to the DOM:

### 1. Signals - Reactive State

[`signal()`](/reference/core/signal) creates reactive containers for state that can change:

```jsx
const count = signal(0);
const name = signal('John');

// Reading values
console.log(count());     // 0
console.log(name());      // 'John'

// Setting values (triggers updates)
count(5);
name('Jane');
```

**Critical JSX Pattern:** Pass the signal function, not the called result:
```jsx
// ✅ Correct - creates reactive binding
<div>Count: {count}</div>
<h1>Hello {name}</h1>

// ❌ Wrong - gets value once, no reactivity  
<div>Count: {count()}</div>
<h1>Hello {name()}</h1>
```

### 2. Computed - Derived Values

[`computed()`](/reference/core/computed) creates values that automatically recalculate when their dependencies change:

```jsx
const firstName = signal('John');
const lastName = signal('Doe');
const fullName = computed(() => `${firstName()} ${lastName()}`);

console.log(fullName()); // 'John Doe'

firstName('Jane'); 
console.log(fullName()); // 'Jane Doe' - automatically updated!
```

**Key Benefits:**
- Cached - only recalculates when dependencies actually change
- Automatically tracks dependencies
- Can depend on other computed values

### 3. Effects - Side Effects

[`effect()`](/reference/core/effect) runs code when reactive dependencies change:

```jsx
const user = signal({ name: 'John', email: 'john@example.com' });

// Effect runs whenever user changes
effect(() => {
  document.title = `User: ${user().name}`;
  console.log('Title updated!');
});

user({ name: 'Jane', email: 'jane@example.com' }); // Title updates automatically
```

**Perfect for:**
- Logging and debugging
- DOM manipulation outside JSX
- localStorage persistence
- API calls triggered by state changes

## Reactive Patterns in Practice

Here's how the three primitives work together in real applications:

### Simple Component State
```jsx
const Counter = () => {
  const count = signal(0);
  const isEven = computed(() => count() % 2 === 0);
  const message = computed(() => 
    `Count is ${count()} (${isEven() ? 'even' : 'odd'})`
  );

  return (
    <div>
      <h1>{message}</h1>
      <button onclick={() => count(count() + 1)}>Increment</button>
    </div>
  );
};
```

### Reactive Data Flow
```jsx
const UserProfile = () => {
  const user = signal({ name: 'John', age: 30 });
  const canVote = computed(() => user().age >= 18);
  
  // Effect runs when user changes
  effect(() => {
    console.log(`${user().name} ${canVote() ? 'can' : 'cannot'} vote`);
  });

  return (
    <div>
      <h2>{user().name} ({user().age})</h2>
      <p>Voting status: {canVote() ? 'Eligible' : 'Too young'}</p>
      <button onclick={() => user({ ...user(), age: user().age + 1 })}>
        Birthday!
      </button>
    </div>
  );
};
```

### Multiple Dependencies
```jsx
const Calculator = () => {
  const a = signal(10);
  const b = signal(5);
  const operation = signal('+');
  
  const result = computed(() => {
    switch (operation()) {
      case '+': return a() + b();
      case '-': return a() - b();
      case '*': return a() * b();
      case '/': return a() / b();
      default: return 0;
    }
  });

  return (
    <div>
      <input value={a} oninput={e => a(Number(e.target.value))} />
      <select value={operation} onchange={e => operation(e.target.value)}>
        <option>+</option>
        <option>-</option>
        <option>*</option>
        <option>/</option>
      </select>
      <input value={b} oninput={e => b(Number(e.target.value))} />
      <h3>= {result}</h3>
    </div>
  );
};
```

## Performance and Debugging

### Batching Updates

Group related updates to avoid unnecessary recalculations:

```jsx
import { batch } from '@hellajs/core';

const PersonForm = () => {
  const firstName = signal('John');
  const lastName = signal('Doe');
  const fullName = computed(() => `${firstName()} ${lastName()}`);
  
  const updatePerson = (data) => {
    batch(() => {
      firstName(data.firstName);  // Only triggers fullName recalculation once
      lastName(data.lastName);
    });
  };

  return (
    <div>
      <h1>{fullName}</h1>
      <button onclick={() => updatePerson({ firstName: 'Jane', lastName: 'Smith' })}>
        Update Name
      </button>
    </div>
  );
};
```

### Common Debugging Issues

**Issue #1: Calling signals in JSX instead of passing them**
```jsx
const name = signal('John');

// ❌ Wrong - gets value once, no reactivity
<div>Hello {name()}</div>

// ✅ Correct - creates reactive binding
<div>Hello {name}</div>
```

**Issue #2: Effects running too often**
```jsx
const user = signal({ name: 'John', age: 30 });

// ❌ Effect runs when entire object changes
effect(() => {
  document.title = user().name;
});

// ✅ Better - extract the specific value
const userName = computed(() => user().name);
effect(() => {
  document.title = userName();
});
```

### Understanding the Magic

HellaJS tracks dependencies automatically through "ownership tracking":
1. When a computed or effect runs, HellaJS starts tracking
2. Any signal read during execution becomes a dependency
3. When dependencies change, dependents automatically re-run
4. JSX expressions work the same way - they're reactive computations

This creates a **directed acyclic graph** where changes flow precisely from signals to the DOM nodes that need updates.

## Reactive Best Practices

### Choose the Right Primitive
- **Signals** for state that changes (user input, toggles, counters)
- **Computed** for derived values (calculations, filtered lists, formatting)
- **Effects** for side effects (logging, DOM manipulation, persistence)

### Write Reactive-Friendly Code
- Pass signal functions to JSX: `{count}` not `{count()}`
- Keep computations pure - no side effects in computed functions
- Use batch() for related updates that should happen together
- Extract specific values from objects to minimize effect re-runs

### Optimize for Performance
- Computed values are cached - use them liberally
- Break complex computations into smaller, focused ones
- Use batch() when updating multiple related signals
- Avoid creating signals inside render functions (they should be stable)

### Debug Reactivity Issues
- Check the browser console for ownership tracking errors
- Use `effect(() => console.log('value changed:', mySignal()))` for debugging
- Remember: if it's not reactive, you probably called the signal instead of passing it

## See Also

- [Components](/learn/concepts/components) - How JSX components work with reactive system
- [State Management](/learn/concepts/state) - Organizing state in larger applications
- [Resources](/learn/concepts/resources) - Handling async reactive data