---
layout: ../../../layouts/MainLayout.astro
title: Resources
description: Async data management with built-in loading states, error handling, and caching.
---

# Resources

Resources handle asynchronous data with built-in loading states, error handling, and caching, eliminating manual async state management boilerplate.

## What Are Resources?

Resources are reactive wrappers around async operations that automatically manage:
- **Loading states** - When data is being fetched
- **Error states** - When requests fail
- **Success states** - When data arrives
- **Caching** - Avoiding unnecessary re-fetches
- **Refetching** - Updating data when dependencies change

```jsx
import { resource } from '@hellajs/resource';

const UserProfile = ({ userId }) => {
  const user = resource(() => 
    fetch(`/api/users/${userId}`).then(r => r.json())
  );

  return (
    <div>
      {user.loading() && <div>Loading user...</div>}
      {user.error() && <div>Error: {user.error().message}</div>}
      {user.data() && (
        <div>
          <h1>{user.data().name}</h1>
          <p>{user.data().email}</p>
        </div>
      )}
    </div>
  );
};
```

Resources automatically track loading, error, and success states. All states are reactive and update the UI automatically.

## Basic Resource Patterns

### Simple Data Fetching

Create a resource for any async operation:

```jsx
const PostList = () => {
  const posts = resource(() => 
    fetch('/api/posts').then(r => r.json())
  );

  return (
    <div>
      {posts.loading() && <div>Loading posts...</div>}
      {posts.data() && (
        <ul>
          {posts.data().map(post => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      )}
    </div>
  );
};
```

### Reactive Dependencies

Resources automatically refetch when their dependencies change:

```jsx
const PostsByCategory = () => {
  const category = signal('tech');
  
  const posts = resource(
    cat => fetch(`/api/posts?category=${cat}`).then(r => r.json()),
    { key: category } // Refetch when category changes
  );

  return (
    <div>
      <select value={category} onchange={e => category(e.target.value)}>
        <option value="tech">Tech</option>
        <option value="design">Design</option>
      </select>
      
      {posts.loading() && <div>Loading posts...</div>}
      {posts.data() && (
        <ul>
          {posts.data().map(post => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      )}
    </div>
  );
};
```

### Manual Control

Trigger resource updates when needed:

```jsx
const TodoList = () => {
  const todos = resource(() => 
    fetch('/api/todos').then(r => r.json())
  );

  const addTodo = async (text) => {
    await fetch('/api/todos', {
      method: 'POST',
      body: JSON.stringify({ text }),
      headers: { 'Content-Type': 'application/json' }
    });
    
    todos.refetch(); // Refresh the resource
  };

  return (
    <div>
      <button onclick={() => addTodo('New todo')}>Add Todo</button>
      
      {todos.data() && (
        <ul>
          {todos.data().map(todo => (
            <li key={todo.id}>{todo.text}</li>
          ))}
        </ul>
      )}
    </div>
  );
};
```

## Advanced Resource Configuration

### Caching and Error Handling

Configure caching, retry logic, and error handling:

```jsx
const UserDashboard = () => {
  const userId = signal(1);
  
  const user = resource(
    id => fetch(`/api/users/${id}`).then(r => r.json()),
    {
      key: userId,                    // Refetch when userId changes
      cacheTime: 5 * 60 * 1000,      // Cache for 5 minutes
      retry: 3,                      // Retry failed requests 3 times
      retryDelay: 1000,              // Wait 1s between retries
      onError: (err) => console.error('User fetch failed:', err)
    }
  );

  const posts = resource(
    id => fetch(`/api/users/${id}/posts`).then(r => r.json()),
    { 
      key: userId,
      enabled: () => !!user.data(), // Only fetch when user is loaded
    }
  );

  return (
    <div>
      <select value={userId} onchange={e => userId(+e.target.value)}>
        <option value={1}>User 1</option>
        <option value={2}>User 2</option>
      </select>

      {user.loading() && <div>Loading user...</div>}
      {user.error() && <div>Failed to load user</div>}
      {user.data() && (
        <div>
          <h1>{user.data().name}</h1>
          <p>{user.data().email}</p>
          
          {posts.loading() && <div>Loading posts...</div>}
          {posts.data() && (
            <div>
              <h2>Posts</h2>
              {posts.data().map(post => (
                <article key={post.id}>
                  <h3>{post.title}</h3>
                  <p>{post.body}</p>
                </article>
              ))}
            </div>
          )}
        </div>
      )}
    </div>
  );
};
```

## Optimistic Updates

Update UI immediately for better user experience, then sync with server:

```jsx
const TodoApp = () => {
  const todos = resource(() => 
    fetch('/api/todos').then(r => r.json())
  );

  const toggleTodo = async (id) => {
    // Optimistic update - change UI immediately
    const current = todos.data();
    const optimistic = current.map(todo => 
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    );
    todos.mutate(optimistic);

    try {
      // Sync with server
      await fetch(`/api/todos/${id}/toggle`, { method: 'POST' });
    } catch (error) {
      // Revert on error
      todos.refetch();
    }
  };

  return (
    <div>
      {todos.data() && todos.data().map(todo => (
        <div key={todo.id}>
          <input
            type="checkbox"
            checked={todo.completed}
            onchange={() => toggleTodo(todo.id)}
          />
          {todo.text}
        </div>
      ))}
    </div>
  );
};
```


### Robust Error Handling

Handle different types of errors gracefully:

```jsx
const RobustDataComponent = () => {
  const data = resource(
    () => fetch('/api/data').then(async r => {
      if (!r.ok) {
        const error = await r.text();
        throw new Error(`${r.status}: ${error}`);
      }
      return r.json();
    }),
    {
      retry: 3,
      retryDelay: (attempt) => Math.pow(2, attempt) * 1000, // Exponential backoff
      onError: (error, attempt) => {
        console.error(`Attempt ${attempt} failed:`, error.message);
        if (attempt >= 3) {
          // Final failure - could send to error reporting
          console.error('All retries exhausted:', error);
        }
      }
    }
  );

  const retry = () => data.refetch();

  return (
    <div>
      {data.loading() && <div>Loading data...</div>}
      
      {data.error() && (
        <div class="error">
          <h3>Failed to load data</h3>
          <p>{data.error().message}</p>
          <button onclick={retry}>Try Again</button>
        </div>
      )}
      
      {data.data() && (
        <div class="success">
          <h3>Data loaded successfully!</h3>
          <pre>{JSON.stringify(data.data(), null, 2)}</pre>
        </div>
      )}
    </div>
  );
};
```

## Best Practices

### Design Guidelines
- **Use resources for all async data** - They handle loading and error states automatically
- **Set appropriate cache times** - Balance data freshness with performance
- **Use reactive keys** - Automatically refetch when dependencies change
- **Implement optimistic updates** - Better user experience for mutations
- **Handle errors gracefully** - Provide retry logic and user-friendly fallbacks
- **Use conditional fetching** - Only fetch when data is actually needed
- **Compose resources thoughtfully** - Structure complex data flows clearly

### Common Implementation Patterns

**Data Fetching on Route Changes:**
```jsx
const ProductPage = ({ productId }) => {
  const product = resource(
    id => fetch(`/api/products/${id}`).then(r => r.json()),
    { key: () => productId }
  );
  // Automatically refetches when productId changes
};
```

**Background Refresh:**
```jsx
const Dashboard = () => {
  const stats = resource(
    () => fetch('/api/stats').then(r => r.json()),
    { 
      cacheTime: 60000,      // Cache for 1 minute
      staleTime: 30000,      // Consider stale after 30 seconds
      refetchOnFocus: true   // Refresh when window regains focus
    }
  );
};
```

**Conditional Data Loading:**
```jsx
const ConditionalData = () => {
  const userId = signal(null);
  const userData = resource(
    id => fetch(`/api/users/${id}`).then(r => r.json()),
    { 
      key: userId,
      enabled: () => !!userId() // Only fetch when userId exists
    }
  );
};
```

## See Also

- [Reactivity](/learn/concepts/reactivity) - Understanding reactive primitives that power resources
- [State Management](/learn/concepts/state) - Managing state alongside async data
- [Components](/learn/concepts/components) - Using resources in components