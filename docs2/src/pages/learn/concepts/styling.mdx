---
layout: ../../../layouts/MainLayout.astro
title: Styling
description: Styling components in HellaJS with CSS-in-JS and traditional CSS.
---

HellaJS provides multiple styling approaches to fit different project needs - from traditional CSS classes to reactive CSS-in-JS that responds to state changes.

## Styling Approaches Overview

Choose the right styling approach for your project:

### Traditional CSS Classes
Best for: Static styles, existing stylesheets, team familiarity
```jsx
const Button = ({ variant, children }) => (
  <button class={`btn btn-${variant}`}>
    {children}
  </button>
);
```

### Inline Styles
Best for: Dynamic values, simple styling, performance-critical updates
```jsx
const ProgressBar = ({ progress }) => (
  <div style={`width: ${progress}%; background: green;`} />
);
```

### CSS-in-JS with `@hellajs/css`
Best for: Component-scoped styles, reactive styling, dynamic themes
```jsx
import { css } from '@hellajs/css';

const Button = ({ variant, children }) => {
  const buttonStyle = css`
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 0.25rem;
    cursor: pointer;
    
    ${variant === 'primary' && `
      background: blue;
      color: white;
    `}
    
    ${variant === 'secondary' && `
      background: gray;
      color: black;
    `}
  `;
  
  return (
    <button class={buttonStyle}>
      {children}
    </button>
  );
};
```

## CSS Classes and External Stylesheets

### Static CSS Classes

Use traditional CSS for stable, reusable styles:

```jsx
// styles.css
.card {
  padding: 1rem;
  border-radius: 0.5rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: all 0.2s ease;
}

.card--highlighted {
  border: 2px solid #3b82f6;
  box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
}

.card--dark {
  background: #374151;
  color: white;
}
```

```jsx
// Component
const Card = ({ highlighted, theme = 'light', children }) => {
  const classes = [
    'card',
    highlighted && 'card--highlighted',
    theme === 'dark' && 'card--dark'
  ].filter(Boolean).join(' ');
  
  return (
    <div class={classes}>
      {children}
    </div>
  );
};
```

### Dynamic Class Names

Reactive class names that respond to state:

```jsx
const TabButton = ({ isActive, children, onclick }) => {
  const isHovered = signal(false);
  
  const className = computed(() => [
    'tab-button',
    isActive() && 'tab-button--active',
    isHovered() && 'tab-button--hover'
  ].filter(Boolean).join(' '));
  
  return (
    <button 
      class={className}
      onclick={onclick}
      onmouseenter={() => isHovered(true)}
      onmouseleave={() => isHovered(false)}
    >
      {children}
    </button>
  );
};
```

## Inline Styles for Dynamic Values

### Reactive Inline Styles

Use inline styles when values change frequently:

```jsx
const ProgressBar = ({ progress, color = '#3b82f6' }) => {
  const barStyle = computed(() => `
    width: ${progress()}%;
    background: ${color};
    height: 8px;
    border-radius: 4px;
    transition: width 0.3s ease;
  `);
  
  return (
    <div style="width: 100%; background: #f1f5f9; border-radius: 4px; overflow: hidden;">
      <div style={barStyle} />
    </div>
  );
};
```

### Performance-Optimized Styles

```jsx
const AnimatedBox = ({ x, y, scale }) => {
  // Use transform for better performance
  const transform = computed(() => 
    `translate3d(${x()}px, ${y()}px, 0) scale(${scale()})`
  );
  
  return (
    <div style={`transform: ${transform}; will-change: transform;`}>
      Animated content
    </div>
  );
};
```

## CSS-in-JS with `@hellajs/css`

### Component-Scoped Styling

Create styles that are automatically scoped to components:

```jsx
import { css, keyframes } from '@hellajs/css';

const fadeIn = keyframes`
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
`;

const Modal = ({ isOpen, children }) => {
  const modalStyle = css`
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    padding: 2rem;
    border-radius: 0.5rem;
    box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    max-width: 500px;
    width: 90%;
    z-index: 1000;
    
    animation: ${fadeIn} 0.3s ease-out;
  `;
  
  const overlayStyle = css`
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 999;
  `;
  
  return (
    <>
      {isOpen() && (
        <>
          <div class={overlayStyle} onclick={() => isOpen(false)} />
          <div class={modalStyle}>
            {children}
          </div>
        </>
      )}
    </>
  );
};
```

### Reactive CSS-in-JS

Styles that automatically update when signals change:

```jsx
import { css } from '@hellajs/css';

const InteractiveCard = ({ data }) => {
  const isActive = signal(false);
  const theme = signal('light');
  
  const cardStyle = css`
    padding: 1rem;
    border-radius: 0.5rem;
    cursor: pointer;
    transition: all 0.2s ease;
    
    ${theme() === 'light' ? `
      background: white;
      color: black;
      border: 1px solid #e5e7eb;
    ` : `
      background: #374151;
      color: white;
      border: 1px solid #4b5563;
    `}
    
    ${isActive() && `
      transform: scale(1.02);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    `}
    
    &:hover {
      transform: scale(1.01);
    }
  `;
  
  return (
    <div 
      class={cardStyle}
      onclick={() => isActive(!isActive())}
    >
      <h3>{data.title}</h3>
      <p>{data.description}</p>
      
      <button onclick={() => theme(theme() === 'light' ? 'dark' : 'light')}>
        Switch to {theme() === 'light' ? 'dark' : 'light'} theme
      </button>
    </div>
  );
};
```

### Style Composition and Mixins

Reuse and compose styles across components:

```jsx
// Define reusable style mixins
const buttonBase = css`
  padding: 0.5rem 1rem;
  border: none;
  border-radius: 0.375rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`;

const primaryButton = css`
  ${buttonBase}
  background: #3b82f6;
  color: white;
  
  &:hover:not(:disabled) {
    background: #2563eb;
  }
`;

const secondaryButton = css`
  ${buttonBase}
  background: #f1f5f9;
  color: #475569;
  border: 1px solid #e2e8f0;
  
  &:hover:not(:disabled) {
    background: #e2e8f0;
  }
`;

const Button = ({ variant = 'primary', children, ...props }) => {
  const buttonStyle = variant === 'primary' ? primaryButton : secondaryButton;
  
  return (
    <button class={buttonStyle} {...props}>
      {children}
    </button>
  );
};
```

## Advanced Styling Techniques

### Theme Systems and Design Tokens

Build a comprehensive, reactive theme system:

```jsx
import { css } from '@hellajs/css';

// Design tokens
const tokens = {
  colors: {
    primary: {
      50: '#eff6ff',
      500: '#3b82f6',
      600: '#2563eb',
      900: '#1e3a8a'
    },
    gray: {
      50: '#f9fafb',
      100: '#f3f4f6',
      500: '#6b7280',
      900: '#111827'
    }
  },
  spacing: {
    xs: '0.25rem',
    sm: '0.5rem',
    md: '1rem',
    lg: '1.5rem',
    xl: '2rem'
  },
  breakpoints: {
    sm: '640px',
    md: '768px',
    lg: '1024px'
  }
};

// Theme configurations
const themes = {
  light: {
    background: tokens.colors.gray[50],
    surface: '#ffffff',
    text: tokens.colors.gray[900],
    primary: tokens.colors.primary[500]
  },
  dark: {
    background: tokens.colors.gray[900],
    surface: '#374151',
    text: tokens.colors.gray[50],
    primary: tokens.colors.primary[400]
  }
};

// Theme provider
const currentTheme = signal('light');
const theme = computed(() => themes[currentTheme()]);

const ThemeButton = ({ children, ...props }) => {
  const buttonStyle = css`
    background: ${theme().primary};
    color: ${theme().surface};
    border: none;
    padding: ${tokens.spacing.sm} ${tokens.spacing.md};
    border-radius: 0.375rem;
    cursor: pointer;
    font-weight: 500;
    transition: all 0.2s;
    
    &:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }
    
    @media (min-width: ${tokens.breakpoints.md}) {
      padding: ${tokens.spacing.md} ${tokens.spacing.lg};
    }
  `;
  
  return (
    <button class={buttonStyle} {...props}>
      {children}
    </button>
  );
};
```

### Responsive Design with CSS-in-JS

Handle responsive design systematically:

```jsx
import { css } from '@hellajs/css';

// Responsive utilities
const breakpoints = {
  sm: '(min-width: 640px)',
  md: '(min-width: 768px)',
  lg: '(min-width: 1024px)',
  xl: '(min-width: 1280px)'
};

const media = Object.entries(breakpoints).reduce((acc, [key, query]) => {
  acc[key] = (styles) => `@media ${query} { ${styles} }`;
  return acc;
}, {});

const ResponsiveGrid = ({ items }) => {
  const gridStyle = css`
    display: grid;
    gap: 1rem;
    padding: 1rem;
    grid-template-columns: 1fr;
    
    ${media.sm(`
      grid-template-columns: repeat(2, 1fr);
      gap: 1.5rem;
    `)}
    
    ${media.md(`
      grid-template-columns: repeat(3, 1fr);
      gap: 2rem;
    `)}
    
    ${media.lg(`
      grid-template-columns: repeat(4, 1fr);
    `)}
  `;
  
  const itemStyle = css`
    background: white;
    padding: 1rem;
    border-radius: 0.5rem;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    transition: all 0.2s;
    
    &:hover {
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      transform: translateY(-2px);
    }
    
    ${media.sm(`
      padding: 1.25rem;
    `)}
    
    ${media.md(`
      padding: 1.5rem;
    `)}
  `;
  
  return (
    <div class={gridStyle}>
      {items().map(item => (
        <div key={item.id} class={itemStyle}>
          <h3>{item.title}</h3>
          <p>{item.description}</p>
        </div>
      ))}
    </div>
  );
};
```

### Animation and Transitions

Create smooth, performant animations:

```jsx
import { css, keyframes } from '@hellajs/css';

// Define keyframe animations
const slideIn = keyframes`
  from {
    opacity: 0;
    transform: translateX(-20px);
  }
  to {
    opacity: 1;
    transform: translateX(0);
  }
`;

const pulse = keyframes`
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
`;

const AnimatedCard = ({ isVisible, isLoading, children }) => {
  const cardStyle = css`
    padding: 2rem;
    background: white;
    border-radius: 0.5rem;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    
    ${isVisible() ? `
      animation: ${slideIn} 0.5s ease-out;
      opacity: 1;
      transform: translateY(0);
    ` : `
      opacity: 0;
      transform: translateY(20px);
    `}
    
    ${isLoading() && `
      animation: ${pulse} 2s ease-in-out infinite;
    `}
    
    &:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 16px rgba(0,0,0,0.15);
    }
  `;
  
  return (
    <div class={cardStyle}>
      {children}
    </div>
  );
};
```

## Styling Best Practices

### Architecture and Organization

**Choose the Right Approach:**
- **CSS Classes** - For stable, reusable styles and design systems
- **Inline Styles** - For dynamic values and performance-critical updates
- **CSS-in-JS** - For component-scoped styles and reactive styling

**Style Organization Patterns:**
```jsx
// ✅ Good - Clear separation of concerns
const ComponentStyles = {
  // Static styles in CSS files
  container: 'component-container',
  header: 'component-header',
  
  // Dynamic styles with CSS-in-JS
  dynamicButton: (isActive, theme) => css`
    background: ${isActive ? theme.primary : theme.secondary};
    transform: ${isActive ? 'scale(1.05)' : 'scale(1)'};
    transition: all 0.2s ease;
  `
};

const MyComponent = ({ isActive, theme }) => (
  <div class={ComponentStyles.container}>
    <header class={ComponentStyles.header}>Title</header>
    <button class={ComponentStyles.dynamicButton(isActive, theme)}>
      Click me
    </button>
  </div>
);
```

### Performance Optimization

**Efficient Style Updates:**
```jsx
// ✅ Good - Computed styles cache results
const OptimizedComponent = ({ items, theme }) => {
  const containerStyle = computed(() => css`
    background: ${theme().background};
    color: ${theme().text};
  `);
  
  return (
    <div class={containerStyle}>
      {items().map(item => (
        <div key={item.id}>{item.name}</div>
      ))}
    </div>
  );
};

// ❌ Avoid - Recreating styles on every render
const InefficientComponent = ({ items, theme }) => {
  const containerStyle = css`  // Created every render!
    background: ${theme().background};
    color: ${theme().text};
  `;
  
  return <div class={containerStyle}>...</div>;
};
```

**Use Transform and Opacity for Animations:**
```jsx
// ✅ Good - GPU-accelerated properties
const SmoothAnimation = ({ isVisible }) => {
  const style = css`
    transform: translateY(${isVisible() ? '0' : '20px'});
    opacity: ${isVisible() ? '1' : '0'};
    transition: transform 0.3s ease, opacity 0.3s ease;
    will-change: transform, opacity;
  `;
  
  return <div class={style}>Content</div>;
};
```

## Common Styling Patterns

### State-Based Styling
```jsx
const StatusBadge = ({ status, children }) => {
  const badgeStyles = {
    success: css`
      background: #dcfce7;
      color: #166534;
      border: 1px solid #bbf7d0;
    `,
    error: css`
      background: #fee2e2;
      color: #991b1b;
      border: 1px solid #fecaca;
    `,
    warning: css`
      background: #fef3c7;
      color: #92400e;
      border: 1px solid #fde68a;
    `
  };
  
  const baseStyle = css`
    display: inline-flex;
    align-items: center;
    padding: 0.25rem 0.75rem;
    border-radius: 0.375rem;
    font-size: 0.875rem;
    font-weight: 500;
  `;
  
  return (
    <span class={`${baseStyle} ${badgeStyles[status]}`}>
      {children}
    </span>
  );
};
```

### Responsive Component Styling
```jsx
const ResponsiveCard = ({ title, content }) => {
  const cardStyle = css`
    padding: 1rem;
    background: white;
    border-radius: 0.5rem;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    
    /* Mobile first approach */
    font-size: 0.875rem;
    
    @media (min-width: 640px) {
      padding: 1.5rem;
      font-size: 1rem;
    }
    
    @media (min-width: 1024px) {
      padding: 2rem;
      font-size: 1.125rem;
    }
    
    /* Dark mode support */
    @media (prefers-color-scheme: dark) {
      background: #374151;
      color: #f9fafb;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
  `;
  
  return (
    <div class={cardStyle}>
      <h3>{title}</h3>
      <p>{content}</p>
    </div>
  );
};
```

### Dynamic Theme Integration
```jsx
const ThemedButton = ({ variant = 'primary', size = 'md', children, ...props }) => {
  const theme = useTheme(); // Assume this hook provides current theme
  
  const buttonStyle = css`
    /* Base styles */
    border: none;
    border-radius: 0.375rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    
    /* Size variants */
    ${size === 'sm' && `
      padding: 0.375rem 0.75rem;
      font-size: 0.875rem;
    `}
    
    ${size === 'md' && `
      padding: 0.5rem 1rem;
      font-size: 1rem;
    `}
    
    ${size === 'lg' && `
      padding: 0.75rem 1.5rem;
      font-size: 1.125rem;
    `}
    
    /* Color variants */
    ${variant === 'primary' && `
      background: ${theme().colors.primary};
      color: ${theme().colors.primaryText};
      
      &:hover:not(:disabled) {
        background: ${theme().colors.primaryHover};
      }
    `}
    
    ${variant === 'secondary' && `
      background: ${theme().colors.secondary};
      color: ${theme().colors.secondaryText};
      
      &:hover:not(:disabled) {
        background: ${theme().colors.secondaryHover};
      }
    `}
    
    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  `;
  
  return (
    <button class={buttonStyle} {...props}>
      {children}
    </button>
  );
};
```

## Integration with HellaJS Concepts

### With Component Architecture
Style components efficiently while maintaining clean separation of concerns:

```jsx
// Design system approach
const designSystem = {
  components: {
    button: (variant, size) => css`
      /* Base button styles */
      ${buttonBase}
      ${buttonVariants[variant]}
      ${buttonSizes[size]}
    `,
    
    card: (elevation) => css`
      ${cardBase}
      box-shadow: ${elevations[elevation]};
    `
  }
};

const Button = ({ variant = 'primary', size = 'md', children, ...props }) => (
  <button class={designSystem.components.button(variant, size)} {...props}>
    {children}
  </button>
);
```

### With State Management
Connect styles to global state for consistent theming:

```jsx
import { store } from '@hellajs/store';

const uiStore = store({
  theme: 'light',
  primaryColor: '#3b82f6',
  
  toggleTheme() {
    this.theme = this.theme === 'light' ? 'dark' : 'light';
  },
  
  setPrimaryColor(color) {
    this.primaryColor = color;
  }
});

const ThemedComponent = () => {
  const componentStyle = css`
    background: ${uiStore.theme === 'light' ? '#ffffff' : '#374151'};
    color: ${uiStore.theme === 'light' ? '#111827' : '#f9fafb'};
    border: 2px solid ${uiStore.primaryColor};
    transition: all 0.2s ease;
  `;
  
  return (
    <div class={componentStyle}>
      <button onclick={() => uiStore.toggleTheme()}>
        Switch to {uiStore.theme === 'light' ? 'dark' : 'light'} theme
      </button>
    </div>
  );
};
```

### With Performance Optimization
Optimize styling for better performance:

```jsx
// Use computed for expensive style calculations
const ComplexStyledComponent = ({ data, settings }) => {
  const expensiveStyle = computed(() => {
    // Only recalculates when data or settings change
    const processedData = expensiveStyleCalculation(data(), settings());
    
    return css`
      /* Complex styles based on processed data */
      background: linear-gradient(${processedData.gradient});
      transform: ${processedData.transform};
      filter: ${processedData.filter};
    `;
  });
  
  return <div class={expensiveStyle}>Content</div>;
};

// Batch style updates for better performance
const BatchedStyleUpdates = () => {
  const position = signal({ x: 0, y: 0 });
  const rotation = signal(0);
  const scale = signal(1);
  
  const transform = computed(() => 
    `translate3d(${position().x}px, ${position().y}px, 0) 
     rotate(${rotation()}deg) 
     scale(${scale()})`
  );
  
  const updateAll = () => {
    // Batch all updates for single style recalculation
    batch(() => {
      position({ x: 100, y: 50 });
      rotation(45);
      scale(1.2);
    });
  };
  
  return (
    <div 
      style={`transform: ${transform}; will-change: transform;`}
      onclick={updateAll}
    >
      Animated element
    </div>
  );
};
```

## See Also

- [Components](/learn/concepts/components) - Building styled component architectures
- [Reactivity](/learn/concepts/reactivity) - Making styles reactive to state changes
- [State Management](/learn/concepts/state) - Managing theme and styling state globally
- [Performance](/learn/concepts/performance) - Optimizing style updates and calculations