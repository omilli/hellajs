---
layout: ../../../layouts/MainLayout.astro
title: Templating
description: JSX templating with reactive bindings and control flow patterns.
---

import { Icon } from "astro-icon/components";

# Granular Templating

HellaJS uses a unique approach to templating that eliminates virtual DOM diffing and re-render cycles. Instead of rebuilding entire component trees, reactive values are bound directly to specific DOM elements, attributes, and event handlers, enabling surgical updates only where data actually changes.

## Reactive Bindings

<div role="alert" class="alert alert-error text-base">
  <Icon name="ph:warning" width={24} height={24} />
  <span>Unlike other frameworks, HellaJS uses function references to create reactive bindings.</span>
</div>

### Signal References

Reactive text content is created by passing signal references (functions) instead of their current values. This creates a direct binding between the signal and the DOM text node, automatically updating the display whenever the signal changes.

✅ Reactive: ` <h1>{count}</h1>`

⛔ Static: ` <h1>{count()}</h1>`

```jsx
import { signal } from '@hellajs/core';

const Counter = () => {
  const count = signal(0);
  
  return (
    <div>
      <h1>{count}</h1>
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

### Derived Functions

HTML attributes and DOM properties become reactive by providing function references instead of static values. This technique works for any attribute or property, from CSS classes to data attributes to boolean properties like `checked` or `disabled`.

✅ Reactive: `class={() => count() % 2 === 0 ? 'even' : 'odd'}`

⛔ Static: `class={count % 2 === 0 ? 'even' : 'odd'}`

```jsx
import { signal } from '@hellajs/core';

const Counter = () => {
  const count = signal(0);
  
  return (
    <div>
      <h1 class={() => count() % 2 === 0 ? 'even' : 'odd'}>{count}</h1>
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

### Dynamic Text

✅ Reactive: ` <h1>Count: {count}</h1>`

✅ Reactive: ```<h1>{() => `Count: ${count()}`}</h1>```

⛔ Static: ` <h1>Count: {count()}</h1>`

Dynamic string interpolation can be achieved through arrow functions that return template strings. This approach is particularly useful when you need to combine static text with reactive values or perform string transformations.
```jsx
import { signal } from '@hellajs/core';

const Counter = () => {
  const count = signal(0);
  
  return (
    <div>
      <h1>{() => `Count: ${count()}`}</h1>
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

## Components

HellaJS components are functions that execute once to establish DOM structure and reactive connections. Unlike traditional frameworks that re-execute components on every state change, HellaJS components initialize once and let the reactive system handle all updates.

### Static Components

Static components render fixed content that doesn't change over time:

```jsx
const Header = ({ title }) => <h1>{title}</h1>;
const Footer = ({ year = 2024 }) => <footer>© {year} My App</footer>;
```

### Interactive Components

Interactive components create signals and reactive state during their single execution. Once created, the reactive system automatically handles all updates:

```jsx
const Counter = ({ initialValue = 0 }) => {
  const count = signal(initialValue);
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
      <button onclick={() => count(count() - 1)}>
        Decrement
      </button>
    </div>
  );
};
```

### Component Composition

HellaJS components compose naturally through props and children. Since components are just functions, composition works the same way as function composition:

```jsx
const Card = ({ title, variant = 'default' }, children) => (
  <div class={`card card-${variant}`}>
    <div class="card-header"><h2>{title}</h2></div>
    <div class="card-content">{children}</div>
  </div>
);

const Button = ({ variant = 'primary', onclick, children }) => (
  <button class={`btn btn-${variant}`} onclick={onclick}>
    {children}
  </button>
);

// Components compose naturally
const MyPage = () => (
  <Card title="Welcome" variant="highlighted">
    <p>Welcome to our application!</p>
    <Button onclick={() => alert('Hello!')}>Get Started</Button>
  </Card>
);
```

### Reactive Data Flow

HellaJS enables powerful data flow patterns by passing reactive signals between components. Unlike props in traditional frameworks that are just values, signals maintain their reactivity across component boundaries:

```jsx
const TodoCard = ({ todo }) => (
  <div class="todo-card">
    <h3>{() => todo().text}</h3>
    <p>Priority: {() => todo().priority}</p>
    <span class={() => `status ${todo().done ? 'completed' : 'pending'}`}>
      {() => todo().done ? 'Completed' : 'Pending'}
    </span>
  </div>
);

const TodoApp = () => {
  const selectedTodo = signal({ 
    id: 1,
    text: 'Learn HellaJS', 
    priority: 'high',
    done: false
  });
  
  return (
    <div class="todo-app">
      <TodoCard todo={selectedTodo} />
      <button onclick={() => selectedTodo({
        id: 2,
        text: 'Build awesome app',
        priority: 'medium', 
        done: true
      })}>
        Switch Todo
      </button>
    </div>
  );
};
```
## Control Flow

### Conditional Rendering

Conditional rendering in HellaJS uses function references that return either elements or falsy values. When the condition changes, the DOM updates automatically by adding or removing elements as needed, without requiring manual lifecycle management.

```jsx
const Counter = () => {
  const count = signal(0);
  const doubled = () => count() * 2;

  return (
    <div>
      <h1>Count: {count}</h1>
      <h2>Doubled: {doubled}</h2>
      <p>Count is: {() => count() % 2 === 0 ? 'even' : 'odd'}</p>
      {() => count() > 5 && <p>Great job! Count is greater than 5!</p>}
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

### Lists and Iteration

List rendering in HellaJS comes in two forms: static lists using regular array methods for one-time rendering, and reactive lists using the optimized `forEach` function. The `forEach` helper provides efficient list updates by tracking individual items and minimizing DOM operations through intelligent diffing algorithms.

```jsx
const TodoList = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', done: false },
    { id: 2, text: 'Build an app', done: false }
  ]);
  
  const addTodo = (text) => {
    todos([...todos(), { 
      id: Date.now(), 
      text, 
      done: false 
    }]);
  };
  
  return (
    <div>
      <ul>
        {forEach(todos, todo => (
          <li key={todo.id} class={todo.done ? 'done' : ''}>
            <input 
              type="checkbox" 
              checked={todo.done}
              onchange={e => {
                const updated = todos().map(t => 
                  t.id === todo.id ? { ...t, done: e.target.checked } : t
                );
                todos(updated);
              }}
            />
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
};
```

### Fragments and Children

Fragments allow you to group multiple elements without introducing unnecessary wrapper elements in the DOM. They're particularly useful for conditional rendering of multiple elements or when component structure requirements don't align with semantic HTML needs.

```jsx
const Modal = ({ isOpen, onClose, children }) => {
  return (
    <>
      {() => isOpen() && (
        <>
          <div class="overlay" onclick={onClose} />
          <div class="modal">
            <button class="close" onclick={onClose}>×</button>
            {children}
          </div>
        </>
      )}
    </>
  );
};

const App = () => {
  const showModal = signal(false);
  
  return (
    <div>
      <button onclick={() => showModal(true)}>Open Modal</button>
      
      <Modal isOpen={showModal} onClose={() => showModal(false)}>
        <h2>Modal Content</h2>
        <p>This is inside the modal!</p>
      </Modal>
    </div>
  );
};
```

## Element Lifecycle

<div role="alert" class="alert alert-error text-base">
  <Icon name="ph:warning" width={24} height={24} />
  <span>Unlike other frameworks, lifecycle hooks are tied directly to elements, not component scope.</span>
</div>

### `onUpdate`

The `onUpdate` lifecycle hook executes whenever a reactive binding updates an element's properties, attributes, or content. This provides a way to respond to DOM changes without polling or external observation mechanisms.

```jsx
const Counter = () => {
  const count = signal(0);
  
  return (
    <div>
      <h1 onUpdate={() => console.log('Count updated to:', count())}>{count}</h1>
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

### `onDestroy`

The `onDestroy` lifecycle hook executes when an element is removed from the DOM, providing an opportunity to clean up resources, cancel subscriptions, or perform other teardown tasks. This hook is automatically triggered by a MutationObserver that watches for DOM removals.

```jsx
const Counter = () => {
  const count = signal(0);  
  return (
    <div>
      {() => count() > 0 && (
        <h1 onDestroy={() => console.log('Count display destroyed')}>{count}</h1>
      )}
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
      <button onclick={() => count(0)}>
        Reset
      </button>
    </div>
  );
};
```

## Performance Optimizations

### Untracked Reads

Use `untracked` to read signals without creating dependencies:

```jsx
const Counter = () => {
  const count = signal(0);
  const debugMode = signal(true);
  
  const doubled = () => {
    const value = count();
    
    // Read debugMode without making it a dependency
    if (untracked(() => debugMode())) {
      console.log('Debug: count is', value);
    }
    
    return value * 2;
  };
  
  return (
    <div>
      <h1>Count: {count}</h1>
      <h2>Doubled: {doubled}</h2>
      <button onclick={() => count(count() + 1)}>Increment</button>
      <button onclick={() => debugMode(!debugMode())}>
        Toggle Debug: {() => debugMode() ? 'On' : 'Off'}
      </button>
    </div>
  );
};
```

### Cleanup with `onDestroy`

For components with external resources like timers, subscriptions, or event listeners, use `onDestroy` on the root element to ensure proper cleanup when the component is removed from the DOM. This prevents memory leaks and unwanted side effects.

```jsx
const Counter = () => {
  const count = signal(0);
  
  const interval = setInterval(() => {
    count(count() + 1);
  }, 1000);

  return (
    <div onDestroy={() => clearInterval(interval)}>
      <h1>{count}</h1>
    </div>
  );
};
```

## Internal Mechanics

Understanding how HellaJS templating works internally reveals the elegant simplicity behind its granular reactivity system. The DOM package orchestrates a sophisticated yet lightweight approach to binding reactive data directly to DOM elements.

#### VNode Architecture

Every template element is represented as a **VNode** (Virtual Node) object containing three core properties:
- **tag** - The HTML element name or fragment identifier
- **props** - Element attributes, properties, and lifecycle hooks  
- **children** - Array of child VNodes or primitive values

```
VNode {
  tag: "div",
  props: { class: () => count() > 5 ? "active" : "" },
  children: [count, "items"]
}
```

Unlike traditional virtual DOM systems that diff entire trees, HellaJS VNodes serve as templates that establish direct reactive connections during the initial render.

#### VNode Templating

For scenarios where JSX isn't available or when programmatically generating templates, you can construct VNodes directly. This approach offers the same reactive capabilities as JSX:

```js
import { signal } from '@hellajs/core';

const Counter = () => {
  const count = signal(0);

  return {
    tag: 'div',
    children: [
      {
        tag: 'h1',
        children: count  // Function reference for reactivity
      },
      {
        tag: 'button',
        props: { onclick: () => count(count() + 1) },
        children: 'Increment'
      }
    ]
  };
};
```

#### Reactive Binding Process

When mounting a template, the system distinguishes between static values and function references to establish reactive bindings:

1. **Function Detection** - The mount system identifies function references in props and children
2. **Effect Creation** - Each reactive binding creates a dedicated effect using the core reactivity system
3. **Direct DOM Binding** - Effects update specific DOM properties without intermediate virtual representations
4. **Lifecycle Integration** - Element lifecycle hooks are wired directly to DOM mutation events

```
Signal Change → Effect Execution → Direct DOM Update
     ↑                                      ↓
     └── No Virtual DOM Diffing ←──────────┘
```

#### Dynamic Content Handling

Dynamic children (conditional renders and function expressions) use a sophisticated comment-marker system for efficient DOM updates:

- **Boundary Markers** - HTML comments mark the start and end of dynamic content regions
- **Content Replacement** - When expressions change, only content between markers is replaced
- **Fragment Support** - Multiple elements can be inserted or removed as cohesive units
- **Cleanup Coordination** - Removed elements trigger automatic effect cleanup and lifecycle hooks

#### List Optimization

The `forEach` helper implements advanced list diffing using the Longest Increasing Subsequence (LIS) algorithm:

- **Key-Based Tracking** - Items are tracked by unique keys for efficient reordering
- **Minimal DOM Operations** - Only elements that actually need moving are repositioned
- **Memory Efficiency** - Node references are cached and reused across updates
- **Performance Scaling** - Algorithms ensure performance remains optimal even with large lists

#### Element Lifecycle Management

Element lifecycle is managed through a combination of direct hooks and automatic observation:

- **MutationObserver Integration** - A global observer watches for DOM removals
- **Effect Registration** - Each element maintains a set of cleanup functions for its reactive bindings
- **Automatic Cleanup** - When elements are removed, all associated effects are disposed automatically
- **Memory Safety** - Circular references are prevented through proper cleanup sequencing

#### Rendering Pipeline

The complete rendering process follows this optimized pipeline:

1. **VNode Resolution** - Templates are converted to VNode objects
2. **Element Creation** - Real DOM elements are created for each VNode
3. **Property Binding** - Static properties are set directly, reactive properties create effects
4. **Child Mounting** - Child elements are recursively processed and appended
5. **Effect Activation** - All reactive bindings begin tracking their dependencies
6. **Lifecycle Registration** - Elements are registered for automatic cleanup on removal

This architecture delivers the performance benefits of fine-grained reactivity while maintaining the developer experience of declarative templating, creating a system that scales efficiently from simple components to complex applications.