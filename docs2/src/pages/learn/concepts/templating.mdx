---
layout: ../../../layouts/MainLayout.astro
title: Templating
description: JSX templating with reactive bindings and control flow patterns.
---

# Templating

HellaJS uses JSX for templating with a key difference: JSX expressions create direct reactive bindings to DOM elements, not virtual DOM nodes.

## Quick Example

JSX in HellaJS creates reactive connections directly to the DOM:

```jsx
import { signal } from '@hellajs/core';

const UserCard = () => {
  const user = signal({ name: 'John', online: false });
  const count = signal(0);
  
  return (
    <div class={user().online ? 'online' : 'offline'}>
      <h1>Welcome, {user().name}!</h1>
      <p>Status: {user().online ? 'Online' : 'Offline'}</p>
      <button onclick={() => count(count() + 1)}>
        Clicked {count} times
      </button>
    </div>
  );
};
```

Each reactive expression creates a direct binding to a specific DOM node. When the signal changes, only that exact element updates.

## Basic Usage

### Text Content

Bind reactive values to text content:

```jsx
const Greeting = () => {
  const name = signal('World');
  const time = signal(new Date().toLocaleTimeString());
  
  // Update time every second
  setInterval(() => time(new Date().toLocaleTimeString()), 1000);
  
  return (
    <div>
      <h1>Hello, {name}!</h1>
      <p>Current time: {time}</p>
      <input 
        placeholder="Enter your name"
        value={name}
        oninput={e => name(e.target.value)}
      />
    </div>
  );
};
```

### Attributes and Properties

Bind to any HTML attribute or property:

```jsx
const ImageGallery = () => {
  const currentImage = signal(0);
  const images = signal([
    { src: '/image1.jpg', alt: 'Image 1' },
    { src: '/image2.jpg', alt: 'Image 2' },
    { src: '/image3.jpg', alt: 'Image 3' }
  ]);
  
  return (
    <div>
      <img 
        src={images()[currentImage()].src}
        alt={images()[currentImage()].alt}
        style={`transform: scale(${currentImage() === 0 ? 1.1 : 1})`}
      />
      
      <div>
        {images().map((_, index) => (
          <button 
            key={index}
            onclick={() => currentImage(index)}
            class={currentImage() === index ? 'active' : ''}
          >
            {index + 1}
          </button>
        ))}
      </div>
    </div>
  );
};
```

### Event Handlers

Handle events with reactive callbacks:

```jsx
const InteractiveButton = () => {
  const clicks = signal(0);
  const isPressed = signal(false);
  
  const handleClick = () => {
    clicks(clicks() + 1);
  };
  
  const handleMouseDown = () => isPressed(true);
  const handleMouseUp = () => isPressed(false);
  
  return (
    <button 
      onclick={handleClick}
      onmousedown={handleMouseDown}
      onmouseup={handleMouseUp}
      class={isPressed() ? 'pressed' : ''}
      style={`transform: scale(${isPressed() ? 0.95 : 1})`}
    >
      Clicked {clicks} times
    </button>
  );
};
```

## Control Flow

### Conditional Rendering

Show or hide elements based on reactive conditions:

```jsx
const UserStatus = () => {
  const user = signal({ name: 'John', isLoggedIn: false });
  
  return (
    <div>
      {user().isLoggedIn ? (
        <p>Welcome back, {user().name}!</p>
      ) : (
        <p>Please log in</p>
      )}
      
      {/* Show/hide with && operator */}
      {user().isLoggedIn && (
        <button onclick={() => user({...user(), isLoggedIn: false})}>
          Logout
        </button>
      )}
    </div>
  );
};
```

### Lists and Iteration

Render dynamic lists with reactive data:

```jsx
const TodoList = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', done: false },
    { id: 2, text: 'Build an app', done: false }
  ]);
  
  const addTodo = (text) => {
    todos([...todos(), { 
      id: Date.now(), 
      text, 
      done: false 
    }]);
  };
  
  return (
    <div>
      <ul>
        {todos().map(todo => (
          <li key={todo.id} class={todo.done ? 'done' : ''}>
            <input 
              type="checkbox" 
              checked={todo.done}
              onchange={e => {
                const updated = todos().map(t => 
                  t.id === todo.id ? { ...t, done: e.target.checked } : t
                );
                todos(updated);
              }}
            />
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
};
```

### Fragments and Children

Use fragments for multiple elements without wrapper divs:

```jsx
const Modal = ({ isOpen, onClose, children }) => {
  return (
    <>
      {isOpen() && (
        <>
          <div class="overlay" onclick={onClose} />
          <div class="modal">
            <button class="close" onclick={onClose}>Ã—</button>
            {children}
          </div>
        </>
      )}
    </>
  );
};

const App = () => {
  const showModal = signal(false);
  
  return (
    <div>
      <button onclick={() => showModal(true)}>Open Modal</button>
      
      <Modal isOpen={showModal} onClose={() => showModal(false)}>
        <h2>Modal Content</h2>
        <p>This is inside the modal!</p>
      </Modal>
    </div>
  );
};
```


## Best Practices

### Reactive Bindings

- Pass signal functions to JSX, not called results: `{count}` not `{count()}`
- Use computed for derived values that multiple elements need
- Keep reactive expressions simple and focused
- Avoid complex calculations in JSX expressions

### Event Handling

- Use arrow functions for simple event handlers
- Create named functions for complex logic
- Pass data through event handlers rather than reading from DOM
- Consider using event delegation for dynamic lists

### Control Flow

- Use ternary operators for simple conditionals
- Use `&&` for show/hide logic
- Use `map()` for dynamic lists
- Always provide `key` props for list items

## JSX Patterns

### Form Handling
```jsx
const ContactForm = () => {
  const formData = signal({ name: '', email: '', message: '' });
  
  const updateField = (field) => (e) => {
    formData({ ...formData(), [field]: e.target.value });
  };
  
  return (
    <form>
      <input 
        value={formData().name}
        oninput={updateField('name')}
        placeholder="Name"
      />
      <input 
        value={formData().email}
        oninput={updateField('email')}
        placeholder="Email"
      />
      <textarea
        value={formData().message}
        oninput={updateField('message')}
        placeholder="Message"
      />
    </form>
  );
};
```

### Loading States
```jsx
const DataComponent = () => {
  const data = resource(() => fetch('/api/data').then(r => r.json()));
  
  return (
    <div>
      {data.loading() && <div>Loading...</div>}
      {data.error() && <div>Error: {data.error().message}</div>}
      {data.data() && (
        <div>
          <h1>{data.data().title}</h1>
          <p>{data.data().content}</p>
        </div>
      )}
    </div>
  );
};
```

## See Also

- [Reactivity](/learn/concepts/reactivity) - Understanding reactive bindings
- [Components](/learn/concepts/components) - Building components with JSX
- [Styling](/learn/concepts/styling) - Styling JSX elements