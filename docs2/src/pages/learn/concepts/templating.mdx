---
layout: ../../../layouts/MainLayout.astro
title: Templating
description: JSX templating with reactive bindings and control flow patterns.
---

import { Icon } from "astro-icon/components";

# Granular Templating

A one-shot render with no virtual DOM or re-render lifecycles. Bind reactive values directly to elements, attributes, and events.

## Reactive Bindings

<div role="alert" class="alert alert-error text-base">
  <Icon name="ph:warning" width={24} height={24} />
  <span>Unlike other frameworks, HellaJS uses function references to create reactive bindings.</span>
</div>

### Text Content

Bind reactive values to text content using a function reference.

✅ Reactive: ` <h1>{count}</h1>`

⛔ Static: ` <h1>{count()}</h1>`

```jsx
const Counter = () => {
  const count = signal(0);
  
  return (
    <div>
      <h1>{count}</h1>
      <button>
        Increment
      </button>
    </div>
  );
};
```

### Attributes and Properties

Bind to any HTML attribute or property using a function reference.

✅ Reactive: `class={() => count() % 2 === 0 ? 'even' : 'odd'}`

⛔ Static: `class={count % 2 === 0 ? 'even' : 'odd'}`

```jsx
const Counter = () => {
  const count = signal(0);
  
  return (
    <div>
      <h1 class={() => count() % 2 === 0 ? 'even' : 'odd'}>{count}</h1>
      <button>
        Increment
      </button>
    </div>
  );
};
```

### Dynamic Strings

✅ Reactive: ` <h1>Count: {count}</h1>`

✅ Reactive: ```<h1>{() => `Count: ${count()}`}</h1>```

⛔ Static: ` <h1>Count: {count()}</h1>`

Bind dynamic strings using a function reference to create reactive content.
```jsx
const Counter = () => {
  const count = signal(0);
  
  return (
    <div>
      <h1>{() => `Count: ${count()}`}</h1>
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

## Templating Approaches

The same principles apply to both JSX and VNode templates. You can use either approach based on your preference.

### JSX Templates

JSX is transformed using one of the [plugins](/plugins). A `VNode` (see next section) with reactive bindings is created for each element.

```jsx
const Counter = () => {
  const count = signal(0);
  const double = () => count() * 2;

  return (
    <div>
      <div class={() => count() % 2 === 0 ? 'even' : 'odd'}>
        <h1>{count}</h1>
        <h2>{double}</h2>
      </div>
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

### VNode Templates

It's possible to template directly using `VNode` objects. This is useful (even if cumbersome) when you want to avoid JSX.

```js
const Counter = () => {
  const count = signal(0);

  return {
    tag: 'div',
    children: [
      {
        tag: 'h1',
        children: `Count: ${count}`
      },
      {
        tag: 'button',
        props: { onclick: () => count(count() + 1) },
        children: 'Increment'
      }
    ]
  };
};

```
## Control Flow

### Conditional Rendering

Show or hide elements based on reactive conditions using function references.

```jsx
const Counter = () => {
  const count = signal(0);
  const double = () => count() * 2;

  return (
    <div>
      <h1>{count}</h1>
      <h2>{double}</h2>
      <p>Count is: {() => count() % 2 === 0 ? 'even' : 'odd'}</p>
      {() => count() > 5 && <p>Count is greater than 5</p>}
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

### Lists and Iteration

Render static lists with dynamic lists with standard array methods or render reactive lists using the optimized `forEach` function.

```jsx
const TodoList = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', done: false },
    { id: 2, text: 'Build an app', done: false }
  ]);
  
  const addTodo = (text) => {
    todos([...todos(), { 
      id: Date.now(), 
      text, 
      done: false 
    }]);
  };
  
  return (
    <div>
      <ul>
        {forEach(todos, todo => (
          <li key={todo.id} class={todo.done ? 'done' : ''}>
            <input 
              type="checkbox" 
              checked={todo.done}
              onchange={e => {
                const updated = todos().map(t => 
                  t.id === todo.id ? { ...t, done: e.target.checked } : t
                );
                todos(updated);
              }}
            />
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
};
```

### Fragments and Children

Use fragments for multiple elements without wrapper divs.

```jsx
const Modal = ({ isOpen, onClose, children }) => {
  return (
    <>
      {() => isOpen() && (
        <>
          <div class="overlay" onclick={onClose} />
          <div class="modal">
            <button class="close" onclick={onClose}>×</button>
            {children}
          </div>
        </>
      )}
    </>
  );
};

const App = () => {
  const showModal = signal(false);
  
  return (
    <div>
      <button onclick={() => showModal(true)}>Open Modal</button>
      
      <Modal isOpen={showModal} onClose={() => showModal(false)}>
        <h2>Modal Content</h2>
        <p>This is inside the modal!</p>
      </Modal>
    </div>
  );
};
```

## Element Lifecycle

<div role="alert" class="alert alert-error text-base">
  <Icon name="ph:warning" width={24} height={24} />
  <span>Unlike other frameworks, lifecycle hooks are tied directly to elements, not component scope.</span>
</div>

### `onUpdate`

Runs any time a reactive value changes an element's content or attributes.

```jsx
const Counter = () => {
  const count = signal(0);
  
  return (
    <div>
      <h1 onUpdate={() => console.log('h1 Updated')}>{count}</h1>
      <button>
        Increment
      </button>
    </div>
  );
};
```

### `onDestroy`
Runs when an element is removed from the DOM.

```jsx
const Counter = () => {
  const count = signal(0);  
  return (
    <div>
      <h1 onDestroy={() => console.log('h1 Destroyed')}>{count}</h1>
      <button onclick={() => count(count() + 1)}>
        Increment
      </button>
    </div>
  );
};
```

## Performance Optimizations

### Untracked Reads

Use `untracked` to read signals without creating dependencies:

```jsx
const DebugComponent = () => {
  const count = signal(0);
  const debugMode = signal(true);
  
  const computed = computed(() => {
    const value = count();
    
    // Read debugMode without making it a dependency
    if (untracked(() => debugMode())) {
      console.log('Debug: count is', value);
    }
    
    return value * 2;
  });
  
  return <div>Doubled count: {computed}</div>;
};
```

### Cleanup with onDestroy

Use onDestroy to clean up resources when the component is removed from the DOM.

```jsx
const Counter = () => {
  const count = signal(0);
  
  const interval = setInterval(() => {
    count(count() + 1);
  }, 1000);

  return (
    <div>
      <h1 onDestroy={() => clearInterval(interval)}>{count}</h1>
    </div>
  );
};