---
layout: ../../../layouts/MainLayout.astro
title: Todo App
description: Learn advanced HellaJS patterns by building a todo app.
---

# Build a Todo App With HellaJS
 
Ready to build something more complex? Let's create a feature-rich todo application that will teach you advanced HellaJS patterns through hands-on development.

**Prerequisites:** Complete the [Counter App Tutorial](/learn/tutorials/counter-app) first to understand signals, computed values, and effects.

## What You'll Learn

This tutorial progressively builds a complete todo application, teaching you:

- **Complex state management** - Managing multiple related pieces of state
- **Array manipulation** - Working with lists of data reactively
- **Form handling** - Capturing and validating user input
- **Conditional rendering** - Showing different UI based on state
- **Computed filtering** - Deriving filtered views from data
- **Inline editing** - Advanced interaction patterns
- **Data persistence** - Saving state across browser sessions
- **Effects for side actions** - Document title updates and more

We'll start simple and add complexity step by step, so you see how each concept builds on the previous ones.

## Setup

Use your favorite package manager to scaffold a new Vite project.

```bash
npm create vite@latest todo-app -- --template vanilla
```

Navigate into your new project directory and install the necessary HellaJS packages, the Vite plugin, and Tailwind CSS v4.

```bash
cd todo-app
npm install @hellajs/core @hellajs/dom @hellajs/store
npm install -D vite-plugin-hellajs @tailwindcss/vite@next
```

Update your `vite.config.js` to use the HellaJS plugin and Tailwind CSS.

```js
// vite.config.js
import { defineConfig } from 'vite';
import viteHellaJS from 'vite-plugin-hellajs';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [viteHellaJS(), tailwindcss()],
});
```

Create a `style.css` file in your `src` directory and import Tailwind:

```css
/* src/style.css */
@import "tailwindcss";
```

Import this CSS file in your `main.js`:

```js
import './style.css';
```

If you're using TypeScript, you can add type definitions for HellaJS. Update your `tsconfig.json`:

```json
{
  "compilerOptions": {
    //...
    "jsx": "preserve",
    "types": ["hellajs"]
    //...
  }
}
```

## Basic Todo List Structure

Let's start with the foundation - a simple todo list that can add, toggle, and delete items. This introduces you to managing arrays in reactive state and basic CRUD operations.

**Learning focus:** Array state management, event handlers, and list rendering.

Replace the content of `main.js` with your first HellaJS todo app:

```jsx
// main.js
import { signal } from "@hellajs/core";
import { mount, forEach } from "@hellajs/dom";
import './style.css';

const TodoApp = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', completed: false },
    { id: 2, text: 'Build a todo app', completed: false }
  ]);
  const newTodoText = signal('');

  const addTodo = () => {
    const text = newTodoText().trim();
    if (!text) return;
    
    todos([
      ...todos(),
      { id: Date.now(), text, completed: false }
    ]);
    newTodoText('');
  };

  const toggleTodo = (id) => {
    todos(todos().map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const removeTodo = (id) => {
    todos(todos().filter(todo => todo.id !== id));
  };

  return (
    <div class="p-4 max-w-md mx-auto">
      <h1 class="text-2xl mb-4 text-center">Todo App</h1>
      
      <div class="flex gap-2 mb-4">
        <input
          type="text"
          value={newTodoText}
          oninput={e => newTodoText(e.target.value)}
          onkeydown={e => e.key === 'Enter' && addTodo()}
          placeholder="What needs to be done?"
          class="flex-1 px-3 py-2 border rounded"
        />
        <button 
          onclick={addTodo}
          class="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Add
        </button>
      </div>

      <ul class="space-y-2">
        {forEach(todos, todo => (
          <li key={todo.id} class="flex items-center gap-2 p-2 border rounded">
            <input
              type="checkbox"
              checked={todo.completed}
              onchange={() => toggleTodo(todo.id)}
            />
            <span class={`flex-1 ${todo.completed ? 'line-through text-gray-500' : ''}`}>
              {todo.text}
            </span>
            <button 
              onclick={() => removeTodo(todo.id)}
              class="px-2 py-1 bg-red-500 text-white rounded text-sm"
            >
              Delete
            </button>
          </li>
        ))}
      </ul>
      
      {() => todos().length === 0 && (
        <div class="text-center text-gray-500 mt-4">
          No todos yet! Add one above.
        </div>
      )}
    </div>
  );
};

mount(TodoApp, '#app');
```

Start the development server to see your app in action:

```bash
npm run dev
```

Your app will be running at `http://localhost:5173`. Add some todos and watch them update automatically!

**Breaking down the fundamentals:**

1. **Array state management** - `signal([...])` creates reactive state for our todo list
2. **Two-way input binding** - `value={newTodoText}` and `oninput` keep input synced with state
3. **CRUD operations** - Add, toggle completion, and delete todos
4. **Reactive rendering** - `{forEach(todos, ...)}` automatically updates when todos change with optimized list diffing
5. **Conditional display** - Empty state shows when no todos exist

**Key pattern:** Notice how we create new arrays for updates (`[...todos(), newTodo]`) instead of mutating existing ones. This is essential for reactive updates!

**Try it out:** Add a few todos, mark some complete, delete others. See how the UI responds instantly to every change.

<details>
<summary>Understanding Array Updates</summary>

When updating arrays in signals, always create new arrays:

```jsx
// ✅ Good - creates new array
todos([...todos(), newTodo]);

// ✅ Good - filters create new array  
todos(todos().filter(todo => todo.id !== id));

// ❌ Bad - mutates existing array
todos().push(newTodo); // Won't trigger updates

// ❌ Bad - modifies in place
todos().splice(index, 1); // Won't trigger updates
```

**Key insight**: Signals detect changes by comparing references, so always return new objects/arrays when updating.

**About forEach**: Use the `forEach` helper for reactive list rendering instead of `.map()`. The `forEach` function provides optimized list diffing and efficient DOM updates when items are added, removed, or reordered.

</details>

## Smart Filtering and Live Statistics

Great! Now you have basic todo functionality. But users often want to focus on specific todos - like seeing only incomplete tasks. Let's add filtering and live statistics using computed values.

**Learning focus:** Computed values for complex derivations, conditional rendering, and reactive UI states.

This step introduces the power of computed values for creating filtered views and statistics that update automatically:

```jsx
import { signal, computed } from "@hellajs/core";
import { mount, forEach } from "@hellajs/dom";
import './style.css';

const TodoApp = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', completed: false },
    { id: 2, text: 'Build a todo app', completed: false },
    { id: 3, text: 'Deploy to production', completed: true }
  ]);
  
  const newTodoText = signal('');
  const filter = signal('all'); // 'all', 'active', 'completed'

  // Computed values automatically recalculate when dependencies change
  const filteredTodos = computed(() => {
    const allTodos = todos();
    switch (filter()) {
      case 'active': return allTodos.filter(t => !t.completed);
      case 'completed': return allTodos.filter(t => t.completed);
      default: return allTodos;
    }
  });

  const stats = computed(() => {
    const allTodos = todos();
    return {
      total: allTodos.length,
      active: allTodos.filter(t => !t.completed).length,
      completed: allTodos.filter(t => t.completed).length
    };
  });

  const addTodo = () => {
    const text = newTodoText().trim();
    if (!text) return;
    
    todos([...todos(), { id: Date.now(), text, completed: false }]);
    newTodoText('');
  };

  const toggleTodo = (id) => {
    todos(todos().map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const removeTodo = (id) => {
    todos(todos().filter(todo => todo.id !== id));
  };

  return (
    <div class="p-4 max-w-md mx-auto">
      <h1 class="text-2xl mb-4 text-center">Todo App</h1>
      
      <div class="flex gap-2 mb-4">
        <input
          type="text"
          value={newTodoText}
          oninput={e => newTodoText(e.target.value)}
          onkeydown={e => e.key === 'Enter' && addTodo()}
          placeholder="What needs to be done?"
          class="flex-1 px-3 py-2 border rounded"
        />
        <button 
          onclick={addTodo}
          class="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Add
        </button>
      </div>

      <div class="flex gap-2 mb-4">
        <button 
          class={() => `px-3 py-1 rounded text-sm ${
            filter() === 'all' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('all')}
        >
          All ({() => stats().total})
        </button>
        <button 
          class={() => `px-3 py-1 rounded text-sm ${
            filter() === 'active' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('active')}
        >
          Active ({() => stats().active})
        </button>
        <button 
          class={() => `px-3 py-1 rounded text-sm ${
            filter() === 'completed' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('completed')}
        >
          Done ({() => stats().completed})
        </button>
      </div>

      <ul class="space-y-2">
        {forEach(filteredTodos, todo => (
          <li key={todo.id} class="flex items-center gap-2 p-2 border rounded">
            <input
              type="checkbox"
              checked={todo.completed}
              onchange={() => toggleTodo(todo.id)}
            />
            <span class={`flex-1 ${todo.completed ? 'line-through text-gray-500' : ''}`}>
              {todo.text}
            </span>
            <button 
              onclick={() => removeTodo(todo.id)}
              class="px-2 py-1 bg-red-500 text-white rounded text-sm"
            >
              Delete
            </button>
          </li>
        ))}
      </ul>
      
      {() => filteredTodos().length === 0 && (
        <div class="text-center text-gray-500 mt-4">
          {() => filter() === 'all' && "No todos yet! Add one above."}
          {() => filter() === 'active' && "No active todos. Great job!"}
          {() => filter() === 'completed' && "No completed todos yet."}
        </div>
      )}
    </div>
  );
};

mount(TodoApp, '#app');
```

**New reactive concepts:**

1. **Computed filtering** - `filteredTodos` automatically shows the right todos based on current filter
2. **Live statistics** - `stats` calculates counts in real-time as todos change
3. **Multiple dependencies** - Computeds can depend on multiple signals (`todos` and `filter`)
4. **Reactive styling** - Button styles change based on active filter
5. **Contextual empty states** - Different messages for different filter states

**Watch the magic:** Click between filter buttons and see how:
- The todo list updates instantly
- Button counts stay accurate
- Empty state messages change contextually
- All without manual DOM manipulation!

**Performance insight:** Even with complex filtering and statistics, HellaJS only recalculates what's actually needed when dependencies change.

<details>
<summary>Understanding Computed Dependencies</summary>

Computed values automatically track what signals they read:

```jsx
const todos = signal([...]);
const filter = signal('all');

// This computed depends on both todos and filter
const filteredTodos = computed(() => {
  const allTodos = todos(); // Tracks todos signal
  switch (filter()) {       // Tracks filter signal
    case 'active': return allTodos.filter(t => !t.completed);
    // ...
  }
});

// Only recalculates when dependencies change
todos([...newTodos]); // filteredTodos recalculates
filter('active');      // filteredTodos recalculates
someOtherSignal(123);  // filteredTodos does NOT recalculate
```

**Performance benefit**: Computeds are cached and only run when their dependencies actually change.

</details>

## Interactive Editing Experience

Todos often need updates after creation. Let's add inline editing - a pattern that showcases advanced reactive state management with multiple coordinated signals.

**Learning focus:** Multi-signal coordination, conditional rendering, and complex user interactions.

This feature introduces editing state management and shows how multiple signals work together:

```jsx
import { signal, computed } from "@hellajs/core";
import { mount, forEach } from "@hellajs/dom";
import './style.css';

const TodoApp = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', completed: false },
    { id: 2, text: 'Build a todo app', completed: false },
    { id: 3, text: 'Deploy to production', completed: true }
  ]);
  
  const newTodoText = signal('');
  const filter = signal('all');
  const editingId = signal(null);
  const editText = signal('');

  const filteredTodos = computed(() => {
    const allTodos = todos();
    switch (filter()) {
      case 'active': return allTodos.filter(t => !t.completed);
      case 'completed': return allTodos.filter(t => t.completed);
      default: return allTodos;
    }
  });

  const stats = computed(() => {
    const allTodos = todos();
    return {
      total: allTodos.length,
      active: allTodos.filter(t => !t.completed).length,
      completed: allTodos.filter(t => t.completed).length
    };
  });

  const addTodo = () => {
    const text = newTodoText().trim();
    if (!text) return;
    
    todos([...todos(), { id: Date.now(), text, completed: false }]);
    newTodoText('');
  };

  const toggleTodo = (id) => {
    todos(todos().map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const removeTodo = (id) => {
    todos(todos().filter(todo => todo.id !== id));
  };

  const startEditing = (id, currentText) => {
    editingId(id);
    editText(currentText);
  };

  const saveEdit = () => {
    const id = editingId();
    const newText = editText().trim();
    
    if (!newText) {
      removeTodo(id);
    } else {
      todos(todos().map(todo =>
        todo.id === id ? { ...todo, text: newText } : todo
      ));
    }
    
    editingId(null);
    editText('');
  };

  const cancelEdit = () => {
    editingId(null);
    editText('');
  };

  const handleEditKeydown = (e) => {
    if (e.key === 'Enter') saveEdit();
    if (e.key === 'Escape') cancelEdit();
  };

  return (
    <div class="p-4 max-w-md mx-auto">
      <h1 class="text-2xl mb-4 text-center">Todo App</h1>
      
      <div class="flex gap-2 mb-4">
        <input
          type="text"
          value={newTodoText}
          oninput={e => newTodoText(e.target.value)}
          onkeydown={e => e.key === 'Enter' && addTodo()}
          placeholder="What needs to be done?"
          class="flex-1 px-3 py-2 border rounded"
        />
        <button 
          onclick={addTodo}
          class="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Add
        </button>
      </div>

      <div class="flex gap-2 mb-4">
        <button 
          class={() => `px-3 py-1 rounded text-sm ${
            filter() === 'all' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('all')}
        >
          All ({() => stats().total})
        </button>
        <button 
          class={() => `px-3 py-1 rounded text-sm ${
            filter() === 'active' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('active')}
        >
          Active ({() => stats().active})
        </button>
        <button 
          class={() => `px-3 py-1 rounded text-sm ${
            filter() === 'completed' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('completed')}
        >
          Done ({() => stats().completed})
        </button>
      </div>

      <ul class="space-y-2">
        {forEach(filteredTodos, todo => (
          <li key={todo.id} class="flex items-center gap-2 p-2 border rounded">
            <input
              type="checkbox"
              checked={todo.completed}
              onchange={() => toggleTodo(todo.id)}
            />
            
            {() => editingId() === todo.id ? (
              <input
                type="text"
                value={editText}
                oninput={e => editText(e.target.value)}
                onkeydown={handleEditKeydown}
                onblur={saveEdit}
                class="flex-1 px-2 py-1 border rounded"
                autofocus
              />
            ) : (
              <span 
                class={`flex-1 cursor-pointer ${todo.completed ? 'line-through text-gray-500' : ''}`}
                ondblclick={() => startEditing(todo.id, todo.text)}
                title="Double-click to edit"
              >
                {todo.text}
              </span>
            )}
            
            <div class="flex gap-1">
              {() => editingId() === todo.id ? (
                <>
                  <button 
                    onclick={saveEdit}
                    class="px-2 py-1 bg-green-500 text-white rounded text-sm"
                  >
                    ✓
                  </button>
                  <button 
                    onclick={cancelEdit}
                    class="px-2 py-1 bg-gray-500 text-white rounded text-sm"
                  >
                    ✕
                  </button>
                </>
              ) : (
                <button 
                  onclick={() => removeTodo(todo.id)}
                  class="px-2 py-1 bg-red-500 text-white rounded text-sm"
                >
                  Delete
                </button>
              )}
            </div>
          </li>
        ))}
      </ul>
      
      {() => filteredTodos().length === 0 && (
        <div class="text-center text-gray-500 mt-4">
          {() => filter() === 'all' && "No todos yet! Add one above."}
          {() => filter() === 'active' && "No active todos. Great job!"}
          {() => filter() === 'completed' && "No completed todos yet."}
        </div>
      )}
    </div>
  );
};

mount(TodoApp, '#app');
```

**Advanced interaction patterns:**

1. **Editing state** - `editingId` and `editText` signals coordinate the editing experience
2. **Conditional UI** - Different rendering based on whether a todo is being edited
3. **Multiple input modes** - Click to edit, keyboard shortcuts to save/cancel
4. **Smart validation** - Empty text automatically deletes the todo
5. **Visual feedback** - UI clearly shows editing mode with different buttons
6. **Event coordination** - Multiple events (double-click, keydown, blur) work together

**Interaction details:**
- **Double-click** any todo text to start editing
- **Enter** saves changes, **Escape** cancels
- **Tab/click away** also saves changes
- **Empty text** deletes the todo (smart cleanup)

**Architecture insight:** Notice how editing doesn't interfere with other features - filtering, statistics, and persistence all continue working. This is the modularity benefit of reactive architecture.

## Persistence and Enhanced User Experience

Now let's make our app production-ready by adding data persistence and user experience enhancements. This showcases how effects handle side actions elegantly.

**Learning focus:** Effects for side actions, error handling, and progressive enhancement.

We'll add several effects that make the app feel professional:

```jsx
import { signal, computed, effect } from "@hellajs/core";
import { mount, forEach } from "@hellajs/dom";
import './style.css';

// Load todos from localStorage
const loadTodos = () => {
  try {
    const saved = localStorage.getItem('hellajs-todos');
    return saved ? JSON.parse(saved) : [
      { id: 1, text: 'Learn HellaJS', completed: false },
      { id: 2, text: 'Build a todo app', completed: false }
    ];
  } catch {
    return [];
  }
};

const TodoApp = () => {
  const todos = signal(loadTodos());
  const newTodoText = signal('');
  const filter = signal('all');
  const editingId = signal(null);
  const editText = signal('');

  // Persist todos to localStorage
  effect(() => {
    localStorage.setItem('hellajs-todos', JSON.stringify(todos()));
  });

  // Update document title
  effect(() => {
    const activeCount = todos().filter(t => !t.completed).length;
    document.title = activeCount === 0 
      ? 'Todo App' 
      : `Todo App (${activeCount} active)`;
  });

  const filteredTodos = computed(() => {
    const allTodos = todos();
    switch (filter()) {
      case 'active': return allTodos.filter(t => !t.completed);
      case 'completed': return allTodos.filter(t => t.completed);
      default: return allTodos;
    }
  });

  const stats = computed(() => {
    const allTodos = todos();
    return {
      total: allTodos.length,
      active: allTodos.filter(t => !t.completed).length,
      completed: allTodos.filter(t => t.completed).length
    };
  });

  const addTodo = () => {
    const text = newTodoText().trim();
    if (!text) return;
    
    todos([...todos(), { id: Date.now(), text, completed: false }]);
    newTodoText('');
  };

  const toggleTodo = (id) => {
    todos(todos().map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const removeTodo = (id) => {
    todos(todos().filter(todo => todo.id !== id));
  };

  const clearCompleted = () => {
    todos(todos().filter(todo => !todo.completed));
  };

  const startEditing = (id, currentText) => {
    editingId(id);
    editText(currentText);
  };

  const saveEdit = () => {
    const id = editingId();
    const newText = editText().trim();
    
    if (!newText) {
      removeTodo(id);
    } else {
      todos(todos().map(todo =>
        todo.id === id ? { ...todo, text: newText } : todo
      ));
    }
    
    editingId(null);
    editText('');
  };

  const cancelEdit = () => {
    editingId(null);
    editText('');
  };

  const handleEditKeydown = (e) => {
    if (e.key === 'Enter') saveEdit();
    if (e.key === 'Escape') cancelEdit();
  };

  return (
    <div class="p-4 max-w-md mx-auto">
      <div class="flex justify-between items-center mb-4">
        <h1 class="text-2xl">Todo App</h1>
        <div class="text-sm text-gray-500">
          {() => stats().active} active, {() => stats().completed} done
        </div>
      </div>
      
      <div class="flex gap-2 mb-4">
        <input
          type="text"
          value={newTodoText}
          oninput={e => newTodoText(e.target.value)}
          onkeydown={e => e.key === 'Enter' && addTodo()}
          placeholder="What needs to be done?"
          class="flex-1 px-3 py-2 border rounded"
        />
        <button 
          onclick={addTodo}
          class="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Add
        </button>
      </div>

      <div class="flex gap-2 mb-4">
        <button 
          class={() => `px-3 py-1 rounded text-sm ${
            filter() === 'all' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('all')}
        >
          All ({() => stats().total})
        </button>
        <button 
          class={() => `px-3 py-1 rounded text-sm ${
            filter() === 'active' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('active')}
        >
          Active ({() => stats().active})
        </button>
        <button 
          class={() => `px-3 py-1 rounded text-sm ${
            filter() === 'completed' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('completed')}
        >
          Done ({() => stats().completed})
        </button>
        
        {() => stats().completed > 0 && (
          <button 
            onclick={clearCompleted}
            class="px-3 py-1 rounded text-sm bg-red-100 text-red-700 hover:bg-red-200"
          >
            Clear Done
          </button>
        )}
      </div>

      <ul class="space-y-2">
        {forEach(filteredTodos, todo => (
          <li key={todo.id} class="flex items-center gap-2 p-2 border rounded">
            <input
              type="checkbox"
              checked={todo.completed}
              onchange={() => toggleTodo(todo.id)}
            />
            
            {() => editingId() === todo.id ? (
              <input
                type="text"
                value={editText}
                oninput={e => editText(e.target.value)}
                onkeydown={handleEditKeydown}
                onblur={saveEdit}
                class="flex-1 px-2 py-1 border rounded"
                autofocus
              />
            ) : (
              <span 
                class={`flex-1 cursor-pointer ${todo.completed ? 'line-through text-gray-500' : ''}`}
                ondblclick={() => startEditing(todo.id, todo.text)}
                title="Double-click to edit"
              >
                {todo.text}
              </span>
            )}
            
            <div class="flex gap-1">
              {() => editingId() === todo.id ? (
                <>
                  <button 
                    onclick={saveEdit}
                    class="px-2 py-1 bg-green-500 text-white rounded text-sm"
                  >
                    ✓
                  </button>
                  <button 
                    onclick={cancelEdit}
                    class="px-2 py-1 bg-gray-500 text-white rounded text-sm"
                  >
                    ✕
                  </button>
                </>
              ) : (
                <button 
                  onclick={() => removeTodo(todo.id)}
                  class="px-2 py-1 bg-red-500 text-white rounded text-sm"
                >
                  Delete
                </button>
              )}
            </div>
          </li>
        ))}
      </ul>
      
      {() => filteredTodos().length === 0 && (
        <div class="text-center text-gray-500 mt-4">
          {() => filter() === 'all' && "No todos yet! Add one above."}
          {() => filter() === 'active' && "No active todos. Great job!"}
          {() => filter() === 'completed' && "No completed todos yet."}
        </div>
      )}
    </div>
  );
};

mount(TodoApp, '#app');
```

**Production-ready enhancements:**

1. **Persistent storage** - `loadTodos()` function with error handling loads saved state
2. **Automatic saving** - Effect saves to localStorage whenever todos change
3. **Dynamic title** - Browser tab shows active todo count
4. **Progressive disclosure** - "Clear Done" button only appears when needed
5. **Rich statistics** - Header shows comprehensive todo counts
6. **Graceful degradation** - Works even if localStorage fails

**Experience the features:**
- Add todos, refresh the page - they persist!
- Watch your browser tab title update with active count
- Complete some todos to see the "Clear Done" button appear
- Try the bulk "Clear Done" action

**Effect patterns demonstrated:**
- **Data persistence** - Automatic localStorage sync
- **UI enhancements** - Document title updates
- **Error resilience** - Try/catch for localStorage operations

**Real-world ready:** This todo app now has the persistence and UX polish expected in production applications.

<details>
<summary>Understanding Effects</summary>

Effects run side effects when dependencies change:

```jsx
// Persist to localStorage whenever todos change
effect(() => {
  localStorage.setItem('todos', JSON.stringify(todos()));
});

// Update document title when active count changes  
effect(() => {
  const activeCount = todos().filter(t => !t.completed).length;
  document.title = `Todo App (${activeCount} active)`;
});

// Effects can return cleanup functions
effect(() => {
  const handleKeydown = (e) => {
    if (e.key === 'Escape') cancelEdit();
  };
  
  document.addEventListener('keydown', handleKeydown);
  return () => document.removeEventListener('keydown', handleKeydown);
});
```

**Key differences**:
- Use `computed()` for derived values that return data
- Use `effect()` for side effects like DOM updates, localStorage, etc.

</details>

## What You've Learned

Congratulations! You've built a production-ready todo application and learned advanced HellaJS patterns:

**Core reactive concepts:**
- **Complex state management** - multiple related signals working together
- **Computed derivations** - filtered lists and live statistics  
- **Effects for persistence** - automatic localStorage synchronization
- **Conditional rendering** - dynamic UI based on state

**Interactive UI patterns:**
- **Form handling** - input validation and submission
- **Inline editing** - double-click to edit with save/cancel
- **Dynamic filtering** - real-time list filtering
- **Bulk operations** - actions affecting multiple items

**User experience features:**
- **Data persistence** - todos survive page reloads
- **Empty states** - helpful messages for different scenarios
- **Visual feedback** - active states and conditional buttons
- **Keyboard shortcuts** - Enter/Escape for editing

## Next Steps

Ready to level up even further? Here are your best next steps:

- **[State Management](/learn/concepts/state)** - Learn advanced state patterns and organization
- **[Components Guide](/learn/concepts/components)** - Build reusable, composable components
- **[Styling Guide](/learn/concepts/styling)** - Add beautiful, dynamic CSS to your applications

The patterns you learned here - complex state management, computed derivations, effects, and clean architecture - are the foundation for any modern reactive application. You're ready to build amazing apps with HellaJS!