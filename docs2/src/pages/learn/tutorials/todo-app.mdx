---
layout: ../../../layouts/MainLayout.astro
title: Todo App
description: Learn advanced HellaJS patterns by building a todo app with forms, lists, filtering, and local storage persistence.
---

# Build a Todo App

Ready to build something more complex? Let's create a feature-rich todo application that will teach you advanced HellaJS patterns. By the end, you'll understand complex state management, form handling, filtering, and data persistence.

**Prerequisites:** Complete the [Counter App Tutorial](/learn/tutorials/counter-app) first to understand signals, computed values, and effects.

## Setup

Use your favorite package manager to scaffold a new Vite project.

```bash
npm create vite@latest todo-app -- --template vanilla
```

Navigate into your new project directory and install the necessary HellaJS packages, the Vite plugin, and Tailwind CSS v4.

```bash
cd todo-app
npm install @hellajs/core @hellajs/dom @hellajs/store
npm install -D vite-plugin-hellajs @tailwindcss/vite@next
```

Update your `vite.config.js` to use the HellaJS plugin and Tailwind CSS.

```js
// vite.config.js
import { defineConfig } from 'vite';
import viteHellaJS from 'vite-plugin-hellajs';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [viteHellaJS(), tailwindcss()],
});
```

Create a `style.css` file in your `src` directory and import Tailwind:

```css
/* src/style.css */
@import "tailwindcss";
```

Import this CSS file in your `main.js`:

```js
import './style.css';
```

If you're using TypeScript, you can add type definitions for HellaJS. Update your `tsconfig.json`:

```json
{
  "compilerOptions": {
    //...
    "jsx": "preserve",
    "types": ["hellajs"]
    //...
  }
}
```

## Basic Todo App

Replace the content of `main.js` with your first HellaJS todo app:

```jsx
// main.js
import { signal } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

const TodoApp = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', completed: false },
    { id: 2, text: 'Build a todo app', completed: false }
  ]);
  const newTodoText = signal('');

  const addTodo = () => {
    const text = newTodoText().trim();
    if (!text) return;
    
    todos([
      ...todos(),
      { id: Date.now(), text, completed: false }
    ]);
    newTodoText('');
  };

  const toggleTodo = (id) => {
    todos(todos().map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const removeTodo = (id) => {
    todos(todos().filter(todo => todo.id !== id));
  };

  return (
    <div class="p-4 max-w-md mx-auto">
      <h1 class="text-2xl mb-4 text-center">Todo App</h1>
      
      <div class="flex gap-2 mb-4">
        <input
          type="text"
          value={newTodoText}
          oninput={e => newTodoText(e.target.value)}
          onkeydown={e => e.key === 'Enter' && addTodo()}
          placeholder="What needs to be done?"
          class="flex-1 px-3 py-2 border rounded"
        />
        <button 
          onclick={addTodo}
          class="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Add
        </button>
      </div>

      <ul class="space-y-2">
        {todos().map(todo => (
          <li key={todo.id} class="flex items-center gap-2 p-2 border rounded">
            <input
              type="checkbox"
              checked={todo.completed}
              onchange={() => toggleTodo(todo.id)}
            />
            <span class={`flex-1 ${todo.completed ? 'line-through text-gray-500' : ''}`}>
              {todo.text}
            </span>
            <button 
              onclick={() => removeTodo(todo.id)}
              class="px-2 py-1 bg-red-500 text-white rounded text-sm"
            >
              Delete
            </button>
          </li>
        ))}
      </ul>
      
      {todos().length === 0 && (
        <div class="text-center text-gray-500 mt-4">
          No todos yet! Add one above.
        </div>
      )}
    </div>
  );
};

mount(TodoApp, document.getElementById('app'));
```

Start the development server to see your app in action:

```bash
npm run dev
```

Your app will be running at `http://localhost:5173`. Add some todos and watch them update automatically!

**What's happening:**
- `signal([...])` creates reactive state for our todo list
- `{newTodoText}` in the input creates a two-way binding
- `onclick` and `onchange` handlers update signals, which automatically updates the UI
- Tailwind classes provide instant styling with no additional CSS needed

<details>
<summary>Understanding Array Updates</summary>

When updating arrays in signals, always create new arrays:

```jsx
// ✅ Good - creates new array
todos([...todos(), newTodo]);

// ✅ Good - filters create new array  
todos(todos().filter(todo => todo.id !== id));

// ❌ Bad - mutates existing array
todos().push(newTodo); // Won't trigger updates

// ❌ Bad - modifies in place
todos().splice(index, 1); // Won't trigger updates
```

**Key insight**: Signals detect changes by comparing references, so always return new objects/arrays when updating.

</details>

## Add Filtering and Statistics

Now let's add computed values for filtering and real-time statistics:

```jsx
import { signal, computed } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

const TodoApp = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', completed: false },
    { id: 2, text: 'Build a todo app', completed: false },
    { id: 3, text: 'Deploy to production', completed: true }
  ]);
  
  const newTodoText = signal('');
  const filter = signal('all'); // 'all', 'active', 'completed'

  // Computed values automatically recalculate when dependencies change
  const filteredTodos = computed(() => {
    const allTodos = todos();
    switch (filter()) {
      case 'active': return allTodos.filter(t => !t.completed);
      case 'completed': return allTodos.filter(t => t.completed);
      default: return allTodos;
    }
  });

  const stats = computed(() => {
    const allTodos = todos();
    return {
      total: allTodos.length,
      active: allTodos.filter(t => !t.completed).length,
      completed: allTodos.filter(t => t.completed).length
    };
  });

  const addTodo = () => {
    const text = newTodoText().trim();
    if (!text) return;
    
    todos([...todos(), { id: Date.now(), text, completed: false }]);
    newTodoText('');
  };

  const toggleTodo = (id) => {
    todos(todos().map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const removeTodo = (id) => {
    todos(todos().filter(todo => todo.id !== id));
  };

  return (
    <div class="p-4 max-w-md mx-auto">
      <h1 class="text-2xl mb-4 text-center">Todo App</h1>
      
      <div class="flex gap-2 mb-4">
        <input
          type="text"
          value={newTodoText}
          oninput={e => newTodoText(e.target.value)}
          onkeydown={e => e.key === 'Enter' && addTodo()}
          placeholder="What needs to be done?"
          class="flex-1 px-3 py-2 border rounded"
        />
        <button 
          onclick={addTodo}
          class="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Add
        </button>
      </div>

      <div class="flex gap-2 mb-4">
        <button 
          class={`px-3 py-1 rounded text-sm ${
            filter() === 'all' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('all')}
        >
          All ({stats().total})
        </button>
        <button 
          class={`px-3 py-1 rounded text-sm ${
            filter() === 'active' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('active')}
        >
          Active ({stats().active})
        </button>
        <button 
          class={`px-3 py-1 rounded text-sm ${
            filter() === 'completed' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('completed')}
        >
          Done ({stats().completed})
        </button>
      </div>

      <ul class="space-y-2">
        {filteredTodos().map(todo => (
          <li key={todo.id} class="flex items-center gap-2 p-2 border rounded">
            <input
              type="checkbox"
              checked={todo.completed}
              onchange={() => toggleTodo(todo.id)}
            />
            <span class={`flex-1 ${todo.completed ? 'line-through text-gray-500' : ''}`}>
              {todo.text}
            </span>
            <button 
              onclick={() => removeTodo(todo.id)}
              class="px-2 py-1 bg-red-500 text-white rounded text-sm"
            >
              Delete
            </button>
          </li>
        ))}
      </ul>
      
      {filteredTodos().length === 0 && (
        <div class="text-center text-gray-500 mt-4">
          {filter() === 'all' && "No todos yet! Add one above."}
          {filter() === 'active' && "No active todos. Great job!"}
          {filter() === 'completed' && "No completed todos yet."}
        </div>
      )}
    </div>
  );
};

mount(TodoApp, document.getElementById('app'));
```

**What's new:**
- `computed(() => ...)` creates derived reactive values
- `filteredTodos` automatically updates when `todos` or `filter` changes
- `stats` computes live counts for all filter buttons
- Filter buttons show active state with conditional Tailwind classes
- Empty states change based on current filter

<details>
<summary>Understanding Computed Dependencies</summary>

Computed values automatically track what signals they read:

```jsx
const todos = signal([...]);
const filter = signal('all');

// This computed depends on both todos and filter
const filteredTodos = computed(() => {
  const allTodos = todos(); // Tracks todos signal
  switch (filter()) {       // Tracks filter signal
    case 'active': return allTodos.filter(t => !t.completed);
    // ...
  }
});

// Only recalculates when dependencies change
todos([...newTodos]); // filteredTodos recalculates
filter('active');      // filteredTodos recalculates
someOtherSignal(123);  // filteredTodos does NOT recalculate
```

**Performance benefit**: Computeds are cached and only run when their dependencies actually change.

</details>

## Add Inline Editing

Let's add the ability to edit todos by double-clicking:

```jsx
import { signal, computed } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

const TodoApp = () => {
  const todos = signal([
    { id: 1, text: 'Learn HellaJS', completed: false },
    { id: 2, text: 'Build a todo app', completed: false },
    { id: 3, text: 'Deploy to production', completed: true }
  ]);
  
  const newTodoText = signal('');
  const filter = signal('all');
  const editingId = signal(null);
  const editText = signal('');

  const filteredTodos = computed(() => {
    const allTodos = todos();
    switch (filter()) {
      case 'active': return allTodos.filter(t => !t.completed);
      case 'completed': return allTodos.filter(t => t.completed);
      default: return allTodos;
    }
  });

  const stats = computed(() => {
    const allTodos = todos();
    return {
      total: allTodos.length,
      active: allTodos.filter(t => !t.completed).length,
      completed: allTodos.filter(t => t.completed).length
    };
  });

  const addTodo = () => {
    const text = newTodoText().trim();
    if (!text) return;
    
    todos([...todos(), { id: Date.now(), text, completed: false }]);
    newTodoText('');
  };

  const toggleTodo = (id) => {
    todos(todos().map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const removeTodo = (id) => {
    todos(todos().filter(todo => todo.id !== id));
  };

  const startEditing = (id, currentText) => {
    editingId(id);
    editText(currentText);
  };

  const saveEdit = () => {
    const id = editingId();
    const newText = editText().trim();
    
    if (!newText) {
      removeTodo(id);
    } else {
      todos(todos().map(todo =>
        todo.id === id ? { ...todo, text: newText } : todo
      ));
    }
    
    editingId(null);
    editText('');
  };

  const cancelEdit = () => {
    editingId(null);
    editText('');
  };

  const handleEditKeydown = (e) => {
    if (e.key === 'Enter') saveEdit();
    if (e.key === 'Escape') cancelEdit();
  };

  return (
    <div class="p-4 max-w-md mx-auto">
      <h1 class="text-2xl mb-4 text-center">Todo App</h1>
      
      <div class="flex gap-2 mb-4">
        <input
          type="text"
          value={newTodoText}
          oninput={e => newTodoText(e.target.value)}
          onkeydown={e => e.key === 'Enter' && addTodo()}
          placeholder="What needs to be done?"
          class="flex-1 px-3 py-2 border rounded"
        />
        <button 
          onclick={addTodo}
          class="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Add
        </button>
      </div>

      <div class="flex gap-2 mb-4">
        <button 
          class={`px-3 py-1 rounded text-sm ${
            filter() === 'all' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('all')}
        >
          All ({stats().total})
        </button>
        <button 
          class={`px-3 py-1 rounded text-sm ${
            filter() === 'active' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('active')}
        >
          Active ({stats().active})
        </button>
        <button 
          class={`px-3 py-1 rounded text-sm ${
            filter() === 'completed' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('completed')}
        >
          Done ({stats().completed})
        </button>
      </div>

      <ul class="space-y-2">
        {filteredTodos().map(todo => (
          <li key={todo.id} class="flex items-center gap-2 p-2 border rounded">
            <input
              type="checkbox"
              checked={todo.completed}
              onchange={() => toggleTodo(todo.id)}
            />
            
            {editingId() === todo.id ? (
              <input
                type="text"
                value={editText}
                oninput={e => editText(e.target.value)}
                onkeydown={handleEditKeydown}
                onblur={saveEdit}
                class="flex-1 px-2 py-1 border rounded"
                autofocus
              />
            ) : (
              <span 
                class={`flex-1 cursor-pointer ${todo.completed ? 'line-through text-gray-500' : ''}`}
                ondblclick={() => startEditing(todo.id, todo.text)}
                title="Double-click to edit"
              >
                {todo.text}
              </span>
            )}
            
            <div class="flex gap-1">
              {editingId() === todo.id ? (
                <>
                  <button 
                    onclick={saveEdit}
                    class="px-2 py-1 bg-green-500 text-white rounded text-sm"
                  >
                    ✓
                  </button>
                  <button 
                    onclick={cancelEdit}
                    class="px-2 py-1 bg-gray-500 text-white rounded text-sm"
                  >
                    ✕
                  </button>
                </>
              ) : (
                <button 
                  onclick={() => removeTodo(todo.id)}
                  class="px-2 py-1 bg-red-500 text-white rounded text-sm"
                >
                  Delete
                </button>
              )}
            </div>
          </li>
        ))}
      </ul>
      
      {filteredTodos().length === 0 && (
        <div class="text-center text-gray-500 mt-4">
          {filter() === 'all' && "No todos yet! Add one above."}
          {filter() === 'active' && "No active todos. Great job!"}
          {filter() === 'completed' && "No completed todos yet."}
        </div>
      )}
    </div>
  );
};

mount(TodoApp, document.getElementById('app'));
```

**What's new:**
- `editingId` and `editText` signals track editing state
- Double-click any todo text to start editing
- Enter saves, Escape cancels editing
- Empty text automatically deletes the todo
- Visual feedback shows save/cancel buttons while editing

Try it: Double-click on any todo text to edit it inline!

## Add Persistence and Effects

Let's add localStorage persistence and document title updates:

```jsx
import { signal, computed, effect } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

// Load todos from localStorage
const loadTodos = () => {
  try {
    const saved = localStorage.getItem('hellajs-todos');
    return saved ? JSON.parse(saved) : [
      { id: 1, text: 'Learn HellaJS', completed: false },
      { id: 2, text: 'Build a todo app', completed: false }
    ];
  } catch {
    return [];
  }
};

const TodoApp = () => {
  const todos = signal(loadTodos());
  const newTodoText = signal('');
  const filter = signal('all');
  const editingId = signal(null);
  const editText = signal('');

  // Persist todos to localStorage
  effect(() => {
    localStorage.setItem('hellajs-todos', JSON.stringify(todos()));
  });

  // Update document title
  effect(() => {
    const activeCount = todos().filter(t => !t.completed).length;
    document.title = activeCount === 0 
      ? 'Todo App' 
      : `Todo App (${activeCount} active)`;
  });

  const filteredTodos = computed(() => {
    const allTodos = todos();
    switch (filter()) {
      case 'active': return allTodos.filter(t => !t.completed);
      case 'completed': return allTodos.filter(t => t.completed);
      default: return allTodos;
    }
  });

  const stats = computed(() => {
    const allTodos = todos();
    return {
      total: allTodos.length,
      active: allTodos.filter(t => !t.completed).length,
      completed: allTodos.filter(t => t.completed).length
    };
  });

  const addTodo = () => {
    const text = newTodoText().trim();
    if (!text) return;
    
    todos([...todos(), { id: Date.now(), text, completed: false }]);
    newTodoText('');
  };

  const toggleTodo = (id) => {
    todos(todos().map(todo =>
      todo.id === id ? { ...todo, completed: !todo.completed } : todo
    ));
  };

  const removeTodo = (id) => {
    todos(todos().filter(todo => todo.id !== id));
  };

  const clearCompleted = () => {
    todos(todos().filter(todo => !todo.completed));
  };

  const startEditing = (id, currentText) => {
    editingId(id);
    editText(currentText);
  };

  const saveEdit = () => {
    const id = editingId();
    const newText = editText().trim();
    
    if (!newText) {
      removeTodo(id);
    } else {
      todos(todos().map(todo =>
        todo.id === id ? { ...todo, text: newText } : todo
      ));
    }
    
    editingId(null);
    editText('');
  };

  const cancelEdit = () => {
    editingId(null);
    editText('');
  };

  const handleEditKeydown = (e) => {
    if (e.key === 'Enter') saveEdit();
    if (e.key === 'Escape') cancelEdit();
  };

  return (
    <div class="p-4 max-w-md mx-auto">
      <div class="flex justify-between items-center mb-4">
        <h1 class="text-2xl">Todo App</h1>
        <div class="text-sm text-gray-500">
          {stats().active} active, {stats().completed} done
        </div>
      </div>
      
      <div class="flex gap-2 mb-4">
        <input
          type="text"
          value={newTodoText}
          oninput={e => newTodoText(e.target.value)}
          onkeydown={e => e.key === 'Enter' && addTodo()}
          placeholder="What needs to be done?"
          class="flex-1 px-3 py-2 border rounded"
        />
        <button 
          onclick={addTodo}
          class="px-4 py-2 bg-blue-500 text-white rounded"
        >
          Add
        </button>
      </div>

      <div class="flex gap-2 mb-4">
        <button 
          class={`px-3 py-1 rounded text-sm ${
            filter() === 'all' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('all')}
        >
          All ({stats().total})
        </button>
        <button 
          class={`px-3 py-1 rounded text-sm ${
            filter() === 'active' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('active')}
        >
          Active ({stats().active})
        </button>
        <button 
          class={`px-3 py-1 rounded text-sm ${
            filter() === 'completed' 
              ? 'bg-blue-500 text-white' 
              : 'bg-gray-200 text-gray-700'
          }`}
          onclick={() => filter('completed')}
        >
          Done ({stats().completed})
        </button>
        
        {stats().completed > 0 && (
          <button 
            onclick={clearCompleted}
            class="px-3 py-1 rounded text-sm bg-red-100 text-red-700 hover:bg-red-200"
          >
            Clear Done
          </button>
        )}
      </div>

      <ul class="space-y-2">
        {filteredTodos().map(todo => (
          <li key={todo.id} class="flex items-center gap-2 p-2 border rounded">
            <input
              type="checkbox"
              checked={todo.completed}
              onchange={() => toggleTodo(todo.id)}
            />
            
            {editingId() === todo.id ? (
              <input
                type="text"
                value={editText}
                oninput={e => editText(e.target.value)}
                onkeydown={handleEditKeydown}
                onblur={saveEdit}
                class="flex-1 px-2 py-1 border rounded"
                autofocus
              />
            ) : (
              <span 
                class={`flex-1 cursor-pointer ${todo.completed ? 'line-through text-gray-500' : ''}`}
                ondblclick={() => startEditing(todo.id, todo.text)}
                title="Double-click to edit"
              >
                {todo.text}
              </span>
            )}
            
            <div class="flex gap-1">
              {editingId() === todo.id ? (
                <>
                  <button 
                    onclick={saveEdit}
                    class="px-2 py-1 bg-green-500 text-white rounded text-sm"
                  >
                    ✓
                  </button>
                  <button 
                    onclick={cancelEdit}
                    class="px-2 py-1 bg-gray-500 text-white rounded text-sm"
                  >
                    ✕
                  </button>
                </>
              ) : (
                <button 
                  onclick={() => removeTodo(todo.id)}
                  class="px-2 py-1 bg-red-500 text-white rounded text-sm"
                >
                  Delete
                </button>
              )}
            </div>
          </li>
        ))}
      </ul>
      
      {filteredTodos().length === 0 && (
        <div class="text-center text-gray-500 mt-4">
          {filter() === 'all' && "No todos yet! Add one above."}
          {filter() === 'active' && "No active todos. Great job!"}
          {filter() === 'completed' && "No completed todos yet."}
        </div>
      )}
    </div>
  );
};

mount(TodoApp, document.getElementById('app'));
```

**Advanced features added:**
- **localStorage persistence** - todos survive page reloads  
- **Document title updates** - shows active count in browser tab
- **Clear completed button** - appears only when there are completed todos
- **Statistics header** - shows active and completed counts
- **Error handling** - graceful fallback if localStorage fails

Try it: Add some todos, refresh the page - they're still there! Check your browser tab title.

<details>
<summary>Understanding Effects</summary>

Effects run side effects when dependencies change:

```jsx
// Persist to localStorage whenever todos change
effect(() => {
  localStorage.setItem('todos', JSON.stringify(todos()));
});

// Update document title when active count changes  
effect(() => {
  const activeCount = todos().filter(t => !t.completed).length;
  document.title = `Todo App (${activeCount} active)`;
});

// Effects can return cleanup functions
effect(() => {
  const handleKeydown = (e) => {
    if (e.key === 'Escape') cancelEdit();
  };
  
  document.addEventListener('keydown', handleKeydown);
  return () => document.removeEventListener('keydown', handleKeydown);
});
```

**Key differences**:
- Use `computed()` for derived values that return data
- Use `effect()` for side effects like DOM updates, localStorage, etc.

</details>

## What You've Learned

Congratulations! You've built a production-ready todo application and learned advanced HellaJS patterns:

**Core reactive concepts:**
- **Complex state management** - multiple related signals working together
- **Computed derivations** - filtered lists and live statistics  
- **Effects for persistence** - automatic localStorage synchronization
- **Conditional rendering** - dynamic UI based on state

**Interactive UI patterns:**
- **Form handling** - input validation and submission
- **Inline editing** - double-click to edit with save/cancel
- **Dynamic filtering** - real-time list filtering
- **Bulk operations** - actions affecting multiple items

**User experience features:**
- **Data persistence** - todos survive page reloads
- **Empty states** - helpful messages for different scenarios
- **Visual feedback** - active states and conditional buttons
- **Keyboard shortcuts** - Enter/Escape for editing

## Next Steps

Ready to level up even further? Here are your best next steps:

- **[State Management](/learn/concepts/state)** - Learn advanced state patterns and organization
- **[Components Guide](/learn/concepts/components)** - Build reusable, composable components
- **[Styling Guide](/learn/concepts/styling)** - Add beautiful, dynamic CSS to your applications

The patterns you learned here - complex state management, computed derivations, effects, and clean architecture - are the foundation for any modern reactive application. You're ready to build amazing apps with HellaJS!