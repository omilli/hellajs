---
layout: ../../../layouts/MainLayout.astro
title: Counter App
description: Learn HellaJS fundamentals by building an interactive counter app.
---

# Build a Counter App With HellaJS

Let's build an interactive counter app to learn the fundamentals of HellaJS. By the end, you'll understand how signals, computed values, and effects work together to create reactive UIs.

## Setup

Use your favorite package manager to scaffold a new Vite project.

```bash
npm create vite@latest counter-app -- --template vanilla
```

Navigate into your new project directory and install the necessary HellaJS packages, the Vite plugin, and Tailwind CSS v4.

```bash
cd counter-app
npm install @hellajs/core @hellajs/dom
npm install -D vite-plugin-hellajs @tailwindcss/vite@next
```

Update your `vite.config.js` to use the HellaJS plugin and Tailwind CSS.

```js
// vite.config.js
import { defineConfig } from 'vite';
import viteHellaJS from 'vite-plugin-hellajs';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [viteHellaJS(), tailwindcss()],
});
```

Create a `style.css` file in your `src` directory and import Tailwind:

```css
/* src/style.css */
@import "tailwindcss";
```

Import this CSS file in your `main.js`:

```js
import './style.css';
```

If you're using TypeScript, you can add type definitions for HellaJS. Update your `tsconfig.json`:

```json
{
  "compilerOptions": {
    //...
    "jsx": "preserve",
    "types": ["hellajs"]
    //...
  }
}
```

## Basic Counter

Replace the content of `main.js` with your first HellaJS app:

```jsx
// main.js
import { signal } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

const Counter = () => {
  const count = signal(0);

  return (
    <div class="p-4 text-center">
      <h1 class="text-2xl mb-4">Counter: {count}</h1>
      <button 
        onclick={() => count(count() + 1)}
        class="px-4 py-2 bg-blue-500 text-white rounded"
      >
        Click me!
      </button>
    </div>
  );
};

mount(Counter, '#app');
```

Start the development server to see your app in action:

```bash
npm run dev
```

Your app will be running at `http://localhost:5173`. Click the button and watch the counter update automatically!

**What's happening:**
- `signal(0)` creates reactive state starting at 0
- `{count}` in JSX creates a reactive binding to the DOM  
- `onclick` updates the signal, which automatically updates the UI
- No virtual DOM or manual DOM manipulation required

<details>
<summary>Understanding Signals</summary>

Signals are the foundation of HellaJS reactivity:

```jsx
const count = signal(0);

// Reading a signal - returns current value
console.log(count()); // 0

// Writing to a signal - triggers updates
count(5); // Sets value to 5, updates UI

// In JSX, pass the signal function (not the value)
<div>{count}</div>  // ✅ Reactive - updates automatically
<div>{count()}</div> // ❌ Static - gets value once
```

The key insight: **JSX expressions expecting reactive values should receive the signal function, not the called result.**

</details>

## Add Computed Values

Now let's add some derived state that updates automatically when the count changes:

```jsx
import { signal, computed } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

const Counter = () => {
  const count = signal(0);
  
  // Computed values automatically recalculate when dependencies change
  const isEven = computed(() => count() % 2 === 0);
  const message = computed(() => 
    count() === 0 ? "Click to start!" : 
    isEven() ? "Even number" : "Odd number"
  );

  return (
    <div class="p-4 text-center">
      <h1 class="text-2xl mb-4">Counter: {count}</h1>
      <p class={`mb-4 ${isEven() ? 'text-green-600' : 'text-blue-600'}`}>
        {message}
      </p>
      <button 
        onclick={() => count(count() + 1)}
        class="px-4 py-2 bg-blue-500 text-white rounded"
      >
        +
      </button>
    </div>
  );
};

mount(Counter, '#app');
```

**What's new:**
- `computed(() => ...)` creates derived reactive values
- `isEven` automatically updates when `count` changes
- `message` depends on both `count` and `isEven`
- Tailwind classes change reactively based on `isEven()`

<details>
<summary>Understanding Computed</summary>

Computed values automatically track their dependencies:

```jsx
const a = signal(1);
const b = signal(2);

// This computed depends on both a and b
const sum = computed(() => a() + b());

// Only runs when dependencies change
const doubled = computed(() => {
  console.log('Calculating doubled'); // Only logs when sum changes
  return sum() * 2;
});

a(5); // sum recalculates, then doubled recalculates
b(3); // sum recalculates, then doubled recalculates  
```

**Performance note**: Computeds are cached - they only recalculate when their dependencies actually change.

</details>

## Add Multiple Controls

Let's create a more full-featured counter with multiple buttons:

```jsx
import { signal, computed } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

const Counter = () => {
  const count = signal(0);
  const isEven = computed(() => count() % 2 === 0);
  const message = computed(() => 
    count() === 0 ? "Click to start!" : 
    isEven() ? `${count()} is even` : `${count()} is odd`
  );

  // Event handler functions
  const increment = () => count(count() + 1);
  const decrement = () => count(Math.max(0, count() - 1));
  const reset = () => count(0);

  return (
    <div class="p-4 text-center">
      <h1 class="text-2xl mb-4">Counter: {count}</h1>
      
      <p class={`mb-4 ${isEven() ? 'text-green-600' : 'text-blue-600'}`}>
        {message}
      </p>
      
      <div class="flex gap-2 justify-center">
        <button 
          onclick={decrement}
          class="px-3 py-2 bg-red-500 text-white rounded"
          disabled={count() === 0}
        >
          -
        </button>
        
        <button 
          onclick={increment}
          class="px-3 py-2 bg-blue-500 text-white rounded"
        >
          +
        </button>
        
        <button 
          onclick={reset}
          class="px-3 py-2 bg-gray-500 text-white rounded"
          disabled={count() === 0}
        >
          Reset
        </button>
      </div>
    </div>
  );
};

mount(Counter, '#app');
```

**New features:**
- Multiple event handlers with different logic
- Conditional disabling of buttons using `disabled={count() === 0}`
- Reactive styling with computed colors
- Simple styling with basic Tailwind classes

## Add Effects

Let's add side effects like updating the document title when the count changes:

```jsx
import { signal, computed, effect } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

const Counter = () => {
  const count = signal(0);
  const isEven = computed(() => count() % 2 === 0);
  const message = computed(() => 
    count() === 0 ? "Click to start!" : 
    isEven() ? `${count()} is even` : `${count()} is odd`
  );

  // Side effect: update document title
  effect(() => {
    document.title = `Counter: ${count()}`;
  });

  // Side effect: log changes (for debugging)
  effect(() => {
    console.log(`Count changed to: ${count()}`);
  });

  const increment = () => count(count() + 1);
  const decrement = () => count(Math.max(0, count() - 1));
  const reset = () => count(0);

  return (
    <div class="p-4 text-center">
      <h1 class="text-2xl mb-4">Counter: {count}</h1>
      <p class={`mb-4 ${isEven() ? 'text-green-600' : 'text-blue-600'}`}>
        {message}
      </p>
      
      <div class="flex gap-2 justify-center">
        <button 
          onclick={decrement} 
          disabled={count() === 0}
          class="px-3 py-2 bg-red-500 text-white rounded"
        >
          -
        </button>
        <button 
          onclick={increment}
          class="px-3 py-2 bg-blue-500 text-white rounded"
        >
          +
        </button>
        <button 
          onclick={reset} 
          disabled={count() === 0}
          class="px-3 py-2 bg-gray-500 text-white rounded"
        >
          Reset
        </button>
      </div>
    </div>
  );
};

mount(Counter, '#app');
```

The CSS is now handled entirely by Tailwind! No additional CSS file is needed since we're using Tailwind's utility classes directly in our JSX. The styles are automatically generated and optimized by Tailwind v4.

**What's new:**
- `effect(() => ...)` runs side effects when dependencies change
- Document title updates automatically as you click
- Console logging for debugging reactive updates
- Simple design using basic Tailwind classes

<details>
<summary>Understanding Effects</summary>

Effects are for side effects that shouldn't return values:

```jsx
// ✅ Good uses for effects
effect(() => {
  document.title = `Count: ${count()}`;
});

effect(() => {
  localStorage.setItem('count', count().toString());
});

effect(() => {
  if (count() > 10) {
    console.warn('Count is getting high!');
  }
});

// ❌ Don't use effects for derived values - use computed instead
const doubled = signal(0);
effect(() => {
  doubled(count() * 2); // Bad - use computed(() => count() * 2)
});
```

</details>

## Advanced Features

Now let's add some advanced features like persistence and keyboard shortcuts:

```jsx
import { signal, computed, effect } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

const Counter = () => {
  // Initialize from localStorage or default to 0
  const count = signal(
    parseInt(localStorage.getItem('counter') || '0', 10)
  );
  
  const isEven = computed(() => count() % 2 === 0);
  const message = computed(() => {
    const value = count();
    if (value === 0) return "Ready to count!";
    if (value >= 10) return `Double digits: ${value}`;
    return isEven() ? `${value} is even` : `${value} is odd`;
  });

  // Persist to localStorage
  effect(() => {
    localStorage.setItem('counter', count().toString());
  });

  // Update document title
  effect(() => {
    document.title = count() === 0 ? 'Counter App' : `Counter: ${count()}`;
  });

  // Keyboard shortcuts
  effect(() => {
    const handleKeydown = (e) => {
      if (e.key === 'ArrowUp') count(count() + 1);
      if (e.key === 'ArrowDown') count(Math.max(0, count() - 1));
      if (e.key === 'Escape') count(0);
    };
    
    document.addEventListener('keydown', handleKeydown);
    return () => document.removeEventListener('keydown', handleKeydown);
  });

  const increment = () => count(count() + 1);
  const decrement = () => count(Math.max(0, count() - 1));
  const reset = () => count(0);

  return (
    <div class="p-4 text-center">
      <h1 class="text-2xl mb-4">Counter: {count}</h1>
      <p class={`mb-4 ${isEven() ? 'text-green-600' : 'text-blue-600'}`}>
        {message}
      </p>
      
      <div class="flex gap-2 justify-center mb-4">
        <button 
          onclick={decrement} 
          disabled={count() === 0}
          class="px-3 py-2 bg-red-500 text-white rounded"
        >
          -
        </button>
        <button 
          onclick={increment}
          class="px-3 py-2 bg-blue-500 text-white rounded"
        >
          +
        </button>
        <button 
          onclick={reset} 
          disabled={count() === 0}
          class="px-3 py-2 bg-gray-500 text-white rounded"
        >
          Reset
        </button>
      </div>
      
      <p class="text-sm">
        Shortcuts: ↑ increment, ↓ decrement, Esc reset
      </p>
    </div>
  );
};

mount(Counter, '#app');
```

**Advanced features added:**
- **localStorage persistence** - your count survives page reloads
- **Keyboard shortcuts** - use arrow keys and Escape for quick interactions
- **Smarter messaging** - different messages for different count ranges
- **Proper cleanup** - event listeners are removed when the component unmounts

Try it: Count to any number, refresh the page, and your count is saved! Use the keyboard shortcuts for faster interaction.

## What You've Learned

Congratulations! You've built a complete reactive application and learned the core concepts of HellaJS:

**Core reactive concepts:**
- **Signals** - reactive state containers that trigger automatic UI updates
- **Computed values** - derived state that recalculates when dependencies change  
- **Effects** - side effects that run automatically when state changes
- **Reactive JSX** - connecting state to DOM elements for automatic updates

**Practical patterns:**
- Event handling with reactive state updates
- Conditional rendering and styling based on state
- State persistence with localStorage
- Global event listeners with proper cleanup
- Progressive enhancement with keyboard shortcuts

## Next Steps

Ready to level up? Here are your best next steps:

- **[Build a Todo App](/learn/tutorials/todo-app)** - Apply these skills to a more complex app
- **[Understanding Reactivity](/learn/concepts/reactivity)** - Deep dive into how the reactive system works
- **[Components Guide](/learn/concepts/components)** - Learn to build reusable, composable components

The patterns you learned here are the foundation for any HellaJS application. You're ready to build amazing reactive web apps!