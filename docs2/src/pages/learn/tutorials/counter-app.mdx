---
layout: ../../../layouts/MainLayout.astro
title: Counter App
description: Learn HellaJS fundamentals by building an interactive counter app.
---

import {Icon} from 'astro-icon/components';

# Build a Counter App With HellaJS

Let's build an interactive counter app to learn the fundamentals of HellaJS step-by-step.

## What You'll Learn

By completing this tutorial, you'll understand:

- **Signals** - How to create and use reactive state
- **Computed Values** - How to derive state automatically 
- **Effects** - How to run side effects when state changes
- **Event Handling** - How to respond to user interactions
- **Reactive UI** - How HellaJS connects state to the DOM

Each section builds on the previous one, so you'll see how these concepts work together to create reactive applications.

## Project Setup

### Installation

Use your favorite package manager to scaffold a new Vite project.

```bash
npm create vite@latest counter-app -- --template vanilla
```

Navigate into your new project directory and install the HellaJS packages, Vite plugin, and Tailwind CSS.

```bash
cd counter-app
npm install @hellajs/core @hellajs/dom
npm install -D vite-plugin-hellajs @tailwindcss/vite@next
```

### Configuration

Update your `vite.config.js` to use the HellaJS plugin and Tailwind CSS.

```js
// vite.config.js
import { defineConfig } from 'vite';
import viteHellaJS from 'vite-plugin-hellajs';
import tailwindcss from '@tailwindcss/vite';

export default defineConfig({
  plugins: [viteHellaJS(), tailwindcss()],
});
```

If you're using TypeScript, you can add type definitions for HellaJS. Update your `tsconfig.json`:

```json
{
  "compilerOptions": {
    //...
    "jsx": "preserve",
    "types": ["hellajs"]
    //...
  }
}
```

Finally, import Tailwind into your css file.

```css
@import "tailwindcss";
```

## Reactive Component

[Components](/learn/concepts/templates#components) are simply functions that return an element and [signals](/reference/core/signal) automatically update when their values change.

Replace the content of `main.js` with the following:

```jsx
import { signal } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import './style.css';

const Counter = () => {
  const count = signal(0);

  return (
    <div class="p-4 text-center">
      <h1 class="text-2xl mb-4">Counter: {count}</h1>
      <button 
        onclick={() => count(count() + 1)}
        class="px-4 py-2 bg-blue-500 text-white rounded"
      >
        Click me!
      </button>
    </div>
  );
};

mount(Counter, '#app');
```

Start the development server with `npm run dev` to see the app in action.

### Code Explination

1. **`signal(0)`** - Creates a reactive state with an intial value of 0
2. **`{count}`** - Creates a reactive binding that updates automatically
3. **`onclick={() => count(count() + 1)}`** - Updates the signal value
4. **`mount(Counter, '#app')`** - Renders the component into the DOM

### Important Information

<div role="alert" class="alert alert-error text-base">
  <Icon name="ph:warning" width={24} height={24} />
  <span>Unlike other frameworks, HellaJS uses function references to create reactive bindings.</span>
</div>

✅ Reactive: ` <h1>{count}</h1>`

⛔ Static: ` <h1>{count()}</h1>`

## Derived State

What if you want to show information that depends on the count? We can use derived functions or [computed](/reference/core/computed) (memoized) values.

```jsx
import { signal, computed } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import "./global.css";

const Counter = () => {
  const count = signal(0);
  
  const isEven = computed(() => count() % 2 === 0);
  const message = computed(() => 
    count() === 0 ? "Click to start!" : 
    isEven() ? "Even number" : "Odd number"
  );

  return (
    <div class="p-4 text-center">
      <h1 class="text-2xl mb-4">Counter: {count}</h1>
      <p class={["mb-4", () => isEven() ? 'text-green-600' : 'text-blue-600']}>
        {message}
      </p>
      <button 
        onclick={() => count(count() + 1)}
        class="px-4 py-2 bg-blue-500 text-white rounded"
      >
        +
      </button>
    </div>
  );
};

mount(Counter, '#app');
```

### Code Explanation

1. **`computed(() => count() % 2 === 0)`** - Creates a derived value that updates when `count` changes
2. **Dependency tracking** - `message` depends on both `count` and `isEven`, so it updates when either changes
3. **Reactive styling** - The dyanmic [class](/learn/concepts/styling#traditional-css-classes) changes automatically based on `isEven()`
4. **Performance** - [Computed](/reference/core/computed) is cached and only recalculate when dependencies actually change

You don't need to manually update `isEven` or `message`, dependencies automatically update only when necessary.

### Important Information

You don't need [computed](/reference/core/computed) for simple derived state. You can use regular functions instead.

✅ Reactive: `const isEven = () => count() % 2 === 0;`

✅ Memoized: `const isEven = computed(() => count() % 2 === 0);`

## Conditional Controls

Let's make our counter more interactive by adding multiple ways to change the count.

Add increment, decrement, and reset buttons, plus some smart button disabling.

```jsx
import { signal, computed } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import "./global.css";

const Counter = () => {
  const count = signal(0);
  const isEven = computed(() => count() % 2 === 0);
  const message = computed(() => 
    count() === 0 ? "Click to start!" : 
    isEven() ? `${count()} is even` : `${count()} is odd`
  );

  // Event handler functions
  const increment = () => count(count() + 1);
  const decrement = () => count(count() - 1);
  const reset = () => count(0);

  return (
    <div class="p-4 text-center">
      <h1 class="text-2xl mb-4">Counter: {count}</h1>
      
      <p class={["mb-4", () => isEven() ? 'text-green-600' : 'text-blue-600']}>
        {message}
      </p>
      
      <div class="flex gap-2 justify-center">
        <button 
          onclick={decrement}
          class="px-3 py-2 bg-red-500 text-white rounded"
          disabled={() => count() === 0}
        >
          -
        </button>
        
        <button 
          onclick={increment}
          class="px-3 py-2 bg-blue-500 text-white rounded"
        >
          +
        </button>
        
        <button 
          onclick={reset}
          class="px-3 py-2 bg-gray-500 text-white rounded"
          disabled={() => count() === 0}
        >
          Reset
        </button>
      </div>
    </div>
  );
};

mount(Counter, '#app');
```

### Code Explanation

1. **Event handler functions** - Simple functions that update state
2. **Conditional attributes** - `disabled={() => count() === 0}` disables buttons reactively

### Important Information

Events are delegated to the `document.body` and automatically cleaned when elements are removed from the DOM.

## Signal Side Effects

What about actions that happen when state changes? Like updating the browser tab title or saving to localStorage?

Effects run side effects automatically when their dependencies change

```jsx
import { signal, computed, effect } from "@hellajs/core";
import { mount } from "@hellajs/dom";
import "./global.css";

const Counter = () => {
  const count = signal(0);
  const isEven = computed(() => count() % 2 === 0);
  const message = computed(() => 
    count() === 0 ? "Click to start!" : 
    isEven() ? `${count()} is even` : `${count()} is odd`
  );

  // Side effect: update document title
  effect(() => {
    document.title = `Counter: ${count()}`;
  });

  const increment = () => count(count() + 1);
  const decrement = () => count(Math.max(0, count() - 1));
  const reset = () => count(0);

  return (
    <div class="p-4 text-center">
      <h1 class="text-2xl mb-4">Counter: {count}</h1>
      <p class={`mb-4 ${isEven() ? 'text-green-600' : 'text-blue-600'}`}>
        {message}
      </p>
      
      <div class="flex gap-2 justify-center">
        <button 
          onclick={decrement} 
          disabled={count() === 0}
          class="px-3 py-2 bg-red-500 text-white rounded"
        >
          -
        </button>
        <button 
          onclick={increment}
          class="px-3 py-2 bg-blue-500 text-white rounded"
        >
          +
        </button>
        <button 
          onclick={reset} 
          disabled={count() === 0}
          class="px-3 py-2 bg-gray-500 text-white rounded"
        >
          Reset
        </button>
      </div>
    </div>
  );
};

mount(Counter, '#app');
```

The CSS is now handled entirely by Tailwind! No additional CSS file is needed since we're using Tailwind's utility classes directly in our JSX. The styles are automatically generated and optimized by Tailwind v4.

### Code Explanation

1. **`effect(() => { document.title = ... })`** - Side effect that runs when `count` changes

### Important Information


Don't use [effects](/reference/core/effect) for values that return data, use them for actions like DOM updates, network requests, or logging.

```jsx
// ✅ Good uses for effects
effect(() => {
  document.title = `Count: ${count()}`;
});

// ❌ Don't use effects for derived values - use computed instead
const doubled = signal(0);
effect(() => {
  doubled(count() * 2); // Bad - use computed(() => count() * 2)
});
```

## What You've Learned

Congratulations! You've built a complete reactive application and learned the core concepts of HellaJS:

**Core reactive concepts:**
- **Signals** - reactive state containers that trigger automatic UI updates
- **Computed values** - derived state that recalculates when dependencies change  
- **Effects** - side effects that run automatically when state changes
- **Reactive JSX** - connecting state to DOM elements for automatic updates

**Practical patterns:**
- Event handling with reactive state updates
- Conditional rendering and styling based on state

## Next Steps

Ready to level up? Here are your best next steps:

- **[Build a Todo App](/learn/tutorials/todo-app)** - Apply these skills to a more complex app
- **[Understanding Reactivity](/learn/concepts/reactivity)** - Deep dive into how the reactive system works
- **[Components Guide](/learn/concepts/components)** - Learn to build reusable, composable components

The patterns you learned here are the foundation for any HellaJS application. You're ready to build amazing reactive web apps!