# element

DOM manipulation with reactive support and lazy execution for imperative DOM interactions.

## API

```typescript
function element<T extends Element = Element>(
  selector: string
): ReactiveElement<T>

interface ReactiveElement<T extends Element = Element> {
  node: T | null;
  text(value: string | Signal<string> | (() => string)): ReactiveElement<T>;
  attr(attributes: HellaProps): ReactiveElement<T>;
  on(type: string, handler: EventListener): ReactiveElement<T>;
  onLoad(callback: () => void): ReactiveElement<T>;
}
```

### `text`

Sets the text content of the selected element. Automatically detects form elements (input, textarea, select) and sets their `value` property instead of `textContent`.

```jsx
// Regular elements - sets textContent
element('.title').text('Hello World');

// Form elements - sets value property
element('#username').text('john@example.com');
element('#message').text('Type your message here...');

// Reactive text with signal
const message = signal('Dynamic content');
element('.title').text(message);

// Works with all element types reactively
element('#search-input').text(() => `Search: ${query()}`);
```

### `attr`

Sets attributes on the selected element using an object. Supports static values, signals, and functions.

```jsx
// Static attributes
element('.button').attr({ 
  disabled: true,
  class: 'btn btn-primary'
});

// Multiple attributes at once
element('.node').attr({
  'data-value': 'static',
  class: ['btn', 'btn-primary', 'large'],
  id: 'unique-id'
});

// Reactive attributes
const isActive = signal(false);
element('.button').attr({ 
  class: () => isActive() ? 'active' : 'inactive' 
});

// Mixed static and reactive
const status = signal('online');
element('.user').attr({
  'data-static': 'fixed-value',
  'data-status': status,
  class: () => `user ${status()}`
});
```

### `on`

Attaches an event handler using HellaJS's efficient event delegation system.

```jsx
element('.button').on('click', () => {
  console.log('Button clicked!');
});

element('.input').on('input', (e) => {
  console.log('Input value:', e.target.value);
});
```

### `onLoad`

Executes a callback when the element enters the DOM. If the element is already connected, the callback fires immediately. If the element doesn't exist yet, the callback is registered and fires when a matching element is added.

```jsx
// Execute when element is ready
element('.dynamic-content').onLoad(() => {
  console.log('Element loaded!');
});

// Works with elements that don't exist yet
element('.future-element').onLoad(() => {
  console.log('Element was added to DOM!');
});

// Chain with other operations
element('.widget')
  .onLoad(() => console.log('Widget ready'))
  .text('Initialized')
  .attr({ class: 'ready' });
```

### `node`

Provides access to the raw DOM element. Returns `null` if no element was found.

```jsx
const wrapper = element('.my-element');
if (wrapper.node) {
  wrapper.node.focus();
}
```

## Basic Usage

Use `element` to enhance existing DOM elements with reactive behavior.

```jsx
import { signal } from '@hellajs/core';
import { element } from '@hellajs/dom';

const count = signal(0);

// Single element enhancement
element('.counter').text(count);
element('.increment').on('click', () => count(count() + 1));

// For multiple elements, use the elements() function instead
```

## Key Concepts

### Method Chaining

All methods return the ReactiveElement, enabling fluent method chaining:

```jsx
element('.node')
  .text('Hello')
  .attr({ class: 'active', 'data-value': someSignal })
  .on('click', handleClick);
```

### Reactive Integration

The `element` function integrates with HellaJS's reactive system:

```jsx
const user = signal({ name: 'John', status: 'online' });

element('.user-name').text(() => user().name);
element('.user-status').attr({ 
  class: () => `status ${user().status}`,
  'data-user': () => user().name
});

// When user() changes, both elements update automatically
user({ name: 'Jane', status: 'offline' });
```

### Lazy Execution

Operations automatically adapt to element connection state:

```jsx
const el = element('.my-element');

// If connected: executes immediately
el.text('Hello');
el.attr({ class: 'active' });

// If disconnected: operations queue until element enters DOM
const disconnectedEl = document.createElement('div');
const wrapper = element('.not-yet-added');
wrapper.text('Queued'); // Queued for execution
wrapper.attr({ class: 'pending' }); // Queued

// When element is added to DOM, queued operations execute
document.body.appendChild(disconnectedEl);
```

### Working with Dynamic Elements

Use `onLoad()` to work with elements that will be added later:

```jsx
// Register operations before element exists
element('.future-widget')
  .onLoad(() => console.log('Widget loaded'))
  .text('Dynamic content')
  .attr({ 'data-initialized': 'true' })
  .on('click', handleClick);

// Later, when the element is added to DOM...
const widget = document.createElement('div');
widget.className = 'future-widget';
document.body.appendChild(widget);
// All operations execute: onLoad callback, text, attributes, and event handler
```

### Error Handling

The `element` function gracefully handles missing elements:

```jsx
// If .nonexistent doesn't exist, operations queue (no errors thrown)
element('.nonexistent')
  .text('test')
  .attr({ class: 'x' })
  .on('click', fn);

// Check if element currently exists
const wrapper = element('.maybe-exists');
if (wrapper.node) {
  // Element exists in DOM right now
  wrapper.text('Found!');
}
```
