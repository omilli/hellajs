import type { VNode, VNodeValue, HellaElement } from "./types";
import { DOC, isVNode } from "./utils";

/**
 * Template function that takes a context object and returns a VNode
 */
export interface TemplateFunction {
  (context: Record<string, unknown>): VNode;
}

/**
 * Metadata for a cached template
 */
export interface TemplateMetadata {
  id: string;
  template: TemplateFunction;
  staticStructure: boolean;
  paramNames: string[];
}

/**
 * Template instance with bound context and reusable node
 */
interface TemplateInstance {
  context: Record<string, unknown>;
  node: Node;
  element: HellaElement;
  lastUpdate: number;
}

/**
 * Global template registry and optimization manager
 */
class TemplateManager {
  private static instance: TemplateManager;
  private templates = new Map<string, TemplateMetadata>();
  private instancePool = new Map<string, TemplateInstance[]>();
  private activeInstances = new Map<string, TemplateInstance[]>();
  private bindingCache = new Map<string, WeakMap<Record<string, unknown>, VNode>>();
  private maxPoolSize = 50;
  private maxCacheSize = 100;
  private cleanupThreshold = 1000;
  private lastCleanup = Date.now();

  static getInstance(): TemplateManager {
    if (!TemplateManager.instance) {
      TemplateManager.instance = new TemplateManager();
    }
    return TemplateManager.instance;
  }

  /**
   * Register a template from Babel plugin
   */
  registerTemplate(metadata: TemplateMetadata): void {
    this.templates.set(metadata.id, metadata);
    this.instancePool.set(metadata.id, []);
    this.activeInstances.set(metadata.id, []);
    this.bindingCache.set(metadata.id, new WeakMap());
  }

  /**
   * Get a cached template binding or create new one
   */
  bindTemplate(templateId: string, context: Record<string, unknown>): VNode | null {
    const metadata = this.templates.get(templateId);
    if (!metadata) return null;

    const cache = this.bindingCache.get(templateId);
    if (cache?.has(context)) {
      return cache.get(context)!;
    }

    const vNode = metadata.template(context);
    
    // Cache the binding for static structures
    if (metadata.staticStructure && cache) {
      if (cache.size > this.maxCacheSize) {
        // Simple LRU cleanup
        const entries = Array.from(cache.entries());
        entries.slice(0, this.maxCacheSize / 2).forEach(([key]) => cache.delete(key));
      }
      cache.set(context, vNode);
    }

    return vNode;
  }

  /**
   * Get a reusable template instance from pool or create new one
   */
  acquireInstance(templateId: string, context: Record<string, unknown>): TemplateInstance | null {
    const pool = this.instancePool.get(templateId);
    if (!pool) return null;

    let instance = pool.pop();
    
    if (!instance) {
      // Create new instance
      const vNode = this.bindTemplate(templateId, context);
      if (!vNode || !isVNode(vNode)) return null;

      const element = DOC.createElement(vNode.tag as string) as HellaElement;
      instance = {
        context,
        node: element,
        element,
        lastUpdate: Date.now()
      };
    } else {
      // Update existing instance context
      instance.context = context;
      instance.lastUpdate = Date.now();
    }

    const activeList = this.activeInstances.get(templateId);
    activeList?.push(instance);

    return instance;
  }

  /**
   * Return a template instance to the pool for reuse
   */
  releaseInstance(templateId: string, instance: TemplateInstance): void {
    const activeList = this.activeInstances.get(templateId);
    if (activeList) {
      const index = activeList.indexOf(instance);
      if (index > -1) {
        activeList.splice(index, 1);
      }
    }

    const pool = this.instancePool.get(templateId);
    if (pool && pool.length < this.maxPoolSize) {
      pool.push(instance);
    }

    // Periodic cleanup
    if (Date.now() - this.lastCleanup > this.cleanupThreshold) {
      this.cleanup();
    }
  }

  /**
   * Check if a template is registered and can be optimized
   */
  hasTemplate(templateId: string): boolean {
    return this.templates.has(templateId);
  }

  /**
   * Get template metadata
   */
  getTemplate(templateId: string): TemplateMetadata | undefined {
    return this.templates.get(templateId);
  }

  /**
   * Cleanup old instances and optimize memory usage
   */
  private cleanup(): void {
    const cutoff = Date.now() - (5 * 60 * 1000); // 5 minutes ago

    for (const [templateId, instances] of this.instancePool) {
      const filtered = instances.filter(instance => instance.lastUpdate > cutoff);
      this.instancePool.set(templateId, filtered.slice(0, this.maxPoolSize / 2));
    }

    this.lastCleanup = Date.now();
  }

  /**
   * Clear all templates and instances (for testing/cleanup)
   */
  clear(): void {
    this.templates.clear();
    this.instancePool.clear();
    this.activeInstances.clear();
    this.bindingCache.clear();
  }
}

/**
 * Utility function generated by Babel plugin for template binding
 */
export function __hellaUtilBindTemplate(
  templateId: string,
  context: Record<string, unknown>
): VNode | VNodeValue {
  const manager = TemplateManager.getInstance();
  const vNode = manager.bindTemplate(templateId, context);
  return vNode || context;
}

/**
 * Enhanced utility for template-aware forEach optimization
 */
export function __hellaUtilOptimizedForEach<T>(
  templateId: string,
  items: T[],
  paramNames: string[],
  mapper: (item: T, index: number) => VNodeValue
): VNodeValue[] {
  const manager = TemplateManager.getInstance();
  
  if (!manager.hasTemplate(templateId)) {
    // Fallback to regular mapping
    return items.map(mapper);
  }

  return items.map((item, index) => {
    const context = Object.fromEntries(
      paramNames.map((name, i) => [
        name,
        i === 0 ? item : i === 1 ? index : undefined
      ]).filter(([, value]) => value !== undefined)
    );

    return manager.bindTemplate(templateId, context) || mapper(item, index);
  });
}

// Export the singleton instance for direct access
export const templateManager = TemplateManager.getInstance();