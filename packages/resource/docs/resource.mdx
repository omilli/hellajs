# resource

Reactive async data fetching with caching, abort, and mutation.

## API

```typescript
// Overload for simple URL fetching
function resource<T>(url: string, options?: ResourceOptions<T, string>): Resource<T>;

// Overload for custom fetcher functions
function resource<T, K>(fetcher: (key: K) => Promise<T>, options?: ResourceOptions<T, K>): Resource<T>;

// The returned resource object
interface Resource<T> {
  data: () => (T | undefined);
  error: () => (ResourceError | undefined);
  loading: () => boolean;
  status: () => ResourceStatus;
  get(): void;
  request(): void;
  abort(): void;
  invalidate(): void;
  setData: (updater: T | ((old: T | undefined) => T)) => void;
  cacheKey: () => unknown;
  mutate: <TVariables = any>(variables: TVariables) => Promise<T>;
  reset(): void;
}

type ResourceStatus = "idle" | "loading" | "success" | "error";

type ResourceErrorCategory =
  | 'network'       // Network connectivity issues
  | 'validation'    // Data validation failures
  | 'authorization' // Authentication/permission failures
  | 'not_found'     // Resource not found (404)
  | 'server'        // Server errors (5xx)
  | 'client'        // Client errors (4xx)
  | 'timeout'       // Request timeout
  | 'abort'         // Request was cancelled
  | 'unknown';      // Unclassified errors

interface ResourceError {
  /** Human-readable error message */
  message: string;
  /** Categorized error type for structured handling */
  category: ResourceErrorCategory;
  /** HTTP status code if available */
  statusCode?: number;
  /** Original error object for debugging */
  originalError?: unknown;
}

interface ResourceOptions<T, K> {
  /** Function to generate cache key or static key value */
  key?: (() => K) | K;
  /** Whether the resource can make requests (default: true) */
  enabled?: boolean;
  /** Auto-refetch when key dependencies change (default: false) */
  auto?: boolean;
  /** Initial data before first request completes */
  initialData?: T;
  /** Cache TTL in milliseconds (0 = no caching) */
  cacheTime?: number;
  /** Request timeout in milliseconds */
  timeout?: number;
  /** External abort signal for cancellation */
  abortSignal?: AbortSignal;
  /** Deduplicate concurrent requests with same key (default: true) */
  deduplicate?: boolean;
  /** Callback when request succeeds */
  onSuccess?: (data: T) => void;
  /** Callback when request fails */
  onError?: (err: unknown) => void;
  /** Hook for optimistic updates before mutation */
  onMutate?: <TVariables, TContext = unknown>(variables: TVariables) => Promise<TContext> | TContext;
  /** Hook after mutation completion (success or error) */
  onSettled?: <TVariables, TContext = unknown>(data?: T, error?: unknown, variables?: TVariables, context?: TContext) => Promise<void> | void;
}
```

### `data`

Reactive signal containing the fetched data or undefined if not yet loaded.

```typescript
import { resource } from '@hellajs/resource';
import { effect } from '@hellajs/core';

const userResource = resource(() =>
  fetch('/api/user').then(r => r.json())
);

effect(() => {
  const data = userResource.data();
  if (data) {
    console.log('User name:', data.name);
  }
});

userResource.get();
```

### `error`

Reactive signal containing error information if the request failed.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(() =>
  fetch('/api/user').then(r => r.json())
);

effect(() => {
  const error = userResource.error();
  if (error) {
    console.log('Error category:', error.category);
    console.log('Error message:', error.message);
    if (error.statusCode) {
      console.log('HTTP status:', error.statusCode);
    }
  }
});

userResource.get();
```

### `loading`

Reactive signal indicating if a request is currently in progress.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(() =>
  fetch('/api/user').then(r => r.json())
);

effect(() => {
  if (userResource.loading()) {
    console.log('Loading user data...');
  }
});

userResource.get();
```

### `status`

Computed signal showing the current resource status.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(() =>
  fetch('/api/user').then(r => r.json())
);

effect(() => {
  const status = userResource.status();
  switch (status) {
    case 'idle':
      console.log('Resource not fetched yet');
      break;
    case 'loading':
      console.log('Fetching data...');
      break;
    case 'success':
      console.log('Data loaded successfully');
      break;
    case 'error':
      console.log('Failed to load data');
      break;
  }
});

userResource.get();
```

### `get`

Initiates a cache-first fetch. Uses cached data if valid, otherwise makes a network request.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(
  () => fetch('/api/user').then(r => r.json()),
  { cacheTime: 300000 } // 5 minutes
);

// First call - makes network request
userResource.get();

// Second call within 5 minutes - uses cached data
setTimeout(() => {
  userResource.get(); // Returns cached data immediately
}, 1000);
```

### `request`

Forces a fresh request, bypassing any cached data.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(
  () => fetch('/api/user').then(r => r.json()),
  { cacheTime: 300000 }
);

// Force fresh data (ignores cache)
userResource.request();
```

### `abort`

Cancels the ongoing request and resets resource to initial state.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(
  () => fetch('/api/slow-endpoint').then(r => r.json()),
  { initialData: null }
);

userResource.get();

// Cancel the request after 1 second
setTimeout(() => {
  userResource.abort();
  console.log('Request cancelled');
  console.log('Data:', userResource.data()); // Back to initialData
}, 1000);
```

### `invalidate`

Clears the cache entry and triggers a fresh request.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(
  () => fetch('/api/user').then(r => r.json()),
  { cacheTime: 300000 }
);

// After updating user data elsewhere
async function updateUser(data) {
  await fetch('/api/user', {
    method: 'PUT',
    body: JSON.stringify(data)
  });

  // Invalidate cache and refetch fresh data
  userResource.invalidate();
}
```

### `setData`

Updates cached data with a new value or updater function.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(
  () => fetch('/api/user').then(r => r.json()),
  { cacheTime: 300000 }
);

// Update with new value
userResource.setData({ id: 1, name: 'Updated Name' });

// Update with function
userResource.setData(old => ({
  ...old,
  lastSeen: Date.now()
}));
```

### `cacheKey`

Returns the current cache key used for this resource.

```typescript
import { resource } from '@hellajs/resource';
import { signal } from '@hellajs/core';

const userId = signal(1);
const userResource = resource(
  (id) => fetch(`/api/users/${id}`).then(r => r.json()),
  { key: () => `user:${userId()}` }
);

console.log(userResource.cacheKey()); // 'user:1'

userId(2);
console.log(userResource.cacheKey()); // 'user:2'
```

### `mutate`

Executes a mutation with given variables, supporting optimistic updates.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(
  async (userData) => {
    const response = await fetch('/api/user', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(userData)
    });
    return response.json();
  },
  {
    onMutate: async (variables) => {
      // Optimistic update
      console.log('Starting mutation with:', variables);
      return { previousData: userResource.data() };
    },
    onSettled: async (data, error, variables, context) => {
      if (error) {
        console.log('Mutation failed, rollback if needed');
        // Could restore context.previousData here
      } else {
        console.log('Mutation succeeded:', data);
      }
    }
  }
);

// Execute mutation
try {
  const result = await userResource.mutate({
    name: 'John Doe',
    email: 'john@example.com'
  });
  console.log('Created user:', result);
} catch (error) {
  console.error('Mutation failed:', error);
}
```

### `reset`

Resets resource state to initial values, clearing data and errors.

```typescript
import { resource } from '@hellajs/resource';

const userResource = resource(
  () => fetch('/api/user').then(r => r.json()),
  { initialData: null }
);

userResource.get();
// ... resource has data or error

// Reset to clean state
userResource.reset();
console.log(userResource.data()); // null (initialData)
console.log(userResource.error()); // undefined
console.log(userResource.status()); // 'idle'
```

## Key Concepts

### Cache Keys
The `key` option is used for caching and deduplication. You can provide either a static value for simple cases or a function for reactive behavior.

#### Static Keys
For resources that don't depend on changing parameters, use a static string or value:

```typescript
const configResource = resource(
  () => fetch('/api/config').then(r => r.json()),
  { key: 'app-config' } // Static string key
);

const userProfileResource = resource(
  () => fetch('/api/me').then(r => r.json()),
  { key: 'current-user' } // Another static key
);
```

#### Reactive Keys
For dynamic resources that depend on other reactive state, use a function that returns the key:

```typescript
const userId = signal(1);

const userResource = resource(
  (id) => fetch(`/api/users/${id}`).then(r => r.json()),
  { key: () => userId() } // Reactive function key
);

// Fetch user 1
userResource.get();

// To fetch a different user, change the key and call get again
userId(2);
userResource.get();
```

### Auto-Fetch
Set `auto: true` to automatically refetch when reactive key dependencies change. This eliminates the need to manually call `.get()` after key changes.

```typescript
const userId = signal(1);

const userResource = resource(
  (id) => fetch(`/api/users/${id}`).then(r => r.json()),
  { 
    key: () => userId(), // Reactive key function
    auto: true // Automatically refetch when userId changes
  }
);

// Initial fetch happens automatically on first effect run
// No need to call userResource.get()

// Changing userId automatically triggers a new fetch
userId(2); // Resource automatically fetches user 2
userId(3); // Resource automatically fetches user 3
```

<div role="alert" class="alert alert-info alert-soft text-base">
  <span>ℹ️</span>
  <span>Auto-fetch only works with reactive key functions. Static key values won't trigger automatic refetches since they don't change. If your key function uses signals or computed values, the resource will automatically track those dependencies and refetch when they change.</span>
</div>

### Caching
Set `cacheTime` (in milliseconds) to enable caching. Each unique key gets its own cache entry.

```typescript
const postsResource = resource(
  (id) => fetch(`/api/posts/${id}`).then(r => r.json()),
  { 
    key: () => postId(),
    cacheTime: 60000 // Cache for 1 minute
  }
);
```

### Data Mutations
To update data after a mutation (e.g., a POST or PUT request), perform the mutation and then call `.invalidate()` on the relevant resource to refetch the fresh data.

```typescript
async function updateUser(data) {
  await fetch(`/api/users/${userId()}`, { method: 'PUT', body: JSON.stringify(data) });
  
  // Invalidate the user resource to get the updated data
  userResource.invalidate();
}
```

## Important Considerations

### Manual vs Auto Fetching

By default, resources don't auto-fetch on creation - you must explicitly call `.get()` or `.request()`. Set `auto: true` for automatic fetching when key dependencies change.

```typescript
// ❌ No data fetched yet (manual mode)
const userResource = resource(() => fetch('/api/user'));
console.log(userResource.data()); // undefined
// ✅ Explicitly fetch data
userResource.get();

// ✅ Auto-fetch mode
const autoResource = resource(() => fetch('/api/user'), { auto: true });
// Data fetches automatically when effect runs
```

### Memory Management

Each unique key creates a separate cache entry - consider key design for large datasets.

```typescript
// ❌ Too many cache entries
{ key: () => Math.random() }
// ✅ Stable, meaningful keys
{ key: () => `user-${userId()}` }
```

### Error Handling

Always check both `error()` and `status()` states for proper error handling.

```typescript
// ✅ Proper error handling
effect(() => {
  if (resource.error()) {
    console.error('Failed:', resource.error());
  }
  if (resource.status() === 'success') {
    console.log('Data:', resource.data());
  }
});
```